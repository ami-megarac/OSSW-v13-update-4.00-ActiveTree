--- lighttpd-1.4.64/src/mod_openssl.c	2022-01-19 23:23:51.000000000 +0530
+++ lighttpd/src/mod_openssl.c	2023-09-14 09:47:04.154244280 +0530
@@ -202,8 +202,10 @@
 static void
 handler_ctx_free (handler_ctx *hctx)
 {
-    if (hctx->ssl) SSL_free(hctx->ssl);
-    free(hctx);
+    if ( hctx->con->dupped != 1) {
+      if (hctx->ssl) SSL_free(hctx->ssl);
+      free(hctx);
+    }
 }
 
 
@@ -1481,7 +1483,7 @@
 
     x.tm_year-= 1900;
     x.tm_mon -= 1;
-    time_t t = timegm(&x);
+    time_t t = lighttpd_timegm(&x);
     return (t != -1) ? TIME64_CAST(t) + offset : t;
 
   #else
@@ -2396,7 +2398,8 @@
        #endif
         SSL_CTX_set_default_read_ahead(s->ssl_ctx, s->ssl_read_ahead);
         SSL_CTX_set_mode(s->ssl_ctx, SSL_CTX_get_mode(s->ssl_ctx)
-                                   | SSL_MODE_ENABLE_PARTIAL_WRITE
+				/* If this SSL mode is enabled, then partial data will be sent in SSL_write. Even though only parital data is written, SSL_write will not return any error value. So disabling this mode */
+                                  // | SSL_MODE_ENABLE_PARTIAL_WRITE
                                    | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER
                                    | SSL_MODE_RELEASE_BUFFERS);
 
@@ -2566,21 +2569,21 @@
                 break;
               case 8: /* ssl.use-sslv2 */
                 conf.ssl_use_sslv2 = (0 != cpv->v.u);
-                log_error(srv->errh, __FILE__, __LINE__, "SSL: "
+                /*log_error(srv->errh, __FILE__, __LINE__, "SSL: "
                   "ssl.use-sslv2 is deprecated and will soon be removed.  "
                   "It is disabled by default.  "
                   "Many modern TLS libraries no longer support SSLv2.");
-                break;
+                break;*/
               case 9: /* ssl.use-sslv3 */
                 conf.ssl_use_sslv3 = (0 != cpv->v.u);
-                log_error(srv->errh, __FILE__, __LINE__, "SSL: "
+                /*log_error(srv->errh, __FILE__, __LINE__, "SSL: "
                   "ssl.use-sslv3 is deprecated and will soon be removed.  "
                   "It is disabled by default.  "
                   "Many modern TLS libraries no longer support SSLv3.");
                 if (conf.ssl_use_sslv3)
                     log_error(srv->errh, __FILE__, __LINE__, "SSL: "
                       "If needed, use: ssl.openssl.ssl-conf-cmd = "
-                      "(\"MinProtocol\" => \"SSLv3\")");
+                      "(\"MinProtocol\" => \"SSLv3\")");*/
                 break;
               case 10:/* ssl.stek-file */
                 if (!buffer_is_blank(cpv->v.b))
@@ -3281,6 +3284,8 @@
 
     plugin_ssl_ctx * const s = p->ssl_ctxs + srv_sock->sidx;
     hctx->ssl = SSL_new(s->ssl_ctx);
+    //AMI TODO: clear ssl value on socket close
+    con->ssl = hctx->ssl;
     if (NULL != hctx->ssl
         && SSL_set_app_data(hctx->ssl, hctx)
         && SSL_set_fd(hctx->ssl, con->fd)) {
@@ -3306,8 +3311,10 @@
      * (used after handle_connection_shut_wr hook) */
     /* future: might restore prior network_read and network_write fn ptrs */
     hctx->con->is_ssl_sock = 0;
-    /* if called after handle_connection_shut_wr hook, shutdown SHUT_WR */
-    if (-1 == hctx->close_notify) shutdown(hctx->con->fd, SHUT_WR);
+    if ( hctx->con->dupped != 1) {
+      /* if called after handle_connection_shut_wr hook, shutdown SHUT_WR */
+      if (-1 == hctx->close_notify) shutdown(hctx->con->fd, SHUT_WR);
+    }
     hctx->close_notify = 1;
 }
 
@@ -3340,97 +3347,99 @@
         if (1 == hctx->close_notify) return -2;
 
         ERR_clear_error();
-        switch ((ret = SSL_shutdown(hctx->ssl))) {
-        case 1:
-            mod_openssl_detach(hctx);
-            return -2;
-        case 0:
-            /* Drain SSL read buffers in case pending records need processing.
-             * Limit to reading next record to avoid denial of service when CPU
-             * processing TLS is slower than arrival speed of TLS data packets.
-             * (unless hctx->conf.ssl_read_ahead is set)
-             *
-             * references:
-             *
-             * "New session ticket breaks bidirectional shutdown of TLS 1.3 connection"
-             * https://github.com/openssl/openssl/issues/6262
-             *
-             * The peer is still allowed to send data after receiving the
-             * "close notify" event. If the peer did send data it need to be
-             * processed by calling SSL_read() before calling SSL_shutdown() a
-             * second time. SSL_read() will indicate the end of the peer data by
-             * returning <= 0 and SSL_get_error() returning
-             * SSL_ERROR_ZERO_RETURN. It is recommended to call SSL_read()
-             * between SSL_shutdown() calls.
-             *
-             * Additional discussion in "Auto retry in shutdown"
-             * https://github.com/openssl/openssl/pull/6340
-             */
-            ssl_r = SSL_pending(hctx->ssl);
-            if (ssl_r) {
-                do {
-                    char buf[4096];
-                    ret = SSL_read(hctx->ssl, buf, (int)sizeof(buf));
-                } while (ret > 0 && (hctx->conf.ssl_read_ahead||(ssl_r-=ret)));
-            }
-
-            ERR_clear_error();
-            switch ((ret = SSL_shutdown(hctx->ssl))) {
-            case 1:
-                mod_openssl_detach(hctx);
-                return -2;
-            case 0:
-                hctx->close_notify = -1;
-                return 0;
-            default:
-                break;
-            }
-
-            __attribute_fallthrough__
-        default:
-
-            if (!SSL_is_init_finished(hctx->ssl)) {
-                mod_openssl_detach(hctx);
-                return -2;
-            }
-
-            switch ((ssl_r = SSL_get_error(hctx->ssl, ret))) {
-            case SSL_ERROR_ZERO_RETURN:
-            case SSL_ERROR_WANT_WRITE:
-            case SSL_ERROR_WANT_READ:
-                hctx->close_notify = -1;
-                return 0; /* try again later */
-            case SSL_ERROR_SYSCALL:
-                /* perhaps we have error waiting in our error-queue */
-                errh = hctx->r->conf.errh;
-                if (0 != (err = ERR_get_error())) {
-                    do {
-                        log_error(errh, __FILE__, __LINE__,
-                          "SSL: %d %d %s",ssl_r,ret,ERR_error_string(err,NULL));
-                    } while((err = ERR_get_error()));
-                } else if (errno != 0) {
-                    /*ssl bug (see lighttpd ticket #2213): sometimes errno==0*/
-                    switch(errno) {
-                    case EPIPE:
-                    case ECONNRESET:
-                        break;
-                    default:
-                        log_perror(errh, __FILE__, __LINE__,
-                          "SSL (error): %d %d", ssl_r, ret);
-                        break;
-                    }
+        if ( hctx->con->dupped != 1) {
+          switch ((ret = SSL_shutdown(hctx->ssl))) {
+          case 1:
+              mod_openssl_detach(hctx);
+              return -2;
+          case 0:
+              /* Drain SSL read buffers in case pending records need processing.
+              * Limit to reading next record to avoid denial of service when CPU
+              * processing TLS is slower than arrival speed of TLS data packets.
+              * (unless hctx->conf.ssl_read_ahead is set)
+              *
+              * references:
+              *
+              * "New session ticket breaks bidirectional shutdown of TLS 1.3 connection"
+              * https://github.com/openssl/openssl/issues/6262
+              *
+              * The peer is still allowed to send data after receiving the
+              * "close notify" event. If the peer did send data it need to be
+              * processed by calling SSL_read() before calling SSL_shutdown() a
+              * second time. SSL_read() will indicate the end of the peer data by
+              * returning <= 0 and SSL_get_error() returning
+              * SSL_ERROR_ZERO_RETURN. It is recommended to call SSL_read()
+              * between SSL_shutdown() calls.
+              *
+              * Additional discussion in "Auto retry in shutdown"
+              * https://github.com/openssl/openssl/pull/6340
+              */
+              ssl_r = SSL_pending(hctx->ssl);
+              if (ssl_r) {
+                  do {
+                      char buf[4096];
+                      ret = SSL_read(hctx->ssl, buf, (int)sizeof(buf));
+                  } while (ret > 0 && (hctx->conf.ssl_read_ahead||(ssl_r-=ret)));
+              }
+
+              ERR_clear_error();
+                switch ((ret = SSL_shutdown(hctx->ssl))) {
+                case 1:
+                    mod_openssl_detach(hctx);
+                    return -2;
+                case 0:
+                    hctx->close_notify = -1;
+                    return 0;
+                default:
+                    break;
                 }
 
-                break;
-            default:
-                errh = hctx->r->conf.errh;
-                while((err = ERR_get_error())) {
-                    log_error(errh, __FILE__, __LINE__,
-                      "SSL: %d %d %s", ssl_r, ret, ERR_error_string(err, NULL));
-                }
+              __attribute_fallthrough__
+          default:
 
-                break;
-            }
+              if (!SSL_is_init_finished(hctx->ssl)) {
+                  mod_openssl_detach(hctx);
+                  return -2;
+              }
+
+              switch ((ssl_r = SSL_get_error(hctx->ssl, ret))) {
+              case SSL_ERROR_ZERO_RETURN:
+              case SSL_ERROR_WANT_WRITE:
+              case SSL_ERROR_WANT_READ:
+                  hctx->close_notify = -1;
+                  return 0; /* try again later */
+              case SSL_ERROR_SYSCALL:
+                  /* perhaps we have error waiting in our error-queue */
+                  errh = hctx->r->conf.errh;
+                  if (0 != (err = ERR_get_error())) {
+                      do {
+                          log_error(errh, __FILE__, __LINE__,
+                            "SSL: %d %d %s",ssl_r,ret,ERR_error_string(err,NULL));
+                      } while((err = ERR_get_error()));
+                  } else if (errno != 0) {
+                      /*ssl bug (see lighttpd ticket #2213): sometimes errno==0*/
+                      switch(errno) {
+                      case EPIPE:
+                      case ECONNRESET:
+                          break;
+                      default:
+                          log_perror(errh, __FILE__, __LINE__,
+                            "SSL (error): %d %d", ssl_r, ret);
+                          break;
+                      }
+                  }
+
+                  break;
+              default:
+                  errh = hctx->r->conf.errh;
+                  while((err = ERR_get_error())) {
+                      log_error(errh, __FILE__, __LINE__,
+                        "SSL: %d %d %s", ssl_r, ret, ERR_error_string(err, NULL));
+                  }
+
+                  break;
+              }
+          }
         }
         ERR_clear_error();
         hctx->close_notify = -1;
@@ -3442,7 +3451,7 @@
 {
     plugin_data *p = p_d;
     handler_ctx *hctx = con->plugin_ctx[p->id];
-    if (NULL != hctx) {
+    if (NULL != hctx && hctx->con->dupped != 1 ) {
         con->plugin_ctx[p->id] = NULL;
         handler_ctx_free(hctx);
     }
@@ -3878,3 +3887,42 @@
 }
 
 #endif /* BORINGSSL_API_VERSION || LIBRESSL_VERSION_NUMBER */
+
+
+void
+dump_buffer(char *Buffer, int size)
+{
+  int i;
+  int j;
+
+  for (i=0;i<size;i++){
+    if ((!(i % 16))&& (i!=0)){
+      printf("   ");
+      for (j=i-16;j<i;j++){
+        if (isprint((unsigned char)Buffer[j]))
+            printf("%c",(unsigned char)Buffer[j]);
+        else{
+            // printf(".");
+        }
+      }
+      printf("\n");
+    }
+    printf("%02X ",(unsigned char)Buffer[i]);
+  }
+  printf("   ");
+
+  if (size%16){
+    for(j=0;j<(16-(size%16));j++)
+      printf("   ");
+  }
+
+  for(j=(size-1)-((size-1)%16);j<size;j++){
+    if (isprint((unsigned char)Buffer[j]))
+      printf("%c",(unsigned char)Buffer[j]);
+    else{
+    //   printf(".");
+    }
+  }
+  printf("\n");
+
+}
