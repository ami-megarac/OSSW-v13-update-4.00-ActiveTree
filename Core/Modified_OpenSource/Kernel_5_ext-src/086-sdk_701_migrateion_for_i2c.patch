diff -Naur linux_old/drivers/i2c/busses/ast2600-i2c-global.c linux/drivers/i2c/busses/ast2600-i2c-global.c
--- linux_old/drivers/i2c/busses/ast2600-i2c-global.c	2021-09-07 11:25:49.188375000 +0800
+++ linux/drivers/i2c/busses/ast2600-i2c-global.c	2021-09-07 11:46:38.508363920 +0800
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- *  Aspeed I2C Interrupt Controller.
+ * Aspeed I2C Interrupt Controller.
  *
- *  Copyright (C) 2012-2017 ASPEED Technology Inc.
- *  Copyright 2017 IBM Corporation
- *  Copyright 2017 Google, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License version 2 as
- *  published by the Free Software Foundation.
+ * Copyright (C) ASPEED Technology Inc.
+ * Ryan Chen <ryan_chen@aspeedtech.com>
  */
 #include <linux/clk.h>
 #include <linux/irq.h>
@@ -31,56 +27,61 @@
 	u32			i2c_irq_mask;
 	struct reset_control	*rst;
 	struct irq_domain	*irq_domain;
-	int			bus_num;	
+	int			bus_num;
 };
 
 static const struct of_device_id aspeed_i2c_ic_of_match[] = {
 	{ .compatible = "aspeed,ast2600-i2c-global", .data = (void *) 0},	
-	{},
+	{ }
 };
+MODULE_DEVICE_TABLE(of, aspeed_i2c_ic_of_match);
 
 struct aspeed_i2c_base_clk {
 	const char	*name;
 	unsigned long	base_freq;
 };
 
-/* assign 4 base clock 
- * [31:24] base clk4 : 1M for 1KHz
- * [23:16] base clk3 : 4M for 400KHz	 
- * [15:08] base clk2 : 10M for 1MHz  
- * [00:07] base clk1 : 35M for 3.4MHz	 
-*/
+/* assign 4 base clock
+ * [31:24] base clk4 : 1M for 100KHz
+ * [23:16] base clk3 : 4M for 400KHz
+ * [15:08] base clk2 : 10M for 1MHz
+ * [00:07] base clk1 : 35M for 3.4MHz
+ */
 #define BASE_CLK_COUNT 4
 
 static const struct aspeed_i2c_base_clk i2c_base_clk[BASE_CLK_COUNT] = {
 	/* name	target_freq */
-	{  "base_clk0",	1000000 },	//1M
-	{  "base_clk1",	4000000 },	//4M
-	{  "base_clk2",	10000000 },	//10M
-	{  "base_clk3",	35000000 },	//35M
+	{  "base_clk0",	1000000 },	/* 1M */
+	{  "base_clk1",	4000000 },	/* 4M */
+	{  "base_clk2",	10000000 },	/* 10M */
+	{  "base_clk3",	40000000 },	/* 40M */
 };
 
 static u32 aspeed_i2c_ic_get_new_clk_divider(unsigned long	base_clk, struct device_node *node)
 {
 	struct clk_hw_onecell_data *onecell;
+	unsigned long base_freq;
+	u32 clk_divider = 0;
 	struct clk_hw *hw;
 	int err;
-	u32 clk_divider = 0;
-	int i, j;
-	unsigned long base_freq;
+	int i;
+	int j;
+
+	onecell = kzalloc(sizeof(*onecell) +
+			  (BASE_CLK_COUNT * sizeof(struct clk_hw *)),
+			  GFP_KERNEL);
 
-	onecell = kzalloc(sizeof(*onecell) + (BASE_CLK_COUNT * sizeof(struct clk_hw *)), GFP_KERNEL);
 	if (!onecell) {
-		pr_err("allocate clk_hw \n");		
+		pr_err("allocate clk_hw\n");
 		return 0;
 	}
 
 	onecell->num = BASE_CLK_COUNT;
 
-//	printk("base_clk %ld \n", base_clk);
-	for(j = 0; j < BASE_CLK_COUNT; j++) {
-//		printk("target clk : %ld \n", i2c_base_clk[j].base_freq);		
-		for(i = 0; i < 0xff; i++) {
+	pr_debug("base_clk %ld\n", base_clk);
+	for (j = 0; j < BASE_CLK_COUNT; j++) {
+		pr_debug("target clk : %ld\n", i2c_base_clk[j].base_freq);
+		for (i = 0; i < 0xff; i++) {
 			/*
 			 * i maps to div:
 			 * 0x00: div 1
@@ -96,7 +97,7 @@
 			if(base_freq <= i2c_base_clk[j].base_freq)
 				break;
 		}
-		printk("i2cg - %s : %ld \n", i2c_base_clk[j].name, base_freq);
+		pr_info("i2cg - %s : %ld\n", i2c_base_clk[j].name, base_freq);
 		hw = clk_hw_register_fixed_rate(NULL, i2c_base_clk[j].name, NULL, 0, base_freq);
 		if (IS_ERR(hw)) {
 			pr_err("failed to register input clock: %ld\n", PTR_ERR(hw));
@@ -107,78 +108,64 @@
 	}
 
 	err = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, onecell);
-	if (err) {
+	if (err)
 		pr_err("failed to add i2c base clk provider: %d\n", err);
-	}
-	
+
 	return clk_divider;
 }
 
 static int aspeed_i2c_global_probe(struct platform_device *pdev)
 {
-	struct aspeed_i2c_ic *i2c_ic;
 	struct device_node *node = pdev->dev.of_node;
-	const struct of_device_id *match;
-	struct clk *parent_clk;	
 	unsigned long	parent_clk_frequency;
+	struct aspeed_i2c_ic *i2c_ic;
+	struct clk *parent_clk;
+	struct resource *res;
 	u32 clk_divider;
-	int ret = 0;
-	pr_info("i2c global probe \n");
-	match = of_match_node(aspeed_i2c_ic_of_match, node);
-	if (!match)
-		return -ENOMEM;
-
-	i2c_ic = kzalloc(sizeof(*i2c_ic), GFP_KERNEL);
-	if (!i2c_ic)
-		return -ENOMEM;
-
-	i2c_ic->base = of_iomap(node, 0);
-	if (!i2c_ic->base) {
-		ret = -ENOMEM;
-		goto err_free_ic;
-	}
 
-	i2c_ic->bus_num = (int) match->data;
+	pr_info("i2c global probe !\n");
+
+	i2c_ic = devm_kzalloc(&pdev->dev, sizeof(*i2c_ic), GFP_KERNEL);
+	if (IS_ERR(i2c_ic))
+		return PTR_ERR(i2c_ic);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	i2c_ic->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(i2c_ic->base))
+		return PTR_ERR(i2c_ic->base);
 
+	i2c_ic->bus_num = (int)device_get_match_data(&pdev->dev);
 	if (i2c_ic->bus_num) {
-		i2c_ic->parent_irq = irq_of_parse_and_map(node, 0);
-		if (i2c_ic->parent_irq < 0) {
-			ret = i2c_ic->parent_irq;
-			goto err_iounmap;
-		}
-	} 
+		i2c_ic->parent_irq = platform_get_irq(pdev, 0);
+		if (i2c_ic->parent_irq < 0)
+			return i2c_ic->parent_irq;
+	}
 
 	i2c_ic->rst = devm_reset_control_get_exclusive(&pdev->dev, NULL);
-
 	if (IS_ERR(i2c_ic->rst)) {
 		dev_dbg(&pdev->dev,
 			"missing or invalid reset controller device tree entry");
 	} else {
-		//SCU I2C Reset 
+		/* SCU I2C Reset */
 		reset_control_assert(i2c_ic->rst);
 		udelay(3);
 		reset_control_deassert(i2c_ic->rst);
 	}
-	
+
 	/* ast2600 init */
-	writel(ASPEED_I2CG_SLAVE_PKT_NAK | ASPEED_I2CG_CTRL_NEW_REG | ASPEED_I2CG_CTRL_NEW_CLK_DIV, i2c_ic->base + ASPEED_I2CG_CTRL);
+	writel(ASPEED_I2CG_SLAVE_PKT_NAK | ASPEED_I2CG_CTRL_NEW_REG | ASPEED_I2CG_CTRL_NEW_CLK_DIV,
+	       i2c_ic->base + ASPEED_I2CG_CTRL);
 	parent_clk = devm_clk_get(&pdev->dev, NULL);
 	if (IS_ERR(parent_clk))
 		return PTR_ERR(parent_clk);
 	parent_clk_frequency = clk_get_rate(parent_clk);
-//	printk("parent_clk_frequency %ld \n", parent_clk_frequency);
+	pr_debug("parent_clk_frequency %ld\n", parent_clk_frequency);
 	clk_divider = aspeed_i2c_ic_get_new_clk_divider(parent_clk_frequency, node);
 	writel(clk_divider, i2c_ic->base + ASPEED_I2CG_CLK_DIV_CTRL);
-	
+
 	pr_info("i2c global registered \n");
 
 	return 0;
-
-err_iounmap:
-	iounmap(i2c_ic->base);
-err_free_ic:
-	kfree(i2c_ic);
-	return ret;
 }
 
 static struct platform_driver aspeed_i2c_ic_driver = {
diff -Naur linux_old/drivers/i2c/busses/ast2600-i2c-global.h linux/drivers/i2c/busses/ast2600-i2c-global.h
--- linux_old/drivers/i2c/busses/ast2600-i2c-global.h	2021-09-07 11:25:48.856375000 +0800
+++ linux/drivers/i2c/busses/ast2600-i2c-global.h	2021-09-07 11:07:24.894362454 +0800
@@ -8,7 +8,9 @@
 
 
 #ifndef AST2600_I2C_GLOBAL_H
-#define AST2600_I2C_GLOBAL_H 1
+#define AST2600_I2C_GLOBAL_H
+
+#include <linux/bits.h>
 
 #define ASPEED_I2CG_ISR				0x00
 #define ASPEED_I2CG_SLAVE_ISR		0x04	/* ast2600 */
diff -Naur linux_old/drivers/i2c/busses/i2c-aspeed.c linux/drivers/i2c/busses/i2c-aspeed.c
--- linux_old/drivers/i2c/busses/i2c-aspeed.c	2021-09-07 11:25:49.180375000 +0800
+++ linux/drivers/i2c/busses/i2c-aspeed.c	2021-09-07 11:07:24.922362453 +0800
@@ -78,6 +78,7 @@
  * These share bit definitions, so use the same values for the enable &
  * status bits.
  */
+#define ASPEED_I2CD_INTR_RECV_MASK			0xf000ffff
 #define ASPEED_I2CD_INTR_SDA_DL_TIMEOUT			BIT(14)
 #define ASPEED_I2CD_INTR_BUS_RECOVER_DONE		BIT(13)
 #define ASPEED_I2CD_INTR_SLAVE_MATCH			BIT(7)
@@ -263,6 +264,11 @@
 
 	/* Slave was requested, restart state machine. */
 	if (irq_status & ASPEED_I2CD_INTR_SLAVE_MATCH) {
+		if (irq_status & ASPEED_I2CD_INTR_TX_NAK &&
+			bus->slave_state == ASPEED_I2C_SLAVE_READ_PROCESSED) {
+			irq_handled |= ASPEED_I2CD_INTR_TX_NAK;
+			i2c_slave_event(slave, I2C_SLAVE_STOP, &value);
+		}
 		irq_handled |= ASPEED_I2CD_INTR_SLAVE_MATCH;
 		bus->slave_state = ASPEED_I2C_SLAVE_START;
 	}
@@ -341,6 +347,12 @@
 		break;
 	}
 
+	if (irq_handled != irq_status)
+		dev_err(bus->dev,
+			"irq handled != irq. expected %x, but was %x\n",
+			irq_status, irq_handled);
+	writel(irq_handled, bus->base + ASPEED_I2C_INTR_STS_REG);
+
 	return irq_handled;
 }
 #endif /* CONFIG_I2C_SLAVE */
@@ -416,6 +428,11 @@
 	u8 recv_byte;
 	int ret;
 
+	irq_status = readl(bus->base + ASPEED_I2C_INTR_STS_REG);
+	/* Ack all interrupt bits. */
+	writel(irq_status, bus->base + ASPEED_I2C_INTR_STS_REG);
+	readl(bus->base + ASPEED_I2C_INTR_STS_REG);
+
 	if (irq_status & ASPEED_I2CD_INTR_BUS_RECOVER_DONE) {
 		bus->master_state = ASPEED_I2C_MASTER_INACTIVE;
 		irq_handled |= ASPEED_I2CD_INTR_BUS_RECOVER_DONE;
@@ -514,7 +531,7 @@
 			goto error_and_stop;
 		}
 		irq_handled |= ASPEED_I2CD_INTR_TX_ACK;
-		/* fall through */
+		fallthrough;
 	case ASPEED_I2C_MASTER_TX_FIRST:
 		if (bus->buf_index < msg->len) {
 			bus->master_state = ASPEED_I2C_MASTER_TX;
@@ -530,7 +547,7 @@
 		/* RX may not have completed yet (only address cycle) */
 		if (!(irq_status & ASPEED_I2CD_INTR_RX_DONE))
 			goto out_no_complete;
-		/* fall through */
+		fallthrough;
 	case ASPEED_I2C_MASTER_RX:
 		if (unlikely(!(irq_status & ASPEED_I2CD_INTR_RX_DONE))) {
 			dev_err(bus->dev, "master failed to RX\n");
@@ -600,6 +617,10 @@
 		bus->master_xfer_result = bus->msgs_index + 1;
 	complete(&bus->cmd_complete);
 out_no_complete:
+	if (irq_status != irq_handled)
+		dev_err(bus->dev,
+			"irq handled != irq. expected 0x%08x, but was 0x%08x\n",
+			irq_status, irq_handled);
 	return irq_handled;
 }
 
@@ -610,10 +631,7 @@
 
 	spin_lock(&bus->lock);
 	irq_received = readl(bus->base + ASPEED_I2C_INTR_STS_REG);
-	/* Ack all interrupts except for Rx done */
-	writel(irq_received & ~ASPEED_I2CD_INTR_RX_DONE,
-	       bus->base + ASPEED_I2C_INTR_STS_REG);
-	readl(bus->base + ASPEED_I2C_INTR_STS_REG);
+	irq_received &= ASPEED_I2CD_INTR_RECV_MASK;
 	irq_remaining = irq_received;
 
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
@@ -655,12 +673,6 @@
 			"irq handled != irq. expected 0x%08x, but was 0x%08x\n",
 			irq_received, irq_handled);
 
-	/* Ack Rx done */
-	if (irq_received & ASPEED_I2CD_INTR_RX_DONE) {
-		writel(ASPEED_I2CD_INTR_RX_DONE,
-		       bus->base + ASPEED_I2C_INTR_STS_REG);
-		readl(bus->base + ASPEED_I2C_INTR_STS_REG);
-	}
 	spin_unlock(&bus->lock);
 	return irq_remaining ? IRQ_NONE : IRQ_HANDLED;
 }
diff -Naur linux_old/drivers/i2c/busses/i2c-new-aspeed.c linux/drivers/i2c/busses/i2c-new-aspeed.c
--- linux_old/drivers/i2c/busses/i2c-new-aspeed.c	2021-09-07 11:25:49.164375000 +0800
+++ linux/drivers/i2c/busses/i2c-new-aspeed.c	2021-09-07 11:07:24.922362453 +0800
@@ -1,10 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0-only
 /*
- * i2c-new-aspeed.c - I2C driver for the Aspeed SoC
+ * I2C driver for the Aspeed SoC
  *
  * Copyright (C) ASPEED Technology Inc.
  * Ryan Chen <ryan_chen@aspeedtech.com>
- *
  */
 #include <linux/clk.h>
 #include <linux/err.h>
@@ -25,12 +24,12 @@
 #include "ast2600-i2c-global.h"
 
 /***************************************************************************/
-//AST2600 reg
+/* AST2600 reg */
 /* 0x00 : I2CC Master/Slave Function Control Register  */
 #define AST_I2CC_FUN_CTRL		0x00
 #define AST_I2CC_SLAVE_ADDR_RX_EN		BIT(20)
-#define AST_I2CC_MASTER_RETRY_MASK		(0x3 << 18)
-#define AST_I2CC_MASTER_RETRY(x)		((x & 0x3) << 18)
+#define AST_I2CC_MASTER_RETRY_MASK		GENMASK(19, 18)
+#define AST_I2CC_MASTER_RETRY(x)		(((x) & GENMASK(1, 0)) << 18)
 #define AST_I2CC_BUS_AUTO_RELEASE		BIT(17)
 #define AST_I2CC_M_SDA_LOCK_EN			BIT(16)
 #define AST_I2CC_MULTI_MASTER_DIS		BIT(15)
@@ -45,17 +44,17 @@
 
 /* 0x04 : I2CC Master/Slave Clock and AC Timing Control Register #1 */
 #define AST_I2CC_AC_TIMING		0x04
-#define AST_I2CC_tTIMEOUT(x)			((x & 0x1f) << 24)
-#define AST_I2CC_tCKHIGHMin(x)			((x & 0xf) << 20)
-#define AST_I2CC_tCKHIGH(x)			((x & 0xf) << 16)
-#define AST_I2CC_tCKLOW(x)			((x & 0xf) << 12)
-#define AST_I2CC_tHDDAT(x)			((x & 0x3) << 10)
-#define AST_I2CC_toutBaseCLK(x)			((x & 0x3) << 8)
-#define AST_I2CC_tBaseCLK(x)			(x & 0xf)
+#define AST_I2CC_TTIMEOUT(x)			(((x) & GENMASK(4, 0)) << 24)
+#define AST_I2CC_TCKHIGHMIN(x)			(((x) & GENMASK(3, 0)) << 20)
+#define AST_I2CC_TCKHIGH(x)			(((x) & GENMASK(3, 0)) << 16)
+#define AST_I2CC_TCKLOW(x)			(((x) & GENMASK(3, 0)) << 12)
+#define AST_I2CC_THDDAT(x)			(((x) & GENMASK(1, 0)) << 10)
+#define AST_I2CC_TOUTBASECLK(x)			(((x) & GENMASK(1, 0)) << 8)
+#define AST_I2CC_TBASECLK(x)			((x) & GENMASK(3, 0))
 
 /* 0x08 : I2CC Master/Slave Transmit/Receive Byte Buffer Register */
 #define AST_I2CC_STS_AND_BUFF		0x08
-#define AST_I2CC_TX_DIR_MASK			(0x7 << 29)
+#define AST_I2CC_TX_DIR_MASK			GENMASK(31, 29)
 #define AST_I2CC_SDA_OE				BIT(28)
 #define AST_I2CC_SDA_O				BIT(27)
 #define AST_I2CC_SCL_OE				BIT(26)
@@ -65,14 +64,14 @@
 #define AST_I2CC_SDA_LINE_STS			BIT(17)
 #define AST_I2CC_BUS_BUSY_STS			BIT(16)
 
-#define AST_I2CC_GET_RX_BUFF(x)			((x >> 8) & 0xff)
+#define AST_I2CC_GET_RX_BUFF(x)			(((x) >> 8) & GENMASK(7, 0))
 
 /* 0x0C : I2CC Master/Slave Pool Buffer Control Register  */
 #define AST_I2CC_BUFF_CTRL		0x0C
-#define AST_I2CC_GET_RX_BUF_LEN(x)		((x >> 24) & 0x3f)
-#define AST_I2CC_SET_RX_BUF_LEN(x)		(((x - 1) & 0x1f) << 16)
-#define AST_I2CC_SET_TX_BUF_LEN(x)		(((x - 1) & 0x1f) << 8)
-#define AST_I2CC_GET_TX_BUF_LEN(x)		(((x >> 8) & 0x1f) + 1)
+#define AST_I2CC_GET_RX_BUF_LEN(x)		(((x) >> 24) & GENMASK(5, 0))
+#define AST_I2CC_SET_RX_BUF_LEN(x)		((((x) - 1) & GENMASK(4, 0)) << 16)
+#define AST_I2CC_SET_TX_BUF_LEN(x)		((((x) - 1) & GENMASK(4, 0)) << 8)
+#define AST_I2CC_GET_TX_BUF_LEN(x)		((((x) >> 8) & GENMASK(4, 0)) + 1)
 
 /* 0x10 : I2CM Master Interrupt Control Register */
 #define AST_I2CM_IER			0x10
@@ -98,7 +97,7 @@
 
 /* 0x18 : I2CM Master Command/Status Register   */
 #define AST_I2CM_CMD_STS		0x18
-#define AST_I2CM_PKT_ADDR(x)			((x & 0x7f) << 24)
+#define AST_I2CM_PKT_ADDR(x)			(((x) & GENMASK(6, 0)) << 24)
 #define AST_I2CM_PKT_EN				BIT(16)
 #define AST_I2CM_SDA_OE_OUT_DIR			BIT(15)
 #define AST_I2CM_SDA_O_OUT_DIR			BIT(14)
@@ -124,32 +123,30 @@
 /* 0x1C : I2CM Master DMA Transfer Length Register	 */
 #define AST_I2CM_DMA_LEN		0x1C
 /* Tx Rx support length 1 ~ 4096 */
-#define AST_I2CM_SET_RX_DMA_LEN(x)	((((x) & 0xfff) << 16) | BIT(31))
-#define AST_I2CM_SET_TX_DMA_LEN(x)	(((x) & 0xfff) | BIT(15))
+#define AST_I2CM_SET_RX_DMA_LEN(x)	((((x) & GENMASK(11, 0)) << 16) | BIT(31))
+#define AST_I2CM_SET_TX_DMA_LEN(x)	(((x) & GENMASK(11, 0)) | BIT(15))
 
 /* 0x20 : I2CS Slave Interrupt Control Register   */
 #define AST_I2CS_IER			0x20
 /* 0x24 : I2CS Slave Interrupt Status Register	 */
 #define AST_I2CS_ISR			0x24
 
-#define AST_I2CS_ADDR_INDICAT_MASK	(3 << 30)
+#define AST_I2CS_ADDR_INDICATE_MASK	GENMASK(31, 30)
 #define AST_I2CS_SLAVE_PENDING			BIT(29)
 
-#define AST_I2CS_Wait_TX_DMA			BIT(25)
-#define AST_I2CS_Wait_RX_DMA			BIT(24)
-
+#define AST_I2CS_WAIT_TX_DMA			BIT(25)
+#define AST_I2CS_WAIT_RX_DMA			BIT(24)
 
 #define AST_I2CS_ADDR3_NAK			BIT(22)
 #define AST_I2CS_ADDR2_NAK			BIT(21)
 #define AST_I2CS_ADDR1_NAK			BIT(20)
 
-#define AST_I2CS_ADDR_MASK			(3 << 18)
+#define AST_I2CS_ADDR_MASK			GENMASK(19, 18)
 #define AST_I2CS_PKT_ERROR			BIT(17)
 #define AST_I2CS_PKT_DONE			BIT(16)
 #define AST_I2CS_INACTIVE_TO			BIT(15)
-//
+
 #define AST_I2CS_SLAVE_MATCH			BIT(7)
-//
 #define AST_I2CS_ABNOR_STOP			BIT(5)
 #define AST_I2CS_STOP				BIT(4)
 #define AST_I2CS_RX_DONE_NAK			BIT(3)
@@ -159,7 +156,7 @@
 
 /* 0x28 : I2CS Slave CMD/Status Register   */
 #define AST_I2CS_CMD_STS		0x28
-#define AST_I2CS_ACTIVE_ALL			(0x3 << 17)
+#define AST_I2CS_ACTIVE_ALL			GENMASK(18, 17)
 #define AST_I2CS_PKT_MODE_EN			BIT(16)
 #define AST_I2CS_AUTO_NAK_NOADDR		BIT(15)
 #define AST_I2CS_AUTO_NAK_EN			BIT(14)
@@ -174,11 +171,11 @@
 #define AST_I2CS_TX_CMD				BIT(2)
 
 #define AST_I2CS_DMA_LEN		0x2C
-#define AST_I2CS_SET_RX_DMA_LEN(x)	((((x - 1) & 0xfff) << 16) | BIT(31))
-#define AST_I2CS_RX_DMA_LEN_MASK	(0xfff << 16)
+#define AST_I2CS_SET_RX_DMA_LEN(x)	(((((x) - 1) & GENMASK(11, 0)) << 16) | BIT(31))
+#define AST_I2CS_RX_DMA_LEN_MASK	(GENMASK(11, 0) << 16)
 
-#define AST_I2CS_SET_TX_DMA_LEN(x)	(((x - 1) & 0xfff) | BIT(15))
-#define AST_I2CS_TX_DMA_LEN_MASK	0xfff
+#define AST_I2CS_SET_TX_DMA_LEN(x)	((((x) - 1) & GENMASK(11, 0)) | BIT(15))
+#define AST_I2CS_TX_DMA_LEN_MASK	GENMASK(11, 0)
 
 /* I2CM Master DMA Tx Buffer Register   */
 #define AST_I2CM_TX_DMA			0x30
@@ -191,23 +188,22 @@
 
 #define AST_I2CS_ADDR_CTRL		0x40
 
-#define	AST_I2CS_ADDR3_MASK		(0x7f << 16)
-#define	AST_I2CS_ADDR2_MASK		(0x7f << 8)
-#define	AST_I2CS_ADDR1_MASK		0x7f
-
+#define	AST_I2CS_ADDR3_MASK		GENMASK(22, 16)
+#define	AST_I2CS_ADDR2_MASK		GENMASK(14, 8)
+#define	AST_I2CS_ADDR1_MASK		GENMASK(6, 0)
 
 #define AST_I2CM_DMA_LEN_STS		0x48
 #define AST_I2CS_DMA_LEN_STS		0x4C
 
-#define AST_I2C_GET_TX_DMA_LEN(x)		(x & 0x1fff)
-#define AST_I2C_GET_RX_DMA_LEN(x)		((x >> 16) & 0x1fff)
+#define AST_I2C_GET_TX_DMA_LEN(x)		((x) & GENMASK(12, 0))
+#define AST_I2C_GET_RX_DMA_LEN(x)		(((x) >> 16) & GENMASK(12, 0))
 
 /* 0x40 : Slave Device Address Register */
 #define AST_I2CS_ADDR3_ENABLE			BIT(23)
-#define AST_I2CS_ADDR3(x)			(x << 16)
+#define AST_I2CS_ADDR3(x)			((x) << 16)
 
 #define AST_I2CS_ADDR2_ENABLE			BIT(15)
-#define AST_I2CS_ADDR2(x)			(x << 8)
+#define AST_I2CS_ADDR2(x)			((x) << 8)
 #define AST_I2CS_ADDR1_ENABLE			BIT(7)
 #define AST_I2CS_ADDR1(x)			(x)
 
@@ -218,8 +214,7 @@
 
 #define ASPEED_I2C_DMA_SIZE		4096
 
-#define SLAVE_TRIGGER_CMD		\
-	(AST_I2CS_ACTIVE_ALL | AST_I2CS_PKT_MODE_EN | AST_I2CS_AUTO_NAK_EN)
+#define SLAVE_TRIGGER_CMD       (AST_I2CS_ACTIVE_ALL | AST_I2CS_PKT_MODE_EN | AST_I2CS_AUTO_NAK_EN)
 
 struct ast_i2c_timing_table {
 	u32 divisor;
@@ -373,7 +368,6 @@
 	BYTE_MODE = 0,
 	BUFF_MODE,
 	DMA_MODE,
-
 };
 
 struct aspeed_new_i2c_bus {
@@ -400,11 +394,11 @@
 	/* master structure */
 	int					cmd_err;
 	struct completion	cmd_complete;
-	struct i2c_msg		*msgs;	//cur xfer msgs
-	size_t				buf_index;	//buffer mode idx
+	struct i2c_msg		*msgs;	/* cur xfer msgs */
+	size_t				buf_index;	/* buffer mode idx */
 	/* cur xfer msgs index*/
 	int					msgs_index;
-	int					msgs_count;	//total msgs
+	int					msgs_count;	/* total msgs */
 	dma_addr_t			master_dma_addr;
 	/*total xfer count */
 	int					master_xfer_cnt;
@@ -423,64 +417,62 @@
 
 static u32 aspeed_select_i2c_clock(struct aspeed_new_i2c_bus *i2c_bus)
 {
-	int i;
-	u32 data;
-	int div = 0;
-	int divider_ratio = 0;
+	unsigned long base_clk1;
+	unsigned long base_clk2;
+	unsigned long base_clk3;
+	unsigned long base_clk4;
+	int baseclk_idx;
 	u32 clk_div_reg;
+	u32 scl_low;
+	u32 scl_high;
+	int divisor;
 	int inc = 0;
-	unsigned long base_clk1, base_clk2, base_clk3, base_clk4;
-	u32 scl_low, scl_high;
+	u32 data;
+	int i;
 
 	if (i2c_bus->clk_div_mode) {
-		regmap_read(i2c_bus->global_reg, ASPEED_I2CG_CLK_DIV_CTRL,
-			    &clk_div_reg);
-		base_clk1 = (i2c_bus->apb_clk*10) /
-				((((clk_div_reg & 0xff) + 2) * 10) / 2);
-		base_clk2 = (i2c_bus->apb_clk*10) /
+		regmap_read(i2c_bus->global_reg, ASPEED_I2CG_CLK_DIV_CTRL, &clk_div_reg);
+		base_clk1 = (i2c_bus->apb_clk * 10) / ((((clk_div_reg & 0xff) + 2) * 10) / 2);
+		base_clk2 = (i2c_bus->apb_clk * 10) /
 				(((((clk_div_reg >> 8) & 0xff) + 2) * 10) / 2);
-		base_clk3 = (i2c_bus->apb_clk*10) /
+		base_clk3 = (i2c_bus->apb_clk * 10) /
 				(((((clk_div_reg >> 16) & 0xff) + 2) * 10) / 2);
-		base_clk4 = (i2c_bus->apb_clk*10) /
+		base_clk4 = (i2c_bus->apb_clk * 10) /
 				(((((clk_div_reg >> 24) & 0xff) + 2) * 10) / 2);
-		if (i2c_bus->bus_frequency <= (base_clk1/10)) {
-			div = 1;
-			divider_ratio = base_clk1 / i2c_bus->bus_frequency;
-		} else if ((i2c_bus->bus_frequency > (base_clk1/10)) &&
-				(i2c_bus->bus_frequency <= (base_clk2/10))) {
-			div = 2;
-			divider_ratio = base_clk2 / i2c_bus->bus_frequency;
-		} else if ((i2c_bus->bus_frequency > (base_clk2/10)) &&
-				(i2c_bus->bus_frequency <= (base_clk3/10))) {
-			div = 3;
-			divider_ratio = base_clk3 / i2c_bus->bus_frequency;
-		} else if ((i2c_bus->bus_frequency > (base_clk3/10)) &&
-				(i2c_bus->bus_frequency <= (base_clk4/10))) {
-			div = 4;
-			divider_ratio = base_clk4 / i2c_bus->bus_frequency;
+		if (i2c_bus->bus_frequency <= (base_clk1 / 10)) {
+			baseclk_idx = 1;
+			divisor = DIV_ROUND_UP(base_clk1, i2c_bus->bus_frequency);
+		} else if ((i2c_bus->bus_frequency > (base_clk1 / 10)) &&
+			   (i2c_bus->bus_frequency <= (base_clk2 / 10))) {
+			baseclk_idx = 2;
+			divisor = DIV_ROUND_UP(base_clk2, i2c_bus->bus_frequency);
+		} else if ((i2c_bus->bus_frequency > (base_clk2 / 10)) &&
+			   (i2c_bus->bus_frequency <= (base_clk3 / 10))) {
+			baseclk_idx = 3;
+			divisor = DIV_ROUND_UP(base_clk3, i2c_bus->bus_frequency);
+		} else if ((i2c_bus->bus_frequency > (base_clk3 / 10)) &&
+			   (i2c_bus->bus_frequency <= (base_clk4 / 10))) {
+			baseclk_idx = 4;
+			divisor = DIV_ROUND_UP(base_clk4, i2c_bus->bus_frequency);
 			inc = 0;
-			while ((divider_ratio + inc) > 32) {
-				inc |= divider_ratio & 0x1;
-				divider_ratio >>= 1;
-				div++;
+			while ((divisor + inc) > 32) {
+				inc |= divisor & 0x1;
+				divisor >>= 1;
+				baseclk_idx++;
 			}
-			divider_ratio += inc;
+			divisor += inc;
 		} else {
-			div = 0;
-			divider_ratio = i2c_bus->apb_clk /
-					i2c_bus->bus_frequency;
-			divider_ratio = 5;
+			baseclk_idx = 0;
+			divisor = DIV_ROUND_UP(i2c_bus->apb_clk, i2c_bus->bus_frequency);
 		}
-		div &= 0xf;
-		scl_low = ((divider_ratio >> 1) - 1) & 0xf;
-		scl_high = (divider_ratio - scl_low - 2) & 0xf;
+		baseclk_idx &= 0xf;
+		scl_low = ((divisor >> 1) - 1) & 0xf;
+		scl_high = (divisor - scl_low - 2) & 0xf;
 		/* Divisor : Base Clock : tCKHighMin : tCK High : tCK Low  */
-		data = ((scl_high - 1) << 20) | (scl_high << 16) |
-				(scl_low << 12) | (div);
+		data = ((scl_high - 1) << 20) | (scl_high << 16) | (scl_low << 12) | (baseclk_idx);
 	} else {
 		for (i = 0; i < ARRAY_SIZE(aspeed_old_i2c_timing_table); i++) {
-			if ((i2c_bus->apb_clk /
-			     aspeed_old_i2c_timing_table[i].divisor) <
+			if ((i2c_bus->apb_clk / aspeed_old_i2c_timing_table[i].divisor) <
 			    i2c_bus->bus_frequency) {
 				break;
 			}
@@ -492,36 +484,30 @@
 
 static u8 aspeed_new_i2c_recover_bus(struct aspeed_new_i2c_bus *i2c_bus)
 {
-	u32 ctrl, state;
-	int r;
 	int ret = 0;
-        short slv_en = 0;
-	dev_dbg(i2c_bus->dev, "%d-bus recovery bus [%x]\n",
-		i2c_bus->adap.nr,
+	u32 ctrl;
+	u32 state;
+	int r;
+
+	dev_dbg(i2c_bus->dev, "%d-bus recovery bus [%x]\n", i2c_bus->adap.nr,
 		readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
 
 	ctrl = readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
-        if(ctrl & AST_I2CC_SLAVE_EN)
-		slv_en = 1;
+
 	writel(ctrl & ~(AST_I2CC_MASTER_EN | AST_I2CC_SLAVE_EN),
-			i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
+	       i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
 
-	writel(readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL) |
-			AST_I2CC_MASTER_EN,
-			i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
+	writel(readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL) | AST_I2CC_MASTER_EN,
+	       i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
 
-	//Let's retry 10 times
 	reinit_completion(&i2c_bus->cmd_complete);
 	i2c_bus->cmd_err = 0;
 
 	//Check 0x14's SDA and SCL status
 	state = readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
-	if (!(state & AST_I2CC_SDA_LINE_STS) &&
-	    (state & AST_I2CC_SCL_LINE_STS)) {
-		writel(AST_I2CM_RECOVER_CMD_EN,
-				i2c_bus->reg_base + AST_I2CM_CMD_STS);
-		r = wait_for_completion_timeout(&i2c_bus->cmd_complete,
-						i2c_bus->adap.timeout);
+	if (!(state & AST_I2CC_SDA_LINE_STS) && (state & AST_I2CC_SCL_LINE_STS)) {
+		writel(AST_I2CM_RECOVER_CMD_EN, i2c_bus->reg_base + AST_I2CM_CMD_STS);
+		r = wait_for_completion_timeout(&i2c_bus->cmd_complete, i2c_bus->adap.timeout);
 		if (r == 0) {
 			dev_dbg(i2c_bus->dev, "recovery timed out\n");
 			ret = -ETIMEDOUT;
@@ -531,28 +517,46 @@
 				ret = -EPROTO;
 			}
 		}
-	} else {
-		dev_dbg(i2c_bus->dev, "can't recovery this situation\n");
-		ret = -EPROTO;
 	}
-	if(slv_en)
-		writel( readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL) | AST_I2CC_SLAVE_EN, i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
+
 	dev_dbg(i2c_bus->dev, "Recovery done [%x]\n",
 		readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
+	if (readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF) & AST_I2CC_BUS_BUSY_STS) {
+		dev_dbg(i2c_bus->dev, "Can't recovery bus [%x]\n",
+			readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
+	}
 
 	writel(ctrl, i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
+	if (ctrl & AST_I2CC_SLAVE_EN) {
+		u32 cmd = SLAVE_TRIGGER_CMD;
+
+		if (i2c_bus->mode == DMA_MODE) {
+			cmd |= AST_I2CS_RX_DMA_EN;
+			writel(i2c_bus->slave_dma_addr, i2c_bus->reg_base + AST_I2CS_RX_DMA);
+			writel(i2c_bus->slave_dma_addr, i2c_bus->reg_base + AST_I2CS_TX_DMA);
+			writel(AST_I2CS_SET_RX_DMA_LEN(I2C_SLAVE_MSG_BUF_SIZE),
+			       i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+		} else if (i2c_bus->mode == BUFF_MODE) {
+			cmd |= AST_I2CS_RX_BUFF_EN;
+			writel(AST_I2CC_SET_RX_BUF_LEN(i2c_bus->buf_size),
+			       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+		} else {
+			cmd &= ~AST_I2CS_PKT_MODE_EN;
+		}
+		writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
+	}
 
 	return ret;
 }
 
 #ifdef CONFIG_I2C_SLAVE
-void aspeed_i2c_slave_packet_irq(struct aspeed_new_i2c_bus *i2c_bus, u32 sts)
+static void aspeed_i2c_slave_packet_irq(struct aspeed_new_i2c_bus *i2c_bus, u32 sts)
 {
+	int slave_rx_len;
+	u8 byte_data;
 	u32 cmd = 0;
 	u8 value;
-	u8 byte_data;
 	int i = 0;
-	int slave_rx_len;
 
 	sts &= ~(AST_I2CS_PKT_DONE | AST_I2CS_PKT_ERROR);
 	writel(AST_I2CS_PKT_DONE, i2c_bus->reg_base + AST_I2CS_ISR);
@@ -569,8 +573,7 @@
 		break;
 	case AST_I2CS_SLAVE_MATCH:
 	dev_dbg(i2c_bus->dev, "S : Sw\n");
-	i2c_slave_event(i2c_bus->slave,
-			I2C_SLAVE_WRITE_REQUESTED, &value);
+	i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_REQUESTED, &value);
 		break;
 
 	case AST_I2CS_SLAVE_MATCH | AST_I2CS_STOP:
@@ -579,29 +582,26 @@
 		cmd = SLAVE_TRIGGER_CMD;
 		if (i2c_bus->mode == DMA_MODE) {
 			cmd |= AST_I2CS_RX_DMA_EN;
-			writel(AST_I2CS_SET_RX_DMA_LEN(
-				I2C_SLAVE_MSG_BUF_SIZE),
-				i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+			writel(AST_I2CS_SET_RX_DMA_LEN(I2C_SLAVE_MSG_BUF_SIZE),
+			       i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			cmd |= AST_I2CS_RX_BUFF_EN;
-			writel(AST_I2CC_SET_RX_BUF_LEN(
-				i2c_bus->buf_size),
-				i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			writel(AST_I2CC_SET_RX_BUF_LEN(i2c_bus->buf_size),
+			       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
 			cmd &= ~AST_I2CS_PKT_MODE_EN;
 		}
 		writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 		break;
 
-	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE |
-		AST_I2CS_Wait_RX_DMA | AST_I2CS_STOP:
+	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_WAIT_RX_DMA | AST_I2CS_STOP:
 		//dev_dbg(i2c_bus->dev,
 		//	"S : Sw|D|P wait rx dma workaround\n");
-	case AST_I2CS_RX_DONE | AST_I2CS_Wait_RX_DMA | AST_I2CS_STOP:
+	case AST_I2CS_RX_DONE | AST_I2CS_WAIT_RX_DMA | AST_I2CS_STOP:
 		//dev_dbg(i2c_bus->dev,
 		//"S : D|P wait rx dma workaround\n");
 	case AST_I2CS_RX_DONE | AST_I2CS_STOP:
-	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_Wait_RX_DMA:
+	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_WAIT_RX_DMA:
 	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_STOP:
 		cmd = SLAVE_TRIGGER_CMD;
 		if (sts & AST_I2CS_STOP) {
@@ -609,232 +609,168 @@
 				dev_dbg(i2c_bus->dev, "S : Sw|D|P\n");
 			else
 				dev_dbg(i2c_bus->dev, "S : D|P\n");
-		} else
+		} else {
 			dev_dbg(i2c_bus->dev, "S : Sw|D\n");
+		}
 
 		if (sts & AST_I2CS_SLAVE_MATCH)
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_WRITE_REQUESTED,
-					&value);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_REQUESTED, &value);
 
 		if (i2c_bus->mode == DMA_MODE) {
 			cmd |= AST_I2CS_RX_DMA_EN;
-			slave_rx_len =
-			AST_I2C_GET_RX_DMA_LEN(
-			readl(i2c_bus->reg_base + AST_I2CS_DMA_LEN_STS));
-			dev_dbg(i2c_bus->dev, "rx len %d\n",
-						slave_rx_len);
+			slave_rx_len = AST_I2C_GET_RX_DMA_LEN(readl(i2c_bus->reg_base +
+							      AST_I2CS_DMA_LEN_STS));
+			dev_dbg(i2c_bus->dev, "rx len %d\n", slave_rx_len);
 			for (i = 0; i < slave_rx_len; i++) {
-				i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_WRITE_RECEIVED,
-					&i2c_bus->slave_dma_buf[i]);
-//				dev_dbg(i2c_bus->dev, "%x\n",
-//							i2c_bus->slave_dma_buf[i]);
+				i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED,
+						&i2c_bus->slave_dma_buf[i]);
 			}
-//			dev_dbg(i2c_bus->dev, "\n");
-			writel(AST_I2CS_SET_RX_DMA_LEN(
-				I2C_SLAVE_MSG_BUF_SIZE),
-				i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+			writel(AST_I2CS_SET_RX_DMA_LEN(I2C_SLAVE_MSG_BUF_SIZE),
+			       i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			cmd |= AST_I2CS_RX_BUFF_EN;
-			slave_rx_len =
-				AST_I2CC_GET_RX_BUF_LEN(
-				readl(i2c_bus->reg_base + AST_I2CC_BUFF_CTRL));
+			slave_rx_len = AST_I2CC_GET_RX_BUF_LEN(readl(i2c_bus->reg_base +
+							       AST_I2CC_BUFF_CTRL));
 			for (i = 0; i < slave_rx_len; i++) {
 				value = readb(i2c_bus->buf_base + i);
 				dev_dbg(i2c_bus->dev, "[%02x]", value);
-				i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_WRITE_RECEIVED,
-					&value);
+				i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED, &value);
 			}
-			writel(AST_I2CC_SET_RX_BUF_LEN(
-				i2c_bus->buf_size),
-				i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			writel(AST_I2CC_SET_RX_BUF_LEN(i2c_bus->buf_size),
+			       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
 			cmd &= ~AST_I2CS_PKT_MODE_EN;
-			byte_data = AST_I2CC_GET_RX_BUFF(
-					readl(i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF));
+			byte_data = AST_I2CC_GET_RX_BUFF(readl(i2c_bus->reg_base +
+							 AST_I2CC_STS_AND_BUFF));
 			dev_dbg(i2c_bus->dev, "[%02x]", byte_data);
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_WRITE_RECEIVED,
-					&byte_data);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED, &byte_data);
 		}
 		if (sts & AST_I2CS_STOP)
-			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_STOP,
-					&value);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_STOP, &value);
 		writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 		break;
 
-	//it is Mw data Mr coming -> it need send tx
-	case AST_I2CS_RX_DONE | AST_I2CS_Wait_TX_DMA:
-	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_Wait_TX_DMA:
-		//it should be repeat start read
+	/* it is Mw data Mr coming -> it need send tx */
+	case AST_I2CS_RX_DONE | AST_I2CS_WAIT_TX_DMA:
+	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_WAIT_TX_DMA:
+		/* it should be repeat start read */
 		if (sts & AST_I2CS_SLAVE_MATCH)
 			dev_dbg(i2c_bus->dev,
 				"S: AST_I2CS_Wait_TX_DMA | AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE\n");
 		else
-			dev_dbg(i2c_bus->dev,
-				"S: AST_I2CS_Wait_TX_DMA | AST_I2CS_RX_DONE\n");
+			dev_dbg(i2c_bus->dev, "S: AST_I2CS_Wait_TX_DMA | AST_I2CS_RX_DONE\n");
 
 		if (sts & AST_I2CS_SLAVE_MATCH)
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_WRITE_REQUESTED,
-					&value);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_REQUESTED, &value);
 
 		cmd = SLAVE_TRIGGER_CMD;
 		if (i2c_bus->mode == DMA_MODE) {
 			cmd |= AST_I2CS_TX_DMA_EN;
-			slave_rx_len =
-				AST_I2C_GET_RX_DMA_LEN(
-				readl(i2c_bus->reg_base +
-					AST_I2CS_DMA_LEN_STS));
+			slave_rx_len = AST_I2C_GET_RX_DMA_LEN(readl(i2c_bus->reg_base +
+							      AST_I2CS_DMA_LEN_STS));
 			for (i = 0; i < slave_rx_len; i++) {
-				dev_dbg(i2c_bus->dev, "rx [%02x]",
-					i2c_bus->slave_dma_buf[i]);
-				i2c_slave_event(
-					i2c_bus->slave,
-					I2C_SLAVE_WRITE_RECEIVED,
-					&i2c_bus->slave_dma_buf[i]);
+				dev_dbg(i2c_bus->dev, "rx [%02x]", i2c_bus->slave_dma_buf[i]);
+				i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED,
+						&i2c_bus->slave_dma_buf[i]);
 			}
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_REQUESTED,
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED,
 					&i2c_bus->slave_dma_buf[0]);
-			dev_dbg(i2c_bus->dev, "tx : [%02x]",
-				i2c_bus->slave_dma_buf[0]);
+			dev_dbg(i2c_bus->dev, "tx : [%02x]", i2c_bus->slave_dma_buf[0]);
 			writel(0, i2c_bus->reg_base + AST_I2CS_DMA_LEN_STS);
-			writel(AST_I2CS_SET_TX_DMA_LEN(1),
-					i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+			writel(AST_I2CS_SET_TX_DMA_LEN(1), i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			cmd |= AST_I2CS_TX_BUFF_EN;
-			slave_rx_len =
-				AST_I2CC_GET_RX_BUF_LEN(
-				readl(i2c_bus->reg_base + AST_I2CC_BUFF_CTRL));
+			slave_rx_len = AST_I2CC_GET_RX_BUF_LEN(readl(i2c_bus->reg_base +
+							       AST_I2CC_BUFF_CTRL));
 			for (i = 0; i < slave_rx_len; i++) {
 				value = readb(i2c_bus->buf_base + i);
-				dev_dbg(i2c_bus->dev, "rx : [%02x]",
-					value);
-				i2c_slave_event(
-					i2c_bus->slave,
-					I2C_SLAVE_WRITE_RECEIVED,
-					&value);
+				dev_dbg(i2c_bus->dev, "rx : [%02x]", value);
+				i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED, &value);
 			}
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_REQUESTED,
-					&value);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED, &value);
 			dev_dbg(i2c_bus->dev, "tx : [%02x]", value);
 			writeb(value, i2c_bus->buf_base);
-			writel(AST_I2CC_SET_TX_BUF_LEN(1),
-					i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			writel(AST_I2CC_SET_TX_BUF_LEN(1), i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
 			cmd &= ~AST_I2CS_PKT_MODE_EN;
 			cmd |= AST_I2CS_TX_CMD;
-			byte_data = AST_I2CC_GET_RX_BUFF(
-				readl(i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF));
+			byte_data = AST_I2CC_GET_RX_BUFF(readl(i2c_bus->reg_base +
+							 AST_I2CC_STS_AND_BUFF));
 			dev_dbg(i2c_bus->dev, "rx : [%02x]", byte_data);
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_WRITE_RECEIVED,
-					&byte_data);
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_REQUESTED,
-					&byte_data);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED, &byte_data);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED, &byte_data);
 			dev_dbg(i2c_bus->dev, "tx : [%02x]", byte_data);
-			writel(byte_data, i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF);
+			writel(byte_data, i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
 		}
 		writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 		break;
 
-	case AST_I2CS_SLAVE_MATCH | AST_I2CS_Wait_TX_DMA:
-		//First Start read
-		dev_dbg(i2c_bus->dev,
-			"S: AST_I2CS_SLAVE_MATCH | AST_I2CS_Wait_TX_DMA\n");
+	case AST_I2CS_SLAVE_MATCH | AST_I2CS_WAIT_TX_DMA:
+		/* First Start read */
+		dev_dbg(i2c_bus->dev, "S: AST_I2CS_SLAVE_MATCH | AST_I2CS_Wait_TX_DMA\n");
 		cmd = SLAVE_TRIGGER_CMD;
 		if (i2c_bus->mode == DMA_MODE) {
 			cmd |= AST_I2CS_TX_DMA_EN;
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_REQUESTED,
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED,
 					&i2c_bus->slave_dma_buf[0]);
-			dev_dbg(i2c_bus->dev, "tx: [%x]\n",
-				i2c_bus->slave_dma_buf[0]);
-			writel(AST_I2CS_SET_TX_DMA_LEN(1),
-				i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+			dev_dbg(i2c_bus->dev, "tx: [%x]\n", i2c_bus->slave_dma_buf[0]);
+			writel(AST_I2CS_SET_TX_DMA_LEN(1), i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			cmd |= AST_I2CS_TX_BUFF_EN;
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_REQUESTED,
-					&byte_data);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED, &byte_data);
 			dev_dbg(i2c_bus->dev, "tx : [%02x]", byte_data);
 			writeb(byte_data, i2c_bus->buf_base);
-			writel(AST_I2CC_SET_TX_BUF_LEN(1),
-				i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			writel(AST_I2CC_SET_TX_BUF_LEN(1), i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
 			cmd &= ~AST_I2CS_PKT_MODE_EN;
 			cmd |= AST_I2CS_TX_CMD;
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_REQUESTED,
-					&byte_data);
-			writel(byte_data, i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED, &byte_data);
+			writel(byte_data, i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
 		}
 		writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 		break;
 
-	case AST_I2CS_Wait_TX_DMA:
-		//it should be next start read
+	case AST_I2CS_WAIT_TX_DMA:
+		/* it should be next start read */
 		dev_dbg(i2c_bus->dev, "S: AST_I2CS_Wait_TX_DMA\n");
 		cmd = SLAVE_TRIGGER_CMD;
 		if (i2c_bus->mode == DMA_MODE) {
 			cmd |= AST_I2CS_TX_DMA_EN;
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_PROCESSED,
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_PROCESSED,
 					&i2c_bus->slave_dma_buf[0]);
-			dev_dbg(i2c_bus->dev, "tx : [%02x]",
-				i2c_bus->slave_dma_buf[0]);
+			dev_dbg(i2c_bus->dev, "tx : [%02x]", i2c_bus->slave_dma_buf[0]);
 			writel(0, i2c_bus->reg_base + AST_I2CS_DMA_LEN_STS);
-			writel(AST_I2CS_SET_TX_DMA_LEN(1),
-					i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+			writel(AST_I2CS_SET_TX_DMA_LEN(1), i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			cmd |= AST_I2CS_TX_BUFF_EN;
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_PROCESSED,
-					&value);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_PROCESSED, &value);
 			dev_dbg(i2c_bus->dev, "tx: [%02x]\n", value);
 			writeb(value, i2c_bus->buf_base);
-			writel(AST_I2CC_SET_TX_BUF_LEN(1),
-					i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			writel(AST_I2CC_SET_TX_BUF_LEN(1), i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
 			cmd &= ~AST_I2CS_PKT_MODE_EN;
 			cmd |= AST_I2CS_TX_CMD;
-			i2c_slave_event(i2c_bus->slave,
-					I2C_SLAVE_READ_PROCESSED,
-					&byte_data);
-			dev_dbg(i2c_bus->dev, "tx: [%02x]\n",
-				byte_data);
-			writel(byte_data, i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF);
+			i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_PROCESSED, &byte_data);
+			dev_dbg(i2c_bus->dev, "tx: [%02x]\n", byte_data);
+			writel(byte_data, i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
 		}
 		writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 		break;
 
 	case AST_I2CS_TX_NAK | AST_I2CS_STOP:
-		//it just tx complete
-		dev_dbg(i2c_bus->dev,
-			"S: AST_I2CS_TX_NAK | AST_I2CS_STOP\n");
+		/* it just tx complete */
+		dev_dbg(i2c_bus->dev, "S: AST_I2CS_TX_NAK | AST_I2CS_STOP\n");
 		cmd = SLAVE_TRIGGER_CMD;
 		i2c_slave_event(i2c_bus->slave, I2C_SLAVE_STOP, &value);
 		if (i2c_bus->mode == DMA_MODE) {
 			cmd |= AST_I2CS_RX_DMA_EN;
 			writel(0, i2c_bus->reg_base + AST_I2CS_DMA_LEN_STS);
-			writel(AST_I2CS_SET_RX_DMA_LEN(
-				I2C_SLAVE_MSG_BUF_SIZE),
-				i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+			writel(AST_I2CS_SET_RX_DMA_LEN(I2C_SLAVE_MSG_BUF_SIZE),
+			       i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			cmd |= AST_I2CS_RX_BUFF_EN;
-			writel(AST_I2CC_SET_RX_BUF_LEN(
-				i2c_bus->buf_size),
-				i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			writel(AST_I2CC_SET_RX_BUF_LEN(i2c_bus->buf_size),
+			       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
 			cmd &= ~AST_I2CS_PKT_MODE_EN;
 		}
@@ -842,53 +778,45 @@
 		break;
 
 	default:
-		printk("TODO slave sts case %x, now %x\n", sts,
-				readl(i2c_bus->reg_base + AST_I2CS_ISR));
+		dev_dbg(i2c_bus->dev, "todo slave sts case %x, now %x\n", sts,
+			readl(i2c_bus->reg_base + AST_I2CS_ISR));
 		break;
 	}
-
 }
 
-void aspeed_i2c_slave_byte_irq(struct aspeed_new_i2c_bus *i2c_bus, u32 sts)
+static void aspeed_i2c_slave_byte_irq(struct aspeed_new_i2c_bus *i2c_bus, u32 sts)
 {
-	u8 value;
-	u8 byte_data;
 	u32 cmd = AST_I2CS_ACTIVE_ALL;
+	u8 byte_data;
+	u8 value;
 
 	switch (sts) {
-	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_Wait_RX_DMA:
+	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_WAIT_RX_DMA:
 		dev_dbg(i2c_bus->dev, "S : Sw|D\n");
-		i2c_slave_event(i2c_bus->slave,
-				I2C_SLAVE_WRITE_REQUESTED, &value);
-		//first address match is address
-		byte_data = AST_I2CC_GET_RX_BUFF(
-			readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
+		i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_REQUESTED, &value);
+		/* first address match is address */
+		byte_data = AST_I2CC_GET_RX_BUFF(readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
 		dev_dbg(i2c_bus->dev, "addr [%x]", byte_data);
 		break;
-	case AST_I2CS_RX_DONE | AST_I2CS_Wait_RX_DMA:
+	case AST_I2CS_RX_DONE | AST_I2CS_WAIT_RX_DMA:
 		dev_dbg(i2c_bus->dev, "S : D\n");
-		byte_data = AST_I2CC_GET_RX_BUFF(
-			readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
+		byte_data = AST_I2CC_GET_RX_BUFF(readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
 		dev_dbg(i2c_bus->dev, "rx [%x]", byte_data);
-		i2c_slave_event(i2c_bus->slave,
-				I2C_SLAVE_WRITE_RECEIVED, &byte_data);
+		i2c_slave_event(i2c_bus->slave, I2C_SLAVE_WRITE_RECEIVED, &byte_data);
 		break;
-	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_Wait_TX_DMA:
+	case AST_I2CS_SLAVE_MATCH | AST_I2CS_RX_DONE | AST_I2CS_WAIT_TX_DMA:
 		cmd |= AST_I2CS_TX_CMD;
 		dev_dbg(i2c_bus->dev, "S : Sr|D\n");
-		byte_data = AST_I2CC_GET_RX_BUFF(
-			readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
+		byte_data = AST_I2CC_GET_RX_BUFF(readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
 		dev_dbg(i2c_bus->dev, "addr : [%02x]", byte_data);
-		i2c_slave_event(i2c_bus->slave,
-				I2C_SLAVE_READ_REQUESTED, &byte_data);
+		i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_REQUESTED, &byte_data);
 		dev_dbg(i2c_bus->dev, "tx: [%02x]\n", byte_data);
 		writel(byte_data, i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
 		break;
-	case AST_I2CS_TX_ACK | AST_I2CS_Wait_TX_DMA:
+	case AST_I2CS_TX_ACK | AST_I2CS_WAIT_TX_DMA:
 		cmd |= AST_I2CS_TX_CMD;
 		dev_dbg(i2c_bus->dev, "S : D\n");
-		i2c_slave_event(i2c_bus->slave,
-				I2C_SLAVE_READ_PROCESSED, &byte_data);
+		i2c_slave_event(i2c_bus->slave, I2C_SLAVE_READ_PROCESSED, &byte_data);
 		dev_dbg(i2c_bus->dev, "tx: [%02x]\n", byte_data);
 		writel(byte_data, i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
 		break;
@@ -898,15 +826,14 @@
 		i2c_slave_event(i2c_bus->slave, I2C_SLAVE_STOP, &value);
 		break;
 	default:
-		printk("todo no pkt isr %x\n", sts);
+		dev_dbg(i2c_bus->dev, "todo no pkt isr %x\n", sts);
 		break;
 	}
 	writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 	writel(sts, i2c_bus->reg_base + AST_I2CS_ISR);
-
 }
 
-int aspeed_new_i2c_slave_irq(struct aspeed_new_i2c_bus *i2c_bus)
+static int aspeed_new_i2c_slave_irq(struct aspeed_new_i2c_bus *i2c_bus)
 {
 	u32 ier = readl(i2c_bus->reg_base + AST_I2CS_IER);
 	u32 sts = readl(i2c_bus->reg_base + AST_I2CS_ISR);
@@ -915,7 +842,7 @@
 		return 0;
 	dev_dbg(i2c_bus->dev, "slave irq sts %x\n", sts);
 
-	sts &= ~(AST_I2CS_ADDR_INDICAT_MASK | AST_I2CS_SLAVE_PENDING);
+	sts &= ~(AST_I2CS_ADDR_INDICATE_MASK | AST_I2CS_SLAVE_PENDING);
 
 	if (AST_I2CS_ADDR1_NAK & sts)
 		sts &= ~AST_I2CS_ADDR1_NAK;
@@ -940,13 +867,14 @@
 
 static void aspeed_new_i2c_do_start(struct aspeed_new_i2c_bus *i2c_bus)
 {
-	int i = 0;
-	int xfer_len = 0;
 	struct i2c_msg *msg = &i2c_bus->msgs[i2c_bus->msgs_index];
-	u32 cmd = AST_I2CM_PKT_EN | AST_I2CM_PKT_ADDR(msg->addr) |
-		  AST_I2CM_START_CMD;
+	int xfer_len = 0;
+	int i = 0;
+	u32 cmd;
 
-	//send start
+	cmd = AST_I2CM_PKT_EN | AST_I2CM_PKT_ADDR(msg->addr) | AST_I2CM_START_CMD;
+
+	/* send start */
 	dev_dbg(i2c_bus->dev, "[%d] %sing %d byte%s %s 0x%02x\n",
 		i2c_bus->msgs_index, msg->flags & I2C_M_RD ? "read" : "write",
 		msg->len, msg->len > 1 ? "s" : "",
@@ -958,7 +886,7 @@
 	if (msg->flags & I2C_M_RD) {
 		cmd |= AST_I2CM_RX_CMD;
 		if (i2c_bus->mode == DMA_MODE) {
-			//dma mode
+			/* dma mode */
 			cmd |= AST_I2CM_RX_DMA_EN;
 
 			if (msg->flags & I2C_M_RECV_LEN) {
@@ -969,24 +897,19 @@
 					xfer_len = ASPEED_I2C_DMA_SIZE;
 				} else {
 					xfer_len = msg->len;
-					if (i2c_bus->msgs_index + 1 ==
-					    i2c_bus->msgs_count) {
-						dev_dbg(i2c_bus->dev,
-							"last stop\n");
-						cmd |= AST_I2CM_RX_CMD_LAST |
-						       AST_I2CM_STOP_CMD;
+					if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+						dev_dbg(i2c_bus->dev, "last stop\n");
+						cmd |= AST_I2CM_RX_CMD_LAST | AST_I2CM_STOP_CMD;
 					}
 				}
 			}
 			writel(AST_I2CM_SET_RX_DMA_LEN(xfer_len - 1),
-					i2c_bus->reg_base + AST_I2CM_DMA_LEN);
+			       i2c_bus->reg_base + AST_I2CM_DMA_LEN);
 			i2c_bus->master_dma_addr =
-				dma_map_single(i2c_bus->dev,
-					msg->buf, msg->len, DMA_FROM_DEVICE);
-			writel(i2c_bus->master_dma_addr,
-					i2c_bus->reg_base + AST_I2CM_RX_DMA);
+				dma_map_single(i2c_bus->dev, msg->buf, msg->len, DMA_FROM_DEVICE);
+			writel(i2c_bus->master_dma_addr, i2c_bus->reg_base + AST_I2CM_RX_DMA);
 		} else if (i2c_bus->mode == BUFF_MODE) {
-			//buff mode
+			/* buff mode */
 			cmd |= AST_I2CM_RX_BUFF_EN;
 			if (msg->flags & I2C_M_RECV_LEN) {
 				dev_dbg(i2c_bus->dev, "smbus read\n");
@@ -996,40 +919,35 @@
 					xfer_len = i2c_bus->buf_size;
 				} else {
 					xfer_len = msg->len;
-					if (i2c_bus->msgs_index + 1 ==
-					    i2c_bus->msgs_count) {
-						dev_dbg(i2c_bus->dev,
-							"last stop\n");
-						cmd |= AST_I2CM_RX_CMD_LAST |
-						       AST_I2CM_STOP_CMD;
+					if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+						dev_dbg(i2c_bus->dev, "last stop\n");
+						cmd |= AST_I2CM_RX_CMD_LAST | AST_I2CM_STOP_CMD;
 					}
 				}
 			}
 			writel(AST_I2CC_SET_RX_BUF_LEN(xfer_len),
-					i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+			       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 		} else {
-			//byte mode
+			/* byte mode */
 			xfer_len = 1;
 			if (msg->flags & I2C_M_RECV_LEN) {
 				dev_dbg(i2c_bus->dev, "smbus read\n");
 			} else {
-				if ((i2c_bus->msgs_index + 1 ==
-				     i2c_bus->msgs_count) &&
-				    (msg->len == 1)) {
-					dev_dbg(i2c_bus->dev, "last stop\n");
-					cmd |= AST_I2CM_RX_CMD_LAST |
-					       AST_I2CM_STOP_CMD;
+				if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+					if (msg->len == 1) {
+						dev_dbg(i2c_bus->dev, "last stop\n");
+						cmd |= AST_I2CM_RX_CMD_LAST | AST_I2CM_STOP_CMD;
+					}
 				}
 			}
 		}
 	} else {
 		if (i2c_bus->mode == DMA_MODE) {
-			//dma mode
+			/* dma mode */
 			if (msg->len > ASPEED_I2C_DMA_SIZE) {
 				xfer_len = ASPEED_I2C_DMA_SIZE;
 			} else {
-				if (i2c_bus->msgs_index + 1 ==
-				    i2c_bus->msgs_count) {
+				if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
 					dev_dbg(i2c_bus->dev, "with stop\n");
 					cmd |= AST_I2CM_STOP_CMD;
 				}
@@ -1039,21 +957,20 @@
 			if (xfer_len) {
 				cmd |= AST_I2CM_TX_DMA_EN | AST_I2CM_TX_CMD;
 				writel(AST_I2CM_SET_TX_DMA_LEN(xfer_len - 1),
-					i2c_bus->reg_base + AST_I2CM_DMA_LEN);
+				       i2c_bus->reg_base + AST_I2CM_DMA_LEN);
 				i2c_bus->master_dma_addr =
-					dma_map_single(i2c_bus->dev, msg->buf,
-						       msg->len, DMA_TO_DEVICE);
+					dma_map_single(i2c_bus->dev, msg->buf, msg->len,
+						       DMA_TO_DEVICE);
 				writel(i2c_bus->master_dma_addr,
-					i2c_bus->reg_base + AST_I2CM_TX_DMA);
+				       i2c_bus->reg_base + AST_I2CM_TX_DMA);
 			}
 		} else if (i2c_bus->mode == BUFF_MODE) {
 			u8 wbuf[4];
-			//buff mode
+			/* buff mode */
 			if (msg->len > i2c_bus->buf_size) {
 				xfer_len = i2c_bus->buf_size;
 			} else {
-				if (i2c_bus->msgs_index + 1 ==
-				    i2c_bus->msgs_count) {
+				if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
 					dev_dbg(i2c_bus->dev, "with stop\n");
 					cmd |= AST_I2CM_STOP_CMD;
 				}
@@ -1062,24 +979,19 @@
 			if (xfer_len) {
 				cmd |= AST_I2CM_TX_BUFF_EN | AST_I2CM_TX_CMD;
 				writel(AST_I2CC_SET_TX_BUF_LEN(xfer_len),
-					i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+				       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 				for (i = 0; i < xfer_len; i++) {
 					wbuf[i % 4] = msg->buf[i];
 					if (i % 4 == 3)
-						writel(*(u32 *)wbuf,
-						       i2c_bus->buf_base + i -
-							       3);
-					dev_dbg(i2c_bus->dev, "[%02x]\n",
-						msg->buf[i]);
+						writel(*(u32 *)wbuf, i2c_bus->buf_base + i - 3);
+					dev_dbg(i2c_bus->dev, "[%02x]\n", msg->buf[i]);
 				}
 				if (--i % 4 != 3)
-					writel(*(u32 *)wbuf,
-					       i2c_bus->buf_base + i - (i % 4));
+					writel(*(u32 *)wbuf, i2c_bus->buf_base + i - (i % 4));
 			}
 		} else {
-			//byte mode
-			if ((i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) &&
-			    (msg->len <= 1)) {
+			/* byte mode */
+			if ((i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) && (msg->len <= 1)) {
 				dev_dbg(i2c_bus->dev, "with stop\n");
 				cmd |= AST_I2CM_STOP_CMD;
 			}
@@ -1087,13 +999,11 @@
 			if (msg->len) {
 				cmd |= AST_I2CM_TX_CMD;
 				xfer_len = 1;
-				dev_dbg(i2c_bus->dev, "w [0] : %02x\n",
-					msg->buf[0]);
-				writel(msg->buf[0],
-					i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF);
-			} else
+				dev_dbg(i2c_bus->dev, "w [0] : %02x\n", msg->buf[0]);
+				writel(msg->buf[0], i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
+			} else {
 				xfer_len = 0;
+			}
 		}
 	}
 	dev_dbg(i2c_bus->dev, "len %d , cmd %x\n", xfer_len, cmd);
@@ -1112,34 +1022,29 @@
 	return 0;
 }
 
-void aspeed_i2c_master_package_irq(struct aspeed_new_i2c_bus *i2c_bus, u32 sts)
+static void aspeed_i2c_master_package_irq(struct aspeed_new_i2c_bus *i2c_bus, u32 sts)
 {
-	int i;
-	int xfer_len;
-	u32 cmd = AST_I2CM_PKT_EN;
 	struct i2c_msg *msg = &i2c_bus->msgs[i2c_bus->msgs_index];
+	u32 cmd = AST_I2CM_PKT_EN;
+	int xfer_len;
+	int i;
 
 	sts &= ~AST_I2CM_PKT_DONE;
 	writel(AST_I2CM_PKT_DONE, i2c_bus->reg_base + AST_I2CM_ISR);
 	switch (sts) {
 	case AST_I2CM_PKT_ERROR:
 		dev_dbg(i2c_bus->dev, "M : ERROR only\n");
-		printk("M : ERROR only %x %x\n", 
-			readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF),
-			readl(i2c_bus->reg_base + AST_I2CM_CMD_STS));
 		fallthrough;
-	case AST_I2CM_PKT_ERROR | AST_I2CM_TX_NAK: //a0 fix for issue
-		//dev_dbg(i2c_bus->dev, "a0 workaround for M TX NAK [%x]\n",
-		//	readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF));
+	case AST_I2CM_PKT_ERROR | AST_I2CM_TX_NAK: /* a0 fix for issue */
+		fallthrough;
 	case AST_I2CM_PKT_ERROR | AST_I2CM_TX_NAK | AST_I2CM_NORMAL_STOP:
 		dev_dbg(i2c_bus->dev, "M : TX NAK | NORMAL STOP\n");
 		i2c_bus->cmd_err = -ENXIO;
 		complete(&i2c_bus->cmd_complete);
 		break;
 	case AST_I2CM_NORMAL_STOP:
-		//write 0 byte only have stop isr
-		dev_dbg(i2c_bus->dev,
-			"M clear isr: AST_I2CM_NORMAL_STOP = %x\n", sts);
+		/* write 0 byte only have stop isr */
+		dev_dbg(i2c_bus->dev, "M clear isr: AST_I2CM_NORMAL_STOP = %x\n", sts);
 		i2c_bus->msgs_index++;
 		i2c_bus->cmd_err = i2c_bus->msgs_index;
 		complete(&i2c_bus->cmd_complete);
@@ -1147,113 +1052,86 @@
 	case AST_I2CM_TX_ACK:
 		//dev_dbg(i2c_bus->dev, "M : AST_I2CM_TX_ACK = %x\n", sts);
 	case AST_I2CM_TX_ACK | AST_I2CM_NORMAL_STOP:
-		dev_dbg(i2c_bus->dev,
-			"M : AST_I2CM_TX_ACK | AST_I2CM_NORMAL_STOP= %x\n",
-			sts);
+		dev_dbg(i2c_bus->dev, "M : AST_I2CM_TX_ACK | AST_I2CM_NORMAL_STOP= %x\n", sts);
 
-		if (i2c_bus->mode == DMA_MODE) {
-			xfer_len = AST_I2C_GET_TX_DMA_LEN(
-				readl(i2c_bus->reg_base +
-					AST_I2CM_DMA_LEN_STS));
-		} else if (i2c_bus->mode == BUFF_MODE) {
-			xfer_len =
-				AST_I2CC_GET_TX_BUF_LEN(
-				readl(i2c_bus->reg_base + AST_I2CC_BUFF_CTRL));
-		} else {
+		if (i2c_bus->mode == DMA_MODE)
+			xfer_len = AST_I2C_GET_TX_DMA_LEN(readl(i2c_bus->reg_base +
+							  AST_I2CM_DMA_LEN_STS));
+		else if (i2c_bus->mode == BUFF_MODE)
+			xfer_len = AST_I2CC_GET_TX_BUF_LEN(readl(i2c_bus->reg_base +
+							   AST_I2CC_BUFF_CTRL));
+		else
 			xfer_len = 1;
-		}
 		i2c_bus->master_xfer_cnt += xfer_len;
 
 		if (i2c_bus->master_xfer_cnt == msg->len) {
 			if (i2c_bus->mode == DMA_MODE)
-				dma_unmap_single(i2c_bus->dev,
-					i2c_bus->master_dma_addr,
-					msg->len, DMA_TO_DEVICE);
+				dma_unmap_single(i2c_bus->dev, i2c_bus->master_dma_addr, msg->len,
+						 DMA_TO_DEVICE);
 
 			i2c_bus->msgs_index++;
-			if (i2c_bus->msgs_index ==
-				i2c_bus->msgs_count) {
+			if (i2c_bus->msgs_index == i2c_bus->msgs_count) {
 				i2c_bus->cmd_err = i2c_bus->msgs_index;
 				complete(&i2c_bus->cmd_complete);
-			} else
+			} else {
 				aspeed_new_i2c_do_start(i2c_bus);
+			}
 		} else {
-			//do next tx
+			/* do next tx */
 			cmd |= AST_I2CM_TX_CMD;
 			if (i2c_bus->mode == DMA_MODE) {
 				cmd |= AST_I2CS_TX_DMA_EN;
-				xfer_len = msg->len -
-					   i2c_bus->master_xfer_cnt;
+				xfer_len = msg->len - i2c_bus->master_xfer_cnt;
 				if (xfer_len > ASPEED_I2C_DMA_SIZE) {
 					xfer_len = ASPEED_I2C_DMA_SIZE;
 				} else {
-					if (i2c_bus->msgs_index + 1 ==
-						i2c_bus->msgs_count) {
-						dev_dbg(i2c_bus->dev,
-							"M: STOP\n");
+					if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+						dev_dbg(i2c_bus->dev, "M: STOP\n");
 						cmd |= AST_I2CM_STOP_CMD;
 					}
 				}
 				writel(AST_I2CM_SET_TX_DMA_LEN(xfer_len - 1),
-					i2c_bus->reg_base + AST_I2CM_DMA_LEN);
-				dev_dbg(i2c_bus->dev,
-					"next tx xfer_len: %d, offset %d\n",
-					xfer_len,
-					i2c_bus->master_xfer_cnt);
-				writel(i2c_bus->master_dma_addr +
-					i2c_bus->master_xfer_cnt,
-					i2c_bus->reg_base + AST_I2CM_TX_DMA);
+				       i2c_bus->reg_base + AST_I2CM_DMA_LEN);
+				dev_dbg(i2c_bus->dev, "next tx xfer_len: %d, offset %d\n",
+					xfer_len, i2c_bus->master_xfer_cnt);
+				writel(i2c_bus->master_dma_addr + i2c_bus->master_xfer_cnt,
+				       i2c_bus->reg_base + AST_I2CM_TX_DMA);
 			} else if (i2c_bus->mode == BUFF_MODE) {
 				u8 wbuf[4];
 
 				cmd |= AST_I2CS_RX_BUFF_EN;
-				xfer_len = msg->len -
-					   i2c_bus->master_xfer_cnt;
+				xfer_len = msg->len - i2c_bus->master_xfer_cnt;
 				if (xfer_len > i2c_bus->buf_size) {
 					xfer_len = i2c_bus->buf_size;
 				} else {
-					if (i2c_bus->msgs_index + 1 ==
-						i2c_bus->msgs_count) {
-						dev_dbg(i2c_bus->dev,
-							"M: STOP\n");
+					if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+						dev_dbg(i2c_bus->dev, "M: STOP\n");
 						cmd |= AST_I2CM_STOP_CMD;
 					}
 				}
 				for (i = 0; i < xfer_len; i++) {
-					wbuf[i % 4] =
-						msg->buf[
-						i2c_bus->master_xfer_cnt + i];
+					wbuf[i % 4] = msg->buf[i2c_bus->master_xfer_cnt + i];
 					if (i % 4 == 3)
-						writel(*(u32 *)wbuf,
-							   i2c_bus->buf_base +
-								   i - 3);
-					dev_dbg(i2c_bus->dev,
-						"[%02x]\n",
-						msg->buf[
-						i2c_bus->master_xfer_cnt + i]);
+						writel(*(u32 *)wbuf, i2c_bus->buf_base + i - 3);
+					dev_dbg(i2c_bus->dev, "[%02x]\n",
+						msg->buf[i2c_bus->master_xfer_cnt + i]);
 				}
 				if (--i % 4 != 3)
-					writel(*(u32 *)wbuf,
-						   i2c_bus->buf_base + i -
-							   (i % 4));
+					writel(*(u32 *)wbuf, i2c_bus->buf_base + i - (i % 4));
 
 				writel(AST_I2CC_SET_TX_BUF_LEN(xfer_len),
-					i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+				       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 			} else {
-				//byte
-				if ((i2c_bus->msgs_index + 1 ==
-					 i2c_bus->msgs_count) &&
-					((i2c_bus->master_xfer_cnt + 1) ==
-					 msg->len)) {
-					dev_dbg(i2c_bus->dev,
-						"M: STOP\n");
+				/* byte */
+				if ((i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) &&
+				    ((i2c_bus->master_xfer_cnt + 1) == msg->len)) {
+					dev_dbg(i2c_bus->dev, "M: STOP\n");
 					cmd |= AST_I2CM_STOP_CMD;
 				}
 				dev_dbg(i2c_bus->dev, "tx buff[%x]\n",
 					msg->buf[i2c_bus->master_xfer_cnt]);
 				writel(msg->buf[i2c_bus->master_xfer_cnt],
-					i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF);
+				       i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF);
 			}
 			dev_dbg(i2c_bus->dev, "next tx cmd: %x\n", cmd);
 			writel(cmd, i2c_bus->reg_base + AST_I2CM_CMD_STS);
@@ -1262,128 +1140,98 @@
 	case AST_I2CM_RX_DONE:
 		//dev_dbg(i2c_bus->dev, "M : AST_I2CM_RX_DONE = %x\n", sts);
 	case AST_I2CM_RX_DONE | AST_I2CM_NORMAL_STOP:
-		dev_dbg(i2c_bus->dev,
-			"M : AST_I2CM_RX_DONE | AST_I2CM_NORMAL_STOP = %x\n",
-			sts);
-		//do next rx
+		dev_dbg(i2c_bus->dev, "M : AST_I2CM_RX_DONE | AST_I2CM_NORMAL_STOP = %x\n", sts);
+		/* do next rx */
 		if (i2c_bus->mode == DMA_MODE) {
-			xfer_len =
-				AST_I2C_GET_RX_DMA_LEN(
-				readl(i2c_bus->reg_base +
-					AST_I2CM_DMA_LEN_STS));
+			xfer_len = AST_I2C_GET_RX_DMA_LEN(readl(i2c_bus->reg_base +
+							  AST_I2CM_DMA_LEN_STS));
 		} else if (i2c_bus->mode == BUFF_MODE) {
-			xfer_len =
-				AST_I2CC_GET_RX_BUF_LEN(
-				readl(i2c_bus->reg_base + AST_I2CC_BUFF_CTRL));
+			xfer_len = AST_I2CC_GET_RX_BUF_LEN(readl(i2c_bus->reg_base +
+							   AST_I2CC_BUFF_CTRL));
 			for (i = 0; i < xfer_len; i++)
 				msg->buf[i2c_bus->master_xfer_cnt + i] =
 					readb(i2c_bus->buf_base + i);
 		} else {
 			xfer_len = 1;
 			msg->buf[i2c_bus->master_xfer_cnt] =
-				AST_I2CC_GET_RX_BUFF(
-				readl(i2c_bus->reg_base +
-					AST_I2CC_STS_AND_BUFF));
+				AST_I2CC_GET_RX_BUFF(readl(i2c_bus->reg_base +
+						     AST_I2CC_STS_AND_BUFF));
 		}
 
 		if (msg->flags & I2C_M_RECV_LEN) {
-			dev_dbg(i2c_bus->dev, "smbus first len = %x\n",
-				msg->buf[0]);
-			msg->len =
-				msg->buf[0] +
-				((msg->flags & I2C_CLIENT_PEC) ? 2 : 1);
+			dev_dbg(i2c_bus->dev, "smbus first len = %x\n", msg->buf[0]);
+			msg->len = msg->buf[0] + ((msg->flags & I2C_CLIENT_PEC) ? 2 : 1);
 			msg->flags &= ~I2C_M_RECV_LEN;
 		}
 		i2c_bus->master_xfer_cnt += xfer_len;
-		dev_dbg(i2c_bus->dev, "master_xfer_cnt [%d/%d]\n",
-			i2c_bus->master_xfer_cnt, msg->len);
+		dev_dbg(i2c_bus->dev, "master_xfer_cnt [%d/%d]\n", i2c_bus->master_xfer_cnt,
+			msg->len);
 
 		if (i2c_bus->master_xfer_cnt == msg->len) {
 			if (i2c_bus->mode == DMA_MODE)
-				dma_unmap_single(
-					i2c_bus->dev,
-					i2c_bus->master_dma_addr,
-					msg->len, DMA_FROM_DEVICE);
-
-			for (i = 0; i < msg->len; i++) {
-				dev_dbg(i2c_bus->dev, "M: r %d:[%x]\n",
-					i, msg->buf[i]);
-			}
+				dma_unmap_single(i2c_bus->dev, i2c_bus->master_dma_addr, msg->len,
+						 DMA_FROM_DEVICE);
+
+			for (i = 0; i < msg->len; i++)
+				dev_dbg(i2c_bus->dev, "M: r %d:[%x]\n", i, msg->buf[i]);
 			i2c_bus->msgs_index++;
-			if (i2c_bus->msgs_index ==
-				i2c_bus->msgs_count) {
+			if (i2c_bus->msgs_index == i2c_bus->msgs_count) {
 				i2c_bus->cmd_err = i2c_bus->msgs_index;
 				complete(&i2c_bus->cmd_complete);
-			} else
+			} else {
 				aspeed_new_i2c_do_start(i2c_bus);
+			}
 		} else {
-			//next rx
+			/* next rx */
 			cmd |= AST_I2CM_RX_CMD;
 			if (i2c_bus->mode == DMA_MODE) {
 				cmd |= AST_I2CM_RX_DMA_EN;
-				xfer_len = msg->len -
-					   i2c_bus->master_xfer_cnt;
+				xfer_len = msg->len - i2c_bus->master_xfer_cnt;
 				if (xfer_len > ASPEED_I2C_DMA_SIZE) {
 					xfer_len = ASPEED_I2C_DMA_SIZE;
 				} else {
-					if (i2c_bus->msgs_index + 1 ==
-						i2c_bus->msgs_count) {
-						dev_dbg(i2c_bus->dev,
-							"last stop\n");
-						cmd |= AST_I2CM_RX_CMD_LAST |
-							   AST_I2CM_STOP_CMD;
+					if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+						dev_dbg(i2c_bus->dev, "last stop\n");
+						cmd |= AST_I2CM_RX_CMD_LAST | AST_I2CM_STOP_CMD;
 					}
 				}
-				dev_dbg(i2c_bus->dev,
-					"M: next rx len [%d/%d] , cmd %x\n",
-					xfer_len, msg->len, cmd);
+				dev_dbg(i2c_bus->dev, "M: next rx len [%d/%d] , cmd %x\n", xfer_len,
+					msg->len, cmd);
 				writel(AST_I2CM_SET_RX_DMA_LEN(xfer_len - 1),
-					i2c_bus->reg_base + AST_I2CM_DMA_LEN);
-				writel(i2c_bus->master_dma_addr +
-					i2c_bus->master_xfer_cnt,
-					i2c_bus->reg_base + AST_I2CM_RX_DMA);
+				       i2c_bus->reg_base + AST_I2CM_DMA_LEN);
+				writel(i2c_bus->master_dma_addr + i2c_bus->master_xfer_cnt,
+				       i2c_bus->reg_base + AST_I2CM_RX_DMA);
 			} else if (i2c_bus->mode == BUFF_MODE) {
 				cmd |= AST_I2CM_RX_BUFF_EN;
-				xfer_len = msg->len -
-					   i2c_bus->master_xfer_cnt;
+				xfer_len = msg->len - i2c_bus->master_xfer_cnt;
 				if (xfer_len > i2c_bus->buf_size) {
 					xfer_len = i2c_bus->buf_size;
 				} else {
-					if (i2c_bus->msgs_index + 1 ==
-						i2c_bus->msgs_count) {
-						dev_dbg(i2c_bus->dev,
-							"last stop\n");
-						cmd |= AST_I2CM_RX_CMD_LAST |
-							   AST_I2CM_STOP_CMD;
+					if (i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) {
+						dev_dbg(i2c_bus->dev, "last stop\n");
+						cmd |= AST_I2CM_RX_CMD_LAST | AST_I2CM_STOP_CMD;
 					}
 				}
 				writel(AST_I2CC_SET_RX_BUF_LEN(xfer_len),
-					i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+				       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 			} else {
-				if ((i2c_bus->msgs_index + 1 ==
-					 i2c_bus->msgs_count) &&
-					((i2c_bus->master_xfer_cnt + 1) ==
-					 msg->len)) {
-					dev_dbg(i2c_bus->dev,
-						"last stop\n");
-					cmd |= AST_I2CM_RX_CMD_LAST |
-						   AST_I2CM_STOP_CMD;
+				if ((i2c_bus->msgs_index + 1 == i2c_bus->msgs_count) &&
+				    ((i2c_bus->master_xfer_cnt + 1) == msg->len)) {
+					dev_dbg(i2c_bus->dev, "last stop\n");
+					cmd |= AST_I2CM_RX_CMD_LAST | AST_I2CM_STOP_CMD;
 				}
 			}
-			dev_dbg(i2c_bus->dev,
-				"M: next rx len %d, cmd %x\n",
-				xfer_len, cmd);
+			dev_dbg(i2c_bus->dev, "M: next rx len %d, cmd %x\n", xfer_len, cmd);
 			writel(cmd, i2c_bus->reg_base + AST_I2CM_CMD_STS);
 		}
 		break;
 	default:
-		printk("todo care sts %x\n", sts);
+		dev_dbg(i2c_bus->dev, "todo care sts %x\n", sts);
 		break;
 	}
-
 }
 
-int aspeed_new_i2c_master_irq(struct aspeed_new_i2c_bus *i2c_bus)
+static int aspeed_new_i2c_master_irq(struct aspeed_new_i2c_bus *i2c_bus)
 {
 	u32 sts = readl(i2c_bus->reg_base + AST_I2CM_ISR);
 
@@ -1392,18 +1240,15 @@
 		sts &= ~AST_I2CM_SMBUS_ALT;
 
 	if (AST_I2CM_BUS_RECOVER_FAIL & sts) {
-		dev_dbg(i2c_bus->dev,
-			"M clear isr: AST_I2CM_BUS_RECOVER_FAIL= %x\n", sts);
-		writel(AST_I2CM_BUS_RECOVER_FAIL,
-				i2c_bus->reg_base + AST_I2CM_ISR);
+		dev_dbg(i2c_bus->dev, "M clear isr: AST_I2CM_BUS_RECOVER_FAIL= %x\n", sts);
+		writel(AST_I2CM_BUS_RECOVER_FAIL, i2c_bus->reg_base + AST_I2CM_ISR);
 		i2c_bus->cmd_err = -EPROTO;
 		complete(&i2c_bus->cmd_complete);
 		return 1;
 	}
 
 	if (AST_I2CM_BUS_RECOVER & sts) {
-		dev_dbg(i2c_bus->dev, "M clear isr: AST_I2CM_BUS_RECOVER= %x\n",
-			sts);
+		dev_dbg(i2c_bus->dev, "M clear isr: AST_I2CM_BUS_RECOVER= %x\n", sts);
 		writel(AST_I2CM_BUS_RECOVER, i2c_bus->reg_base + AST_I2CM_ISR);
 		i2c_bus->cmd_err = 0;
 		complete(&i2c_bus->cmd_complete);
@@ -1411,16 +1256,13 @@
 	}
 
 	if (AST_I2CM_SMBUS_ALT & sts) {
-		if (readl(i2c_bus->reg_base + AST_I2CM_IER) &
-		    AST_I2CM_SMBUS_ALT) {
-			dev_dbg(i2c_bus->dev,
-				"M clear isr: AST_I2CM_SMBUS_ALT= %x\n", sts);
-			//Disable ALT INT
-			writel(readl(i2c_bus->reg_base + AST_I2CM_IER) &
-					~AST_I2CM_SMBUS_ALT,
-					i2c_bus->reg_base + AST_I2CM_IER);
-			writel(AST_I2CM_SMBUS_ALT,
-					i2c_bus->reg_base + AST_I2CM_ISR);
+		if (readl(i2c_bus->reg_base + AST_I2CM_IER) & AST_I2CM_SMBUS_ALT) {
+			dev_dbg(i2c_bus->dev, "M clear isr: AST_I2CM_SMBUS_ALT= %x\n", sts);
+			/* Disable ALT INT */
+			writel(readl(i2c_bus->reg_base + AST_I2CM_IER) & ~AST_I2CM_SMBUS_ALT,
+			       i2c_bus->reg_base + AST_I2CM_IER);
+			i2c_handle_smbus_alert(i2c_bus->ara);
+			writel(AST_I2CM_SMBUS_ALT, i2c_bus->reg_base + AST_I2CM_ISR);
 			dev_err(i2c_bus->dev,
 				"TODO aspeed_master_alert_recv bus id %d, Disable Alt, Please Imple\n",
 				i2c_bus->adap.nr);
@@ -1430,8 +1272,7 @@
 
 	i2c_bus->cmd_err = aspeed_new_i2c_is_irq_error(sts);
 	if (i2c_bus->cmd_err) {
-		dev_dbg(i2c_bus->dev, "received error interrupt: 0x%02x\n",
-			sts);
+		dev_dbg(i2c_bus->dev, "received error interrupt: 0x%02x\n", sts);
 		writel(AST_I2CM_PKT_DONE, i2c_bus->reg_base + AST_I2CM_ISR);
 		complete(&i2c_bus->cmd_complete);
 		return 1;
@@ -1444,9 +1285,8 @@
 
 	if (readl(i2c_bus->reg_base + AST_I2CM_ISR)) {
 		dev_dbg(i2c_bus->dev, "master TODO care sts %x\n",
-		       readl(i2c_bus->reg_base + AST_I2CM_ISR));
-		writel(readl(i2c_bus->reg_base + AST_I2CM_ISR),
-				i2c_bus->reg_base + AST_I2CM_ISR);
+			readl(i2c_bus->reg_base + AST_I2CM_ISR));
+		writel(readl(i2c_bus->reg_base + AST_I2CM_ISR), i2c_bus->reg_base + AST_I2CM_ISR);
 	}
 
 	return 0;
@@ -1459,8 +1299,7 @@
 #ifdef CONFIG_I2C_SLAVE
 	if (readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL) & AST_I2CC_SLAVE_EN) {
 		if (aspeed_new_i2c_slave_irq(i2c_bus)) {
-			dev_dbg(i2c_bus->dev, "bus-%d.slave handle\n",
-				i2c_bus->adap.nr);
+			dev_dbg(i2c_bus->dev, "bus-%d.slave handle\n", i2c_bus->adap.nr);
 			return IRQ_HANDLED;
 		}
 	}
@@ -1476,8 +1315,7 @@
 
 	/* If bus is busy in a single master environment, attempt recovery. */
 	if (!i2c_bus->multi_master &&
-	    (readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF) &
-	     AST_I2CC_BUS_BUSY_STS)) {
+	    (readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF) & AST_I2CC_BUS_BUSY_STS)) {
 		int ret;
 
 		ret = aspeed_new_i2c_recover_bus(i2c_bus);
@@ -1492,27 +1330,20 @@
 	dev_dbg(i2c_bus->dev, "aspeed_new_i2c_do_msgs_xfer msg cnt %d\n", num);
 	reinit_completion(&i2c_bus->cmd_complete);
 	aspeed_new_i2c_do_start(i2c_bus);
-	timeout = wait_for_completion_timeout(&i2c_bus->cmd_complete,
-					      i2c_bus->adap.timeout);
+	timeout = wait_for_completion_timeout(&i2c_bus->cmd_complete, i2c_bus->adap.timeout);
 	if (timeout == 0) {
 		int isr = readl(i2c_bus->reg_base + AST_I2CM_ISR);
 
-		if (isr)
-			return aspeed_new_i2c_is_irq_error(isr);
-		/*
-		 * If timed out and bus is still busy in a multi master
-		 * environment, attempt recovery at here.
-		 */
-		if (i2c_bus->multi_master &&
-		    (readl(i2c_bus->reg_base + AST_I2CC_STS_AND_BUFF) &
-		     AST_I2CC_BUS_BUSY_STS))
+		dev_dbg(i2c_bus->dev, "timeout\n");
+		if (isr) {
+			dev_dbg(i2c_bus->dev, "recovery situation isr %x\n", isr);
 			aspeed_new_i2c_recover_bus(i2c_bus);
-		printk("i2c driver tineout ~~\n");//test line
+			return aspeed_new_i2c_is_irq_error(isr);
+		}
 		return -ETIMEDOUT;
 	}
 
-	dev_dbg(i2c_bus->dev, "bus%d-m: %d end\n", i2c_bus->adap.nr,
-		i2c_bus->cmd_err);
+	dev_dbg(i2c_bus->dev, "bus%d-m: %d end\n", i2c_bus->adap.nr, i2c_bus->cmd_err);
 
 	return i2c_bus->cmd_err;
 }
@@ -1522,7 +1353,7 @@
 	struct platform_device *pdev = to_platform_device(i2c_bus->dev);
 	u32 fun_ctrl = AST_I2CC_BUS_AUTO_RELEASE | AST_I2CC_MASTER_EN;
 
-	//I2C Reset
+	/* I2C Reset */
 	writel(0, i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
 
 	if (of_property_read_bool(pdev->dev.of_node, "multi-master"))
@@ -1534,29 +1365,18 @@
 	writel(fun_ctrl, i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
 
 	/* Set AC Timing */
-	writel(aspeed_select_i2c_clock(i2c_bus),
-			i2c_bus->reg_base + AST_I2CC_AC_TIMING);
+	writel(aspeed_select_i2c_clock(i2c_bus), i2c_bus->reg_base + AST_I2CC_AC_TIMING);
 
-	//Clear Interrupt
+	/* Clear Interrupt */
 	writel(0xfffffff, i2c_bus->reg_base + AST_I2CM_ISR);
 
 #ifdef CONFIG_I2C_SLAVE
-	//for memory buffer initial
+	/* for memory buffer initial */
 	if (i2c_bus->mode == DMA_MODE) {
-		i2c_bus->slave_dma_buf =
-			dma_alloc_coherent(i2c_bus->dev, I2C_SLAVE_MSG_BUF_SIZE,
-					   &i2c_bus->slave_dma_addr,
-					   GFP_KERNEL);
-		if (!i2c_bus->slave_dma_buf) {
-			dev_err(i2c_bus->dev,
-				"unable to allocate tx Buffer memory\n");
-		} else
-			memset(i2c_bus->slave_dma_buf, 0,
-			       I2C_SLAVE_MSG_BUF_SIZE);
-
-		dev_dbg(i2c_bus->dev,
-			"dma enable slave_dma_buf = [0x%x] slave_dma_addr = [0x%x], please check 4byte boundary\n",
-			(u32)i2c_bus->slave_dma_buf, i2c_bus->slave_dma_addr);
+		i2c_bus->slave_dma_buf = dma_alloc_coherent(i2c_bus->dev, I2C_SLAVE_MSG_BUF_SIZE,
+							    &i2c_bus->slave_dma_addr, GFP_KERNEL);
+		if (!i2c_bus->slave_dma_buf)
+			return;
 	}
 
 	writel(0xfffffff, i2c_bus->reg_base + AST_I2CS_ISR);
@@ -1583,23 +1403,20 @@
 		client->addr);
 
 	writel(0, i2c_bus->reg_base + AST_I2CS_ADDR_CTRL);
-	writel(AST_I2CC_SLAVE_EN |
-			readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL),
-			i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
+	writel(AST_I2CC_SLAVE_EN | readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL),
+	       i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
 
-	//trigger rx buffer
+	/* trigger rx buffer */
 	if (i2c_bus->mode == DMA_MODE) {
 		cmd |= AST_I2CS_RX_DMA_EN;
-		writel(i2c_bus->slave_dma_addr,
-				i2c_bus->reg_base + AST_I2CS_RX_DMA);
-		writel(i2c_bus->slave_dma_addr,
-				i2c_bus->reg_base + AST_I2CS_TX_DMA);
+		writel(i2c_bus->slave_dma_addr, i2c_bus->reg_base + AST_I2CS_RX_DMA);
+		writel(i2c_bus->slave_dma_addr, i2c_bus->reg_base + AST_I2CS_TX_DMA);
 		writel(AST_I2CS_SET_RX_DMA_LEN(I2C_SLAVE_MSG_BUF_SIZE),
-			i2c_bus->reg_base + AST_I2CS_DMA_LEN);
+		       i2c_bus->reg_base + AST_I2CS_DMA_LEN);
 	} else if (i2c_bus->mode == BUFF_MODE) {
 		cmd |= AST_I2CS_RX_BUFF_EN;
 		writel(AST_I2CC_SET_RX_BUF_LEN(i2c_bus->buf_size),
-				i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
+		       i2c_bus->reg_base + AST_I2CC_BUFF_CTRL);
 	} else {
 		cmd &= ~AST_I2CS_PKT_MODE_EN;
 	}
@@ -1607,8 +1424,7 @@
 	writel(cmd, i2c_bus->reg_base + AST_I2CS_CMD_STS);
 	i2c_bus->slave = client;
 	/* Set slave addr. */
-	writel(client->addr | AST_I2CS_ADDR1_ENABLE,
-			i2c_bus->reg_base + AST_I2CS_ADDR_CTRL);
+	writel(client->addr | AST_I2CS_ADDR1_ENABLE, i2c_bus->reg_base + AST_I2CS_ADDR_CTRL);
 
 	return 0;
 }
@@ -1620,12 +1436,10 @@
 	WARN_ON(!i2c_bus->slave);
 
 	/* Turn off slave mode. */
-	writel(~AST_I2CC_SLAVE_EN &
-			readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL),
-			i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
-	writel(readl(i2c_bus->reg_base + AST_I2CS_ADDR_CTRL) &
-			~AST_I2CS_ADDR1_MASK,
-			i2c_bus->reg_base + AST_I2CS_ADDR_CTRL);
+	writel(~AST_I2CC_SLAVE_EN & readl(i2c_bus->reg_base + AST_I2CC_FUN_CTRL),
+	       i2c_bus->reg_base + AST_I2CC_FUN_CTRL);
+	writel(readl(i2c_bus->reg_base + AST_I2CS_ADDR_CTRL) & ~AST_I2CS_ADDR1_MASK,
+	       i2c_bus->reg_base + AST_I2CS_ADDR_CTRL);
 
 	i2c_bus->slave = NULL;
 
@@ -1651,33 +1465,31 @@
 	{
 		.compatible = "aspeed,ast2600-i2c-bus",
 	},
-	{},
+	{}
 };
 
 MODULE_DEVICE_TABLE(of, aspeed_new_i2c_bus_of_table);
 
 static int aspeed_new_i2c_probe(struct platform_device *pdev)
 {
-	const struct of_device_id *match;
 	struct aspeed_new_i2c_bus *i2c_bus;
+	const struct of_device_id *match;
+	struct resource *res;
 	u32 global_ctrl;
 	int ret = 0, bus = 0;
-        struct resource *res;
-	i2c_bus = devm_kzalloc(&pdev->dev, sizeof(struct aspeed_new_i2c_bus),
-			       GFP_KERNEL);
+
+	i2c_bus = devm_kzalloc(&pdev->dev, sizeof(*i2c_bus), GFP_KERNEL);
 	if (!i2c_bus)
 		return -ENOMEM;
 
-	i2c_bus->global_reg =
-		syscon_regmap_lookup_by_compatible("aspeed,ast2600-i2c-global");
+	i2c_bus->global_reg = syscon_regmap_lookup_by_compatible("aspeed,ast2600-i2c-global");
 	if (IS_ERR(i2c_bus->global_reg)) {
-		dev_err(&pdev->dev,
-			"failed to find ast2600 i2c global regmap\n");
+		dev_err(&pdev->dev, "failed to find ast2600 i2c global regmap\n");
 		ret = -ENOMEM;
 		goto free_mem;
 	}
 
-	//get global control register
+	/* get global control register */
 	regmap_read(i2c_bus->global_reg, ASPEED_I2CG_CTRL, &global_ctrl);
 
 	if (global_ctrl & ASPEED_I2CG_CTRL_NEW_CLK_DIV)
@@ -1689,6 +1501,7 @@
 		dev_err(&pdev->dev, "Expect I2CG0C[2] = 1 (new reg mode)\n");
 		goto free_mem;
 	}
+
 	ret = of_property_read_u32(pdev->dev.of_node, "bus-mode", &bus);
 	if(ret < 0)
 	{
@@ -1738,6 +1551,7 @@
 		i2c_bus->mode = BUFF_MODE;
 	}*/
 
+
 	i2c_bus->dev = &pdev->dev;
 	init_completion(&i2c_bus->cmd_complete);
 
@@ -1771,8 +1585,7 @@
 	i2c_bus->apb_clk = clk_get_rate(i2c_bus->clk);
 	dev_dbg(i2c_bus->dev, "i2c_bus->apb_clk %d\n", i2c_bus->apb_clk);
 
-	ret = of_property_read_u32(pdev->dev.of_node, "bus-frequency",
-				   &i2c_bus->bus_frequency);
+	ret = of_property_read_u32(pdev->dev.of_node, "bus-frequency", &i2c_bus->bus_frequency);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Could not read bus-frequency property\n");
 		i2c_bus->bus_frequency = 100000;
@@ -1785,13 +1598,13 @@
 	i2c_bus->adap.dev.parent = i2c_bus->dev;
 	i2c_bus->adap.dev.of_node = pdev->dev.of_node;
 	i2c_bus->adap.algo_data = i2c_bus;
-	strlcpy(i2c_bus->adap.name, pdev->name, sizeof(i2c_bus->adap.name));
+	strscpy(i2c_bus->adap.name, pdev->name, sizeof(i2c_bus->adap.name));
 	i2c_set_adapdata(&i2c_bus->adap, i2c_bus);
 
 	aspeed_new_i2c_init(i2c_bus);
 
-	ret = devm_request_irq(&pdev->dev, i2c_bus->irq, aspeed_new_i2c_bus_irq,
-			       0, dev_name(&pdev->dev), i2c_bus);
+	ret = devm_request_irq(&pdev->dev, i2c_bus->irq, aspeed_new_i2c_bus_irq, 0,
+			       dev_name(&pdev->dev), i2c_bus);
 	if (ret < 0)
 		goto unmap;
 
@@ -1801,24 +1614,21 @@
 
 	if (of_property_read_bool(pdev->dev.of_node, "smbus-alert")) {
 		i2c_bus->alert_enable = 1;
-		i2c_bus->ara = i2c_setup_smbus_alert(&i2c_bus->adap,
-							 &i2c_bus->alert_data);
+		i2c_bus->ara = i2c_setup_smbus_alert(&i2c_bus->adap, &i2c_bus->alert_data);
 		if (!i2c_bus->ara)
 			dev_warn(i2c_bus->dev, "Failed to register ARA client\n");
 
-		writel(AST_I2CM_PKT_DONE | AST_I2CM_BUS_RECOVER |
-				AST_I2CM_SMBUS_ALT,
-				i2c_bus->reg_base + AST_I2CM_IER);
+		writel(AST_I2CM_PKT_DONE | AST_I2CM_BUS_RECOVER | AST_I2CM_SMBUS_ALT,
+		       i2c_bus->reg_base + AST_I2CM_IER);
 	} else {
 		i2c_bus->alert_enable = 0;
 		/* Set interrupt generation of I2C master controller */
-		writel(AST_I2CM_PKT_DONE | AST_I2CM_BUS_RECOVER,
-					i2c_bus->reg_base + AST_I2CM_IER);
+		writel(AST_I2CM_PKT_DONE | AST_I2CM_BUS_RECOVER, i2c_bus->reg_base + AST_I2CM_IER);
 	}
 
 	dev_info(i2c_bus->dev, "NEW-I2C: %s [%d]: adapter [%d khz] mode [%d]\n",
-		 pdev->dev.of_node->name, i2c_bus->adap.nr,
-		 i2c_bus->bus_frequency / 1000, i2c_bus->mode);
+		 pdev->dev.of_node->name, i2c_bus->adap.nr, i2c_bus->bus_frequency / 1000,
+		 i2c_bus->mode);
 
 	return 0;
 
diff -Naur linux_old/drivers/i2c/busses/Kconfig linux/drivers/i2c/busses/Kconfig
--- linux_old/drivers/i2c/busses/Kconfig	2021-09-07 11:25:48.856375000 +0800
+++ linux/drivers/i2c/busses/Kconfig	2021-09-07 11:07:24.978362453 +0800
@@ -375,11 +375,18 @@
 	  will be called i2c-altera.
 
 config I2C_NEW_ASPEED
-	bool "Aspeed New I2C Controller"
-	depends on ARCH_ASPEED || MACH_ASPEED_G6
+	tristate "Aspeed New I2C Controller"
+	depends on ARCH_ASPEED || MACH_ASPEED_G6 || COMPILE_TEST
+	select I2C_SMBUS
+	help
+	  If you say yes to this option, support will be included for the
+	  Aspeed I2C controller with new register set.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-new-aspeed.
 
 config I2C_ASPEED
-	bool "Aspeed I2C Controller"
+	tristate "Aspeed I2C Controller"
 	depends on ARCH_ASPEED || COMPILE_TEST
 	help
 	  If you say yes to this option, support will be included for the
diff -Naur linux_old/drivers/i2c/i2c-core-smbus.c linux/drivers/i2c/i2c-core-smbus.c
--- linux_old/drivers/i2c/i2c-core-smbus.c	2020-12-21 20:27:07.000000000 +0800
+++ linux/drivers/i2c/i2c-core-smbus.c	2021-09-07 11:07:24.998362453 +0800
@@ -37,8 +37,15 @@
 	return (u8)(data >> 8);
 }
 
-/* Incremental CRC8 over count bytes in the array pointed to by p */
-static u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)
+/**
+ * i2c_smbus_pec - Incremental CRC8 over the given input data array
+ * @crc: previous return crc8 value
+ * @p: pointer to data buffer.
+ * @count: number of bytes in data buffer.
+ *
+ * Incremental CRC8 over count bytes in the array pointed to by p
+ */
+u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)
 {
 	int i;
 
@@ -46,6 +53,7 @@
 		crc = crc8((crc ^ p[i]) << 8);
 	return crc;
 }
+EXPORT_SYMBOL(i2c_smbus_pec);
 
 /* Assume a 7-bit address, which is reasonable for SMBus */
 static u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)
diff -Naur linux_old/include/linux/i2c.h linux/include/linux/i2c.h
--- linux_old/include/linux/i2c.h	2021-09-07 11:25:48.908375000 +0800
+++ linux/include/linux/i2c.h	2021-09-07 09:53:38.000000000 +0800
@@ -146,6 +146,7 @@
 /* Now follow the 'nice' access routines. These also document the calling
    conventions of i2c_smbus_xfer. */
 
+u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count);
 extern s32 i2c_smbus_read_byte(const struct i2c_client *client);
 extern s32 i2c_smbus_write_byte(const struct i2c_client *client, u8 value);
 extern s32 i2c_smbus_read_byte_data(const struct i2c_client *client,
