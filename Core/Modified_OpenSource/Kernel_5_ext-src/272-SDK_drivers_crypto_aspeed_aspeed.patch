diff -Nuar a/drivers/crypto/aspeed/aspeed-hace.c b/drivers/crypto/aspeed/aspeed-hace.c
--- a/drivers/crypto/aspeed/aspeed-hace.c	2023-09-01 16:22:17.814357384 +0530
+++ b/drivers/crypto/aspeed/aspeed-hace.c	2023-09-01 16:21:35.181793769 +0530
@@ -34,6 +34,21 @@
 #define HACE_DBUG(fmt, args...)
 #endif
 
+static unsigned char *dummy_key1;
+static unsigned char *dummy_key2;
+
+int find_dummy_key(const char *key, int keylen)
+{
+	int ret = 0;
+
+	if (dummy_key1 && memcmp(key, dummy_key1, keylen) == 0)
+		ret = 1;
+	else if (dummy_key2 && memcmp(key, dummy_key2, keylen) == 0)
+		ret = 2;
+
+	return ret;
+}
+
 static irqreturn_t aspeed_hace_irq(int irq, void *dev)
 {
 	struct aspeed_hace_dev *hace_dev = (struct aspeed_hace_dev *)dev;
@@ -158,6 +173,7 @@
 	struct aspeed_engine_hash *hash_engine;
 	struct aspeed_hace_engine_rsa *rsa_engine;
 	int err;
+	struct device_node *sec_node;
 
 
 	hace_dev = devm_kzalloc(&pdev->dev, sizeof(struct aspeed_hace_dev), GFP_KERNEL);
@@ -260,6 +276,34 @@
 		}
 	}
 
+	if (of_find_property(dev->of_node, "dummy-key1", NULL)) {
+		dummy_key1 = kzalloc(DUMMY_KEY_SIZE, GFP_KERNEL);
+		if (dummy_key1) {
+			err = of_property_read_u8_array(dev->of_node, "dummy-key1", dummy_key1, DUMMY_KEY_SIZE);
+			if (err)
+				dev_err(dev, "err read dummy_key 1\n");
+		} else
+			dev_err(dev, "error dummy_key1 allocation\n");
+	}
+	if (of_find_property(dev->of_node, "dummy-key2", NULL)) {
+		dummy_key2 = kzalloc(DUMMY_KEY_SIZE, GFP_KERNEL);
+		if (dummy_key2) {
+			err = of_property_read_u8_array(dev->of_node, "dummy-key2", dummy_key2, DUMMY_KEY_SIZE);
+			if (err)
+				dev_err(dev, "err read dummy_key 2\n");
+		} else
+			dev_err(dev, "error dummy_key2 allocation\n");
+	}
+
+	sec_node = of_find_compatible_node(NULL, NULL, "aspeed,ast2600-otp");
+	if (!sec_node) {
+		dev_err(dev, "[%s:%d] cannot find sec node\n", __func__, __LINE__);
+	} else {
+		hace_dev->sec_regs = of_iomap(sec_node, 0);
+		if (!hace_dev->sec_regs)
+			dev_err(dev, "[%s:%d] failed to map SEC registers\n", __func__, __LINE__);
+	}
+
 	err = aspeed_hace_register(hace_dev);
 	if (err) {
 		dev_err(dev, "err in register alg");
@@ -278,6 +322,8 @@
 	//aspeed_hace_unregister();
 	// tasklet_kill(&hace_dev->done_task);
 	// tasklet_kill(&hace_dev->queue_task);
+	kfree(dummy_key1);
+	kfree(dummy_key2);
 	return 0;
 }
 
diff -Nuar a/drivers/crypto/aspeed/aspeed-hace-crypto.c b/drivers/crypto/aspeed/aspeed-hace-crypto.c
--- a/drivers/crypto/aspeed/aspeed-hace-crypto.c	2023-09-01 16:22:17.814357384 +0530
+++ b/drivers/crypto/aspeed/aspeed-hace-crypto.c	2023-09-01 16:21:35.181793769 +0530
@@ -17,6 +17,11 @@
  */
 #include "aspeed-hace.h"
 
+#define ASPEED_SEC_PROTECTION		0x0
+#define SEC_UNLOCK_PASSWORD			0x349fe38a
+#define ASPEED_VAULT_KEY_CTRL		0x80C
+#define SEC_VK_CTRL_VK_SELECTION	BIT(0)
+
 // #define ASPEED_CIPHER_DEBUG
 
 #ifdef ASPEED_CIPHER_DEBUG
@@ -217,6 +222,8 @@
 	struct aspeed_engine_crypto *crypto_engine = &hace_dev->crypto_engine;
 	struct skcipher_request *req = skcipher_request_cast(crypto_engine->areq);
 	struct aspeed_cipher_reqctx *rctx = skcipher_request_ctx(req);
+	struct crypto_skcipher *cipher = crypto_skcipher_reqtfm(req);
+	struct aspeed_cipher_ctx *ctx = crypto_skcipher_ctx(cipher);
 	struct device *dev = hace_dev->dev;
 	struct aspeed_sg_list *src_list, *dst_list;
 	dma_addr_t src_dma_addr, dst_dma_addr;
@@ -224,12 +231,52 @@
 	int total, i;
 	int src_sg_len;
 	int dst_sg_len;
+	int use_vault_key = 0;
+	unsigned int val;
 
 	CIPHER_DBG("\n");
 
 	rctx->enc_cmd |= HACE_CMD_DES_SG_CTRL | HACE_CMD_SRC_SG_CTRL |
 			 HACE_CMD_AES_KEY_HW_EXP | HACE_CMD_MBUS_REQ_SYNC_EN;
 
+	if (crypto_engine->load_vault_key) {
+		writel(SEC_UNLOCK_PASSWORD, hace_dev->sec_regs + ASPEED_SEC_PROTECTION);
+		CIPHER_DBG("unlock SB, SEC000=0x%x\n", readl(hace_dev->sec_regs + ASPEED_SEC_PROTECTION));
+		val = readl(hace_dev->sec_regs + ASPEED_VAULT_KEY_CTRL);
+		if (val & BIT(2)) {
+			if (ctx->dummy_key == 1 && !(val & BIT(0))) {
+				use_vault_key = 1;
+				CIPHER_DBG("Vault key 1:\n");
+			} else if (ctx->dummy_key == 2 && (val & BIT(0))) {
+				use_vault_key = 1;
+				CIPHER_DBG("Vault key 2:\n");
+			} else {
+				use_vault_key = 0;
+			}
+		} else {
+			if (ctx->dummy_key == 1) {
+				use_vault_key = 1;
+				val &= ~SEC_VK_CTRL_VK_SELECTION;
+				writel(val, hace_dev->sec_regs + ASPEED_VAULT_KEY_CTRL);
+				CIPHER_DBG("Vault key 1:\n");
+			} else if (ctx->dummy_key == 2) {
+				use_vault_key = 1;
+				val |= SEC_VK_CTRL_VK_SELECTION;
+				writel(val, hace_dev->sec_regs + ASPEED_VAULT_KEY_CTRL);
+				CIPHER_DBG("Vault key 2:\n");
+			} else {
+				use_vault_key = 0;
+			}
+		}
+		writel(0x0, hace_dev->sec_regs + ASPEED_SEC_PROTECTION);
+		CIPHER_DBG("lock SB, SEC000=0x%x\n", readl(hace_dev->sec_regs + ASPEED_SEC_PROTECTION));
+
+		if (use_vault_key)
+			rctx->enc_cmd |= HACE_CMD_AES_KEY_FROM_OTP;
+		else
+			rctx->enc_cmd &= ~HACE_CMD_AES_KEY_FROM_OTP;
+	}
+
 	if (req->dst == req->src) {
 		src_sg_len = dma_map_sg(dev, req->src, rctx->src_nents, DMA_BIDIRECTIONAL);
 		dst_sg_len = src_sg_len;
@@ -476,7 +523,6 @@
 	CIPHER_DBG("bits : %d :\n", keylen);
 
 	if (keylen != DES_KEY_SIZE && keylen != 2 * DES_KEY_SIZE && keylen != 3 * DES_KEY_SIZE) {
-		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
 		dev_err(dev, "keylen fail %d bits\n", keylen);
 		return -EINVAL;
 	}
@@ -656,11 +702,11 @@
 
 	CIPHER_DBG("bits : %d\n", (keylen * 8));
 
+	ctx->dummy_key = find_dummy_key(key, keylen);
+
 	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
-	    keylen != AES_KEYSIZE_256) {
-		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);
+	    keylen != AES_KEYSIZE_256)
 		return -EINVAL;
-	}
 
 	if (ctx->hace_dev->version == 5) {
 		aes_expandkey(&gen_aes_key, key, keylen);
@@ -1086,10 +1132,8 @@
 	CIPHER_DBG("bits : %d\n", (keylen * 8));
 
 	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
-	    keylen != AES_KEYSIZE_256) {
-		crypto_aead_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);
+	    keylen != AES_KEYSIZE_256)
 		return -EINVAL;
-	}
 	memcpy(ctx->key, key, keylen);
 	aspeed_gcm_subkey(ctx->aes, data, 16, key, keylen);
 	memcpy(ctx->sub_key, data, 16);
@@ -1538,11 +1582,41 @@
 	}
 };
 
+#ifdef CONFIG_ASPEED_OTP
+void find_vault_key(struct aspeed_hace_dev *hace_dev)
+{
+	struct aspeed_engine_crypto *crypto_engine = &hace_dev->crypto_engine;
+	u32 otp_data[16];
+	int i;
+
+	crypto_engine->load_vault_key = 0;
+
+	otp_read_data_buf(0, otp_data, 16);
+	for (i = 0; i < 16; i++) {
+		CIPHER_DBG("OTPDATA%d=%x\n", i, otp_data[i]);
+		if (((otp_data[i] >> 14) & 0xf) == 1) {
+			CIPHER_DBG("Found vault key in OTP\n");
+			crypto_engine->load_vault_key = 1;
+			return;
+		}
+		if (otp_data[i] & BIT(13))
+			break;
+	}
+	CIPHER_DBG("Not found vault key in OTP\n");
+}
+#endif
+
 int aspeed_register_hace_crypto_algs(struct aspeed_hace_dev *hace_dev)
 {
 	int i;
 	int err = 0;
 
+#ifdef CONFIG_ASPEED_OTP
+	find_vault_key(hace_dev);
+#else
+	hace_dev->crypto_engine.load_vault_key = 0;
+#endif
+
 	for (i = 0; i < ARRAY_SIZE(aspeed_crypto_algs); i++) {
 		aspeed_crypto_algs[i].hace_dev = hace_dev;
 		err = crypto_register_skcipher(&aspeed_crypto_algs[i].alg.skcipher);
diff -Nuar a/drivers/crypto/aspeed/aspeed-hace.h b/drivers/crypto/aspeed/aspeed-hace.h
--- a/drivers/crypto/aspeed/aspeed-hace.h	2023-09-01 16:22:17.814357384 +0530
+++ b/drivers/crypto/aspeed/aspeed-hace.h	2023-09-01 16:21:35.181793769 +0530
@@ -25,8 +25,6 @@
 #include <crypto/sha.h>
 #include <crypto/ecdh.h>
 
-
-
 /* Crypto control registers*/
 #define ASPEED_HACE_SRC			0x00
 #define ASPEED_HACE_DEST		0x04
@@ -171,6 +169,8 @@
 
 #define SHA_FLAGS_FINUP			BIT(25)
 
+#define DUMMY_KEY_SIZE			32
+
 struct aspeed_hace_dev;
 
 typedef int (*aspeed_hace_fn_t)(struct aspeed_hace_dev *);
@@ -200,6 +200,7 @@
 	//dst dma addr in G6 gcm dec mode, the last 16 bytes indicate tag
 	void				*dst_sg_addr;
 	dma_addr_t			dst_sg_dma_addr; //g6
+	int				load_vault_key;
 };
 
 //tctx
@@ -207,6 +208,7 @@
 	struct aspeed_hace_dev		*hace_dev;
 	aspeed_hace_fn_t		start;
 	int 				key_len;
+	int				dummy_key;
 	u8				key[AES_MAX_KEYLENGTH];
 	u8				sub_key[16]; // for aes gcm
 	struct crypto_skcipher		*aes; // for caculating gcm(aes) subkey
@@ -344,6 +346,7 @@
 
 struct aspeed_hace_dev {
 	void __iomem			*regs;
+	void __iomem			*sec_regs;
 	struct device			*dev;
 	int 				irq;
 	struct clk			*yclk;
@@ -398,4 +401,7 @@
 extern int aspeed_register_hace_hash_algs(struct aspeed_hace_dev *hace_dev);
 extern int aspeed_register_hace_rsa_algs(struct aspeed_hace_dev *hace_dev);
 
+extern int find_dummy_key(const char *key, int keylen);
+extern void otp_read_data_buf(u32 offset, u32 *buf, u32 len);
+
 #endif
