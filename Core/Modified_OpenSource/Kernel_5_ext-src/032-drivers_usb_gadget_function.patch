--- linux/drivers/usb/gadget/function/ami_gadget_ioctl.h	2022-05-31 15:23:48.218051083 +0800
+++ linux-new/drivers/usb/gadget/function/ami_gadget_ioctl.h	2022-05-31 16:20:09.669401878 +0800
@@ -0,0 +1,288 @@
+/****************************************************************
+ **                                                            **
+ **    (C)Copyright 2006-2022, American Megatrends Inc.        **
+ **                                                            **
+ **            All Rights Reserved.                            **
+ **                                                            **
+ **        5555 Oakbrook Pkwy Suite 200, Norcross,             **
+ **                                                            **
+ **        Georgia - 30093, USA. Phone-(770)-246-8600.         **
+ **                                                            **
+****************************************************************/
+
+#ifndef __AMI_GADGET_IOCTL_H__
+#define __AMI_GADGET_IOCTL_H__
+
+/* Note :All Length Fields used in IUSB are Little Endian */
+
+#ifdef __GNUC__
+#define PACKED __attribute__ ((packed))
+#else
+#define PACKED
+#pragma pack( 1 )
+#endif
+#define AMI_USB_GADGET_MODE	(1)
+
+/*Ioctls */
+#define USB_KEYBD_LED		_IOC(_IOC_READ ,'U',0x12,0x3FFF)
+#define USB_KEYBD_LED_NO_WAIT	_IOC(_IOC_READ,'U',0x13,0x3FFF)
+#define USB_KEYBD_LED_RESET	_IOC(_IOC_WRITE,'U',0x14,0x3FFF)
+
+#define USB_CDROM_REQ		_IOC(_IOC_READ, 'U',0x31,0x3FFF)
+#define USB_CDROM_RES		_IOC(_IOC_WRITE,'U',0x32,0x3FFF)
+#define USB_CDROM_EXIT		_IOC(_IOC_WRITE,'U',0x33,0x3FFF)
+#define USB_CDROM_ACTIVATE	_IOC(_IOC_WRITE,'U',0x34,0x3FFF)
+
+#define USB_HDISK_REQ		_IOC(_IOC_READ, 'U',0x41,0x3FFF)
+#define USB_HDISK_RES		_IOC(_IOC_WRITE,'U',0x42,0x3FFF)
+#define USB_HDISK_EXIT		_IOC(_IOC_WRITE,'U',0x43,0x3FFF)
+#define USB_HDISK_ACTIVATE	_IOC(_IOC_WRITE,'U',0x44,0x3FFF)
+#define USB_HDISK_SET_TYPE	_IOC(_IOC_WRITE,'U',0x45,0x3FFF)
+#define USB_HDISK_GET_TYPE	_IOC(_IOC_READ, 'U',0x46,0x3FFF)
+
+#define USB_VENDOR_REQ		_IOC(_IOC_READ, 'U',0x61,0x3FFF)
+#define USB_VENDOR_RES		_IOC(_IOC_WRITE,'U',0x62,0x3FFF)
+#define USB_VENDOR_EXIT		_IOC(_IOC_WRITE,'U',0x63,0x3FFF)
+
+// Indicate the redirect_mode for gadget mass-storage;
+// 0: file-backed mode(handle SCSI command via origin gadget functions).
+// 1: virtual device mode(bypass SCSI command to remote client).
+#define USB_LUN_GET_REDIRECT_MODE	_IOC(_IOC_READ,'U',0x71,0x3FFF)
+#define USB_LUN_SET_REDIRECT_MODE	_IOC(_IOC_WRITE,'U',0x72,0x3FFF)
+
+#define USB_DISABLE_ALL_DEVICE _IOC(_IOC_WRITE,'U',0xF4,0x3FFF)
+#define USB_ENABLE_ALL_DEVICE _IOC(_IOC_WRITE,'U',0xF5,0x3FFF)
+#define USB_GET_ALL_DEVICE_STATUS _IOC(_IOC_WRITE,'U',0xF6,0x3FFF)
+
+#define USB_GET_VHUB_USED_PORT_STATUS	_IOC(_IOC_READ,'U',0x83,0x3FFF)
+
+/***************************************************/
+/***SCSI vendor specific commands for AMI****/
+/**Group 7***/
+#define ISAMICMD(x)							( ((x) & 0xE0) == 0xE0 )
+#define SCSI_AMICMD_HEARTBEAT 				(0xE0)
+
+#define SCSI_AMICMD_CURI_WRITE			 	(0xE2)
+#define SCSI_AMICMD_CURI_READ				(0xE3)
+
+#define SCSI_AMICMD_OSHBSTART				(0xE5)
+#define SCSI_AMICMD_OSHB					(0xE6)
+#define SCSI_AMICMD_OSHBSTOP				(0xE7)
+
+#define SCSI_AMICMD_SUSPEND_HEALTH_MONITORING		(0xE8)
+#define SCSI_AMICMD_RESUME_HEALTH_MONITORING		(0xE9)
+#define SCSI_AMICMD_GET_HEALTH_MONITORING_STATUS	(0xEA)
+
+#define SCSI_AMICMD_HOSTMOUSE			 	(0xE1)
+#define SCSI_AMICMD_TESTHOSTMOUSE			(0xEB)
+
+/*this command is used to identify the USB CCD exposed by G2**/
+/*we send this form host agents to all drives . If this command
+returns success with predefined data then we know it is a USB CDROM drive*/
+#define SCSI_AMICMD_ID						(0xEE)
+
+/* this definitions are used to identify whether the CMD is for
+ * Command sector or Data sector */
+#define SCSI_AMIDEF_CMD_SECTOR				(0x01)
+#define SCSI_AMIDEF_DATA_SECTOR				(0x02)
+
+/***************************************************/
+
+typedef unsigned char    uint8;
+typedef unsigned short   uint16;
+typedef unsigned int     uint32;
+
+/* SCSI Command Packets */
+typedef struct
+{
+	uint8		OpCode;
+	uint8		Lun;
+	uint32		Lba;
+	union
+	{
+		struct
+		{
+			uint8		Reserved6;
+			uint16		Length;
+			uint8		Reserved9[3];
+		} PACKED Cmd10;
+		struct Len32
+		{
+			uint32		Length32;
+			uint8		Reserved10[2];
+		} PACKED Cmd12;
+	} PACKED CmdLen;
+} PACKED SCSI_COMMAND_PACKET;
+
+typedef struct
+{
+	uint8 DataLen;
+	uint8 Data;
+} PACKED HID_PACKET;
+
+/*
+	 *******************************************************************************************************************
+	 * Refer to MMC-6 data sheet.
+	 * For SCSI command: 0x4A(GET EVENT/STATUS NOTIFICATION) response.
+	 * Table 264 - Event Status Notification Response.
+	 * For class code 100b - Returns Media Class events, need to include data as Table 265 + Table 278.
+	 * Table 265 - Event Header + Table 278 - Media Event Descriptor.
+	 *******************************************************************************************************************
+	 */
+typedef struct
+{	
+	uint16	EventLength;
+	uint8	NotificationClass;	// Support class code 100b - Media Class events only.
+	uint8	SupportEventClass;	// 0xDE as default for AMI.
+	uint8	MediaEventCode;
+	/*
+	 *******************************************************************************************************************
+	 * MMC - 6 Table 279: Media Event Format
+	 * 0h - NoEvent: 
+	 *			Media status is unchanged.
+	 * 1h - EjectRequest:
+	 *			The Logical Unit has received a request from the user(usually through a mechanical switch on the Logical Unit) to eject the specified slot or media.
+	 * 2h - NewMedia:
+	 * 			The specified slot (or the Logical Unit) has received new media, and is ready to access it.
+	 * 3h - MediaRemoval:
+	 *			The media has been removed from the specified slot, and the Logical Unit is unable to access the media without user intervention.
+	 * 4h - MediaChanged:
+	 *			The user has requested that the media in the specified slot be loaded.
+	 * 5h - BgformatCompleted:
+	 *		A DVD+RW background format has completed. Since DVD+RW Drives are capable of generating multiple media events concurrently,
+	 *		such Drives shall be capable of queuing media events.
+	 * 6h BgformatRestarted A DVD+RW background format has been automatically restarted by the Drive.
+	 *		Since DVD+RW Drives are capable of generating multiple media events concurrently,
+	 *		such Drives shall be capable of queuing media events.
+	 * 
+	 *******************************************************************************************************************
+	 */
+	uint8	MediaStatus;
+	/*
+	 *******************************************************************************************************************
+	 * MMC - 6 Table 280: Media Status Byte Definition
+	 * Bit 1 - If the Media Present bit is set to zero, no media is present in the Drive. If the Media Present bit is set to one,
+	 * 				media is present in the Drive.
+	 * Bit 0 - If the Door or Tray Open bit is set to zero, the Tray or Door mechanism is in the closed state.
+	 * 				If the Door or Tray Open bit is set to one, the Tray or Door mechanism is in the open state.
+	 * 				If the Drive does not have either a tray or a door, this bit shall be set to zero.
+	 *******************************************************************************************************************
+	 */
+	uint8	StartSlot;
+	uint8	EndSlot;
+	/*
+	 *******************************************************************************************************************
+	 * Slot Definition
+	 * Start Slot field defines the first slot of a multiple slot Drive the media status notification applies to.
+	 * 		For Drives that do not support multiple slots, this field shall be reserved.
+	 * End Slot field defines the last slot of a multiple slot Drive the media status notification applies to.
+	 * 		For Drives that do not support multiple slots, this field shall be reserved.
+	 *******************************************************************************************************************
+	 */
+} PACKED SCSI_GET_EVENT_STATUS_NOTIFICATION_PACKET;
+
+enum notification_class_field {
+	// For SCSI command: 0x4A(GET EVENT/STATUS NOTIFICATION) response.
+	// Refer to MMC - 6 Table 266.
+	NOTIFICATION_CLASS_ID_NO_SUPPORTED = 0, 
+	NOTIFICATION_CLASS_ID_OPERATIONAL_CHANGE_REQUEST_NOTIFICATION = 1, 
+	NOTIFICATION_CLASS_ID_POWER_MANAGEMENT = 2,
+	NOTIFICATION_CLASS_ID_EXTERNAL_REQUEST = 3,
+	NOTIFICATION_CLASS_ID_MEDIA = 4,
+	NOTIFICATION_CLASS_ID_MULTIPLE_HOSTS = 5,
+	NOTIFICATION_CLASS_ID_DEVICE_BUSY = 6,
+	NOTIFICATION_CLASS_ID_RESERVED	= 7,// reserved.
+};
+
+enum media_event_format {
+	// For SCSI command: 0x4A(GET EVENT/STATUS NOTIFICATION) response.
+	// Refer to Media Event Format above.
+	MEDIA_EVENT_ID_NO_EVENT = 0, 
+	MEDIA_EVENT_ID_EJECT_REQUEST = 1, 
+	MEDIA_EVENT_ID_NEW_MEDIA = 2,
+	MEDIA_EVENT_ID_MEDIA_REMOVAL = 3,
+	MEDIA_EVENT_ID_MEDIA_CHANGED = 4,
+	MEDIA_EVENT_ID_BGFORMATCOMPLETED = 5,
+	MEDIA_EVENT_ID_BGFORMATRESTARTED = 6,
+	MEDIA_EVENT_ID_RESERVED	= 7,// 7 ~ 0xF are reserved.
+};
+
+/*
+ *******************************************************************************************************************
+ * MMC - 6 Table 280
+ *******************************************************************************************************************
+ */
+#define TRAY_OPEN		(1 << 0)
+#define MEDIA_PRESENT	(1 << 1)
+
+
+/**************** Values for Direction Field of IUSB Header ****************/
+#define TO_REMOTE	0x00
+#define FROM_REMOTE	0x80
+
+#define FLEXIBLE_DISK_PAGE_CODE	(0x05)
+typedef struct
+{
+	uint16 ModeDataLen;
+#define MEDIUM_TYPE_DEFAULT	(0x00)
+#define MEDIUM_TYPE_720KB	(0x1e)
+#define MEDIUM_TYPE_125_MB	(0x93)
+#define MEDIUM_TYPE_144_MB	(0x94)
+	uint8 MediumTypeCode;
+	uint8 WriteProtect; // bit(7):write protect, bit(6-5):reserved, bit(4):DPOFUA which should be zero, bit(3-0) reserved
+	uint8 Reserved[4];
+} PACKED MODE_SENSE_RESP_HDR;
+
+typedef struct
+{
+	MODE_SENSE_RESP_HDR	ModeSenseRespHdr;
+#define MAX_MODE_SENSE_RESP_DATA_LEN	(72)
+#define FLEXIBLE_DISK_PAGE_LEN	(32)
+	uint8	PageData[MAX_MODE_SENSE_RESP_DATA_LEN];
+} PACKED MODE_SENSE_RESPONSE;
+
+typedef struct
+{
+	uint8	PageCode;
+	uint8	PageLength; //1Eh
+	uint16	TransferRate;
+	uint8	NumberofHeads;
+	uint8	SectorsPerTrack;
+	uint16	DataBytesPerSector;
+	uint16	NumberofCylinders;
+	uint8	Reserved1[9];
+	uint8	MotorONDelay;
+	uint8	MotorOFFDelay;
+	uint8	Reserved2[7];
+	uint16	MediumRotationRate;
+	uint8	Reserved3;
+	uint8	Reserved4;
+} PACKED FLEXIBLE_DISK_PAGE;
+
+/******************* AMI Scsi Request/ResponsePacket ************************/
+#if (1 == AMI_USB_GADGET_MODE)
+typedef struct
+{
+	uint32	ReadLen;				/* Set by Initiator*/	// Determine the data length that host expected.
+	uint8		CurrentLUN;			// Determine the current USB mass-storage LUN(logic unit number) from remote client for data responded or commands of setup.
+									// Some SCSI CDB not include lun for request, so need to assign this for remote client.
+	SCSI_COMMAND_PACKET	CommandPkt;	/* Set by Initiator*/ // SCSI CDB from host to remote client.
+	uint32	DataLen;				/* Set by Initiator and Target */ // Host: Data length to client(WRITE 6/10/12...). Remote client: Actual data length send to host for request(READ 6/10/12...).
+	uint8	Data;					/* Set by Initiator and Target */ // Data for host/remote client.
+} PACKED GADGET_SCSI_PACKET;	// Instead of IUSB_SCSI_PACKET for gadget driver.
+
+#endif	// end #if (1 == AMI_USB_GADGET_MODE)
+
+/* Values for DataDir in ScsiRequest Packet */
+#define READ_DEVICE		0x01
+#define WRITE_DEVICE	0x02
+
+
+
+
+#ifndef __GNUC__
+#pragma pack()
+#endif
+
+#endif	// end #ifndef __AMI_GADGET_IOCTL_H__
+
--- linux-5.4.85/drivers/usb/gadget/function/f_ecm.c	2021-04-15 16:08:43.125755361 +0800
+++ linux-5.4.85-new/drivers/usb/gadget/function/f_ecm.c	2021-04-22 10:28:13.263707895 +0800
@@ -91,25 +91,12 @@
  * encapsulated commands (vendor-specific, using control-OUT).
  */
 
-#define ECM_STATUS_INTERVAL_MS		32
-#define ECM_STATUS_BYTECOUNT		16	/* 8 byte header + data */
+#define ECM_STATUS_INTERVAL		1
+#define ECM_STATUS_BYTECOUNT		1024	/* 8 byte header + data */
 
 
 /* interface descriptor: */
 
-static struct usb_interface_assoc_descriptor
-ecm_iad_descriptor = {
-	.bLength =		sizeof ecm_iad_descriptor,
-	.bDescriptorType =	USB_DT_INTERFACE_ASSOCIATION,
-
-	/* .bFirstInterface =	DYNAMIC, */
-	.bInterfaceCount =	2,	/* control + data */
-	.bFunctionClass =	USB_CLASS_COMM,
-	.bFunctionSubClass =	USB_CDC_SUBCLASS_ETHERNET,
-	.bFunctionProtocol =	USB_CDC_PROTO_NONE,
-	/* .iFunction =		DYNAMIC */
-};
-
 
 static struct usb_interface_descriptor ecm_control_intf = {
 	.bLength =		sizeof ecm_control_intf,
@@ -192,7 +179,7 @@
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
-	.bInterval =		ECM_STATUS_INTERVAL_MS,
+	.bInterval =		ECM_STATUS_INTERVAL,
 };
 
 static struct usb_endpoint_descriptor fs_ecm_in_desc = {
@@ -213,7 +200,6 @@
 
 static struct usb_descriptor_header *ecm_fs_function[] = {
 	/* CDC ECM control descriptors */
-	(struct usb_descriptor_header *) &ecm_iad_descriptor,
 	(struct usb_descriptor_header *) &ecm_control_intf,
 	(struct usb_descriptor_header *) &ecm_header_desc,
 	(struct usb_descriptor_header *) &ecm_union_desc,
@@ -225,8 +211,8 @@
 	/* data interface, altsettings 0 and 1 */
 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
 	(struct usb_descriptor_header *) &ecm_data_intf,
-	(struct usb_descriptor_header *) &fs_ecm_in_desc,
 	(struct usb_descriptor_header *) &fs_ecm_out_desc,
+	(struct usb_descriptor_header *) &fs_ecm_in_desc,
 	NULL,
 };
 
@@ -239,7 +225,7 @@
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
-	.bInterval =		USB_MS_TO_HS_INTERVAL(ECM_STATUS_INTERVAL_MS),
+	.bInterval =		ECM_STATUS_INTERVAL,
 };
 
 static struct usb_endpoint_descriptor hs_ecm_in_desc = {
@@ -262,7 +248,6 @@
 
 static struct usb_descriptor_header *ecm_hs_function[] = {
 	/* CDC ECM control descriptors */
-	(struct usb_descriptor_header *) &ecm_iad_descriptor,
 	(struct usb_descriptor_header *) &ecm_control_intf,
 	(struct usb_descriptor_header *) &ecm_header_desc,
 	(struct usb_descriptor_header *) &ecm_union_desc,
@@ -274,8 +259,9 @@
 	/* data interface, altsettings 0 and 1 */
 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
 	(struct usb_descriptor_header *) &ecm_data_intf,
-	(struct usb_descriptor_header *) &hs_ecm_in_desc,
 	(struct usb_descriptor_header *) &hs_ecm_out_desc,
+	(struct usb_descriptor_header *) &hs_ecm_in_desc,
+
 	NULL,
 };
 
@@ -288,7 +274,7 @@
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	cpu_to_le16(ECM_STATUS_BYTECOUNT),
-	.bInterval =		USB_MS_TO_HS_INTERVAL(ECM_STATUS_INTERVAL_MS),
+	.bInterval =		ECM_STATUS_INTERVAL,
 };
 
 static struct usb_ss_ep_comp_descriptor ss_ecm_intr_comp_desc = {
@@ -330,7 +316,6 @@
 
 static struct usb_descriptor_header *ecm_ss_function[] = {
 	/* CDC ECM control descriptors */
-	(struct usb_descriptor_header *) &ecm_iad_descriptor,
 	(struct usb_descriptor_header *) &ecm_control_intf,
 	(struct usb_descriptor_header *) &ecm_header_desc,
 	(struct usb_descriptor_header *) &ecm_union_desc,
@@ -343,19 +328,19 @@
 	/* data interface, altsettings 0 and 1 */
 	(struct usb_descriptor_header *) &ecm_data_nop_intf,
 	(struct usb_descriptor_header *) &ecm_data_intf,
-	(struct usb_descriptor_header *) &ss_ecm_in_desc,
-	(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,
 	(struct usb_descriptor_header *) &ss_ecm_out_desc,
 	(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,
+	(struct usb_descriptor_header *) &ss_ecm_in_desc,
+	(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,
 	NULL,
 };
 
 /* string descriptors: */
 
 static struct usb_string ecm_string_defs[] = {
-	[0].s = "CDC Ethernet Control Model (ECM)",
+	[0].s = "CDC Notification Interface",
 	[1].s = "",
-	[2].s = "CDC Ethernet Data",
+	[2].s = "CDC Data Interface",
 	[3].s = "CDC ECM",
 	{  } /* end of list */
 };
@@ -721,14 +706,14 @@
 	ecm_control_intf.iInterface = us[0].id;
 	ecm_data_intf.iInterface = us[2].id;
 	ecm_desc.iMACAddress = us[1].id;
-	ecm_iad_descriptor.iFunction = us[3].id;
+
 
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
 	ecm->ctrl_id = status;
-	ecm_iad_descriptor.bFirstInterface = status;
+
 
 	ecm_control_intf.bInterfaceNumber = status;
 	ecm_union_desc.bMasterInterface0 = status;
@@ -745,24 +730,24 @@
 	status = -ENODEV;
 
 	/* allocate instance-specific endpoints */
-	ep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_in_desc);
+	/* NOTE:  a status/notification endpoint is *OPTIONAL* but we
+	 * don't treat it that way.  It's simpler, and some newer CDC
+	 * profiles (wireless handsets) no longer treat it as optional.
+	 */
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_notify_desc);
 	if (!ep)
 		goto fail;
-	ecm->port.in_ep = ep;
+	ecm->notify = ep;
 
 	ep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_out_desc);
 	if (!ep)
 		goto fail;
 	ecm->port.out_ep = ep;
 
-	/* NOTE:  a status/notification endpoint is *OPTIONAL* but we
-	 * don't treat it that way.  It's simpler, and some newer CDC
-	 * profiles (wireless handsets) no longer treat it as optional.
-	 */
-	ep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_notify_desc);
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_in_desc);
 	if (!ep)
 		goto fail;
-	ecm->notify = ep;
+	ecm->port.in_ep = ep;
 
 	status = -ENOMEM;
 
--- linux-5.4.85/drivers/usb/gadget/function/f_rndis.c	2021-04-15 16:08:43.257752707 +0800
+++ linux-5.4.85-new/drivers/usb/gadget/function/f_rndis.c	2021-04-22 10:36:48.904114074 +0800
@@ -69,7 +69,7 @@
 struct f_rndis {
 	struct gether			port;
 	u8				ctrl_id, data_id;
-	u8				ethaddr[ETH_ALEN];
+	u8				ethaddr[14];
 	u32				vendorID;
 	const char			*manufacturer;
 	struct rndis_params		*params;
@@ -100,8 +100,8 @@
 /*
  */
 
-#define RNDIS_STATUS_INTERVAL_MS	32
-#define STATUS_BYTECOUNT		8	/* 8 bytes data */
+#define RNDIS_STATUS_INTERVAL			1
+#define STATUS_BYTECOUNT			1024	/* 1024 bytes data */
 
 
 /* interface descriptor: */
@@ -116,7 +116,7 @@
 	.bInterfaceClass =	USB_CLASS_COMM,
 	.bInterfaceSubClass =   USB_CDC_SUBCLASS_ACM,
 	.bInterfaceProtocol =   USB_CDC_ACM_PROTO_VENDOR,
-	/* .iInterface = DYNAMIC */
+    .iInterface = 		0x04,
 };
 
 static struct usb_cdc_header_desc header_desc = {
@@ -148,8 +148,21 @@
 	.bLength =		sizeof(rndis_union_desc),
 	.bDescriptorType =	USB_DT_CS_INTERFACE,
 	.bDescriptorSubType =	USB_CDC_UNION_TYPE,
-	/* .bMasterInterface0 =	DYNAMIC */
-	/* .bSlaveInterface0 =	DYNAMIC */
+	.bMasterInterface0 =	0x00,
+	.bSlaveInterface0 =	0x01,
+};
+
+static struct usb_cdc_ether_desc ecm_desc = {
+	.bLength =		sizeof ecm_desc,
+	.bDescriptorType =	USB_DT_CS_INTERFACE,
+	.bDescriptorSubType =	USB_CDC_ETHERNET_TYPE,
+
+	/* this descriptor actually adds value, surprise! */
+	.iMACAddress = 0x05,
+	.bmEthernetStatistics =	cpu_to_le32(0), /* no statistics */
+	.wMaxSegmentSize =	cpu_to_le16(ETH_FRAME_LEN),
+	.wNumberMCFilters =	cpu_to_le16(0),
+	.bNumberPowerFilters =	0,
 };
 
 /* the data interface has two bulk endpoints */
@@ -163,22 +176,11 @@
 	.bInterfaceClass =	USB_CLASS_CDC_DATA,
 	.bInterfaceSubClass =	0,
 	.bInterfaceProtocol =	0,
-	/* .iInterface = DYNAMIC */
+	.iInterface = 		0x06,
 };
 
 
-static struct usb_interface_assoc_descriptor
-rndis_iad_descriptor = {
-	.bLength =		sizeof rndis_iad_descriptor,
-	.bDescriptorType =	USB_DT_INTERFACE_ASSOCIATION,
 
-	.bFirstInterface =	0, /* XXX, hardcoded */
-	.bInterfaceCount = 	2,	// control + data
-	.bFunctionClass =	USB_CLASS_COMM,
-	.bFunctionSubClass =	USB_CDC_SUBCLASS_ETHERNET,
-	.bFunctionProtocol =	USB_CDC_PROTO_NONE,
-	/* .iFunction = DYNAMIC */
-};
 
 /* full speed support: */
 
@@ -189,7 +191,7 @@
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	cpu_to_le16(STATUS_BYTECOUNT),
-	.bInterval =		RNDIS_STATUS_INTERVAL_MS,
+	.bInterval =		RNDIS_STATUS_INTERVAL,
 };
 
 static struct usb_endpoint_descriptor fs_in_desc = {
@@ -209,7 +211,6 @@
 };
 
 static struct usb_descriptor_header *eth_fs_function[] = {
-	(struct usb_descriptor_header *) &rndis_iad_descriptor,
 
 	/* control interface matches ACM, not Ethernet */
 	(struct usb_descriptor_header *) &rndis_control_intf,
@@ -217,12 +218,13 @@
 	(struct usb_descriptor_header *) &call_mgmt_descriptor,
 	(struct usb_descriptor_header *) &rndis_acm_descriptor,
 	(struct usb_descriptor_header *) &rndis_union_desc,
+	(struct usb_descriptor_header *) &ecm_desc,	
 	(struct usb_descriptor_header *) &fs_notify_desc,
 
 	/* data interface has no altsetting */
 	(struct usb_descriptor_header *) &rndis_data_intf,
-	(struct usb_descriptor_header *) &fs_in_desc,
 	(struct usb_descriptor_header *) &fs_out_desc,
+	(struct usb_descriptor_header *) &fs_in_desc,
 	NULL,
 };
 
@@ -235,7 +237,7 @@
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	cpu_to_le16(STATUS_BYTECOUNT),
-	.bInterval =		USB_MS_TO_HS_INTERVAL(RNDIS_STATUS_INTERVAL_MS)
+	.bInterval =		RNDIS_STATUS_INTERVAL,
 };
 
 static struct usb_endpoint_descriptor hs_in_desc = {
@@ -257,7 +259,6 @@
 };
 
 static struct usb_descriptor_header *eth_hs_function[] = {
-	(struct usb_descriptor_header *) &rndis_iad_descriptor,
 
 	/* control interface matches ACM, not Ethernet */
 	(struct usb_descriptor_header *) &rndis_control_intf,
@@ -265,12 +266,14 @@
 	(struct usb_descriptor_header *) &call_mgmt_descriptor,
 	(struct usb_descriptor_header *) &rndis_acm_descriptor,
 	(struct usb_descriptor_header *) &rndis_union_desc,
+	(struct usb_descriptor_header *) &ecm_desc,
+
 	(struct usb_descriptor_header *) &hs_notify_desc,
 
 	/* data interface has no altsetting */
 	(struct usb_descriptor_header *) &rndis_data_intf,
-	(struct usb_descriptor_header *) &hs_in_desc,
 	(struct usb_descriptor_header *) &hs_out_desc,
+	(struct usb_descriptor_header *) &hs_in_desc,
 	NULL,
 };
 
@@ -283,7 +286,7 @@
 	.bEndpointAddress =	USB_DIR_IN,
 	.bmAttributes =		USB_ENDPOINT_XFER_INT,
 	.wMaxPacketSize =	cpu_to_le16(STATUS_BYTECOUNT),
-	.bInterval =		USB_MS_TO_HS_INTERVAL(RNDIS_STATUS_INTERVAL_MS)
+	.bInterval =		RNDIS_STATUS_INTERVAL,
 };
 
 static struct usb_ss_ep_comp_descriptor ss_intr_comp_desc = {
@@ -324,7 +327,6 @@
 };
 
 static struct usb_descriptor_header *eth_ss_function[] = {
-	(struct usb_descriptor_header *) &rndis_iad_descriptor,
 
 	/* control interface matches ACM, not Ethernet */
 	(struct usb_descriptor_header *) &rndis_control_intf,
@@ -332,24 +334,26 @@
 	(struct usb_descriptor_header *) &call_mgmt_descriptor,
 	(struct usb_descriptor_header *) &rndis_acm_descriptor,
 	(struct usb_descriptor_header *) &rndis_union_desc,
+	(struct usb_descriptor_header *) &ecm_desc,
 	(struct usb_descriptor_header *) &ss_notify_desc,
 	(struct usb_descriptor_header *) &ss_intr_comp_desc,
 
 	/* data interface has no altsetting */
 	(struct usb_descriptor_header *) &rndis_data_intf,
-	(struct usb_descriptor_header *) &ss_in_desc,
-	(struct usb_descriptor_header *) &ss_bulk_comp_desc,
 	(struct usb_descriptor_header *) &ss_out_desc,
 	(struct usb_descriptor_header *) &ss_bulk_comp_desc,
+	(struct usb_descriptor_header *) &ss_in_desc,
+	(struct usb_descriptor_header *) &ss_bulk_comp_desc,
 	NULL,
 };
 
 /* string descriptors: */
 
 static struct usb_string rndis_string_defs[] = {
-	[0].s = "RNDIS Communications Control",
-	[1].s = "RNDIS Ethernet Data",
-	[2].s = "RNDIS",
+	[0].s = "",
+	[1].s = "RNDIS Notification Interface.",
+	[2].s = "RNDIS Data Interface.",
+	[3].s = "RNDIS",
 	{  } /* end of list */
 };
 
@@ -398,7 +402,7 @@
 	 */
 	data[0] = cpu_to_le32(1);
 	data[1] = cpu_to_le32(0);
-
+	req->length = 8;
 	status = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);
 	if (status) {
 		atomic_dec(&rndis->notify_count);
@@ -679,6 +683,10 @@
 
 	rndis_opts = container_of(f->fi, struct f_rndis_opts, func_inst);
 
+	if(rndis_opts->borrowed_net) {
+		//reset port
+		rndis->port.ioport = netdev_priv(rndis_opts->net);
+	}
 	if (cdev->use_os_string) {
 		f->os_desc_table = kzalloc(sizeof(*f->os_desc_table),
 					   GFP_KERNEL);
@@ -688,10 +696,6 @@
 		f->os_desc_table[0].os_desc = &rndis_opts->rndis_os_desc;
 	}
 
-	rndis_iad_descriptor.bFunctionClass = rndis_opts->class;
-	rndis_iad_descriptor.bFunctionSubClass = rndis_opts->subclass;
-	rndis_iad_descriptor.bFunctionProtocol = rndis_opts->protocol;
-
 	/*
 	 * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
 	 * configurations are bound in sequence with list_for_each_entry,
@@ -706,31 +710,33 @@
 			goto fail;
 		rndis_opts->bound = true;
 	}
-
+	status = gether_get_host_addr_cdc(rndis_opts->net, rndis->ethaddr,
+					  sizeof(rndis->ethaddr));
+	if (status < 12) {
+		kfree(rndis);
+		return ERR_PTR(-EINVAL);
+	}
+	rndis_string_defs[0].s = rndis->ethaddr;
 	us = usb_gstrings_attach(cdev, rndis_strings,
 				 ARRAY_SIZE(rndis_string_defs));
 	if (IS_ERR(us)) {
 		status = PTR_ERR(us);
 		goto fail;
 	}
-	rndis_control_intf.iInterface = us[0].id;
-	rndis_data_intf.iInterface = us[1].id;
-	rndis_iad_descriptor.iFunction = us[2].id;
+	ecm_desc.iMACAddress = us[0].id;
+	rndis_control_intf.iInterface = us[1].id;
+	rndis_data_intf.iInterface = us[2].id;
 
 	/* allocate instance-specific interface IDs */
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
 	rndis->ctrl_id = status;
-	rndis_iad_descriptor.bFirstInterface = status;
+
 
 	rndis_control_intf.bInterfaceNumber = status;
 	rndis_union_desc.bMasterInterface0 = status;
 
-	if (cdev->use_os_string)
-		f->os_desc_table[0].if_id =
-			rndis_iad_descriptor.bFirstInterface;
-
 	status = usb_interface_id(c, f);
 	if (status < 0)
 		goto fail;
@@ -742,24 +748,24 @@
 	status = -ENODEV;
 
 	/* allocate instance-specific endpoints */
-	ep = usb_ep_autoconfig(cdev->gadget, &fs_in_desc);
+	/* NOTE:  a status/notification endpoint is, strictly speaking,
+	 * optional.  We don't treat it that way though!  It's simpler,
+	 * and some newer profiles don't treat it as optional.
+	 */
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_notify_desc);
 	if (!ep)
 		goto fail;
-	rndis->port.in_ep = ep;
+	rndis->notify = ep;
 
 	ep = usb_ep_autoconfig(cdev->gadget, &fs_out_desc);
 	if (!ep)
 		goto fail;
 	rndis->port.out_ep = ep;
 
-	/* NOTE:  a status/notification endpoint is, strictly speaking,
-	 * optional.  We don't treat it that way though!  It's simpler,
-	 * and some newer profiles don't treat it as optional.
-	 */
-	ep = usb_ep_autoconfig(cdev->gadget, &fs_notify_desc);
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_in_desc);
 	if (!ep)
 		goto fail;
-	rndis->notify = ep;
+	rndis->port.in_ep = ep;
 
 	status = -ENOMEM;
 
@@ -931,9 +937,7 @@
 	}
 	INIT_LIST_HEAD(&opts->rndis_os_desc.ext_prop);
 
-	opts->class = rndis_iad_descriptor.bFunctionClass;
-	opts->subclass = rndis_iad_descriptor.bFunctionSubClass;
-	opts->protocol = rndis_iad_descriptor.bFunctionProtocol;
+
 
 	descs[0] = &opts->rndis_os_desc;
 	names[0] = "rndis";
--- linux-5.4.85/drivers/usb/gadget/function/rndis.c	2021-04-15 16:08:43.565746516 +0800
+++ linux-5.4.85-new/drivers/usb/gadget/function/rndis.c	2021-04-22 10:38:06.494367826 +0800
@@ -815,11 +815,11 @@
 	case RNDIS_MSG_HALT:
 		pr_debug("%s: RNDIS_MSG_HALT\n",
 			__func__);
-		params->state = RNDIS_UNINITIALIZED;
+		/*params->state = RNDIS_UNINITIALIZED;
 		if (params->dev) {
 			netif_carrier_off(params->dev);
 			netif_stop_queue(params->dev);
-		}
+		}*/
 		return 0;
 
 	case RNDIS_MSG_QUERY:
--- linux-5.4.251/drivers/usb/gadget/function/f_hid.c	2023-07-27 14:37:45.000000000 +0800
+++ linux-new/drivers/usb/gadget/function/f_hid.c	2023-08-15 17:10:24.487603736 +0800
@@ -20,12 +20,16 @@
 #include "u_f.h"
 #include "u_hid.h"
 
+#include "ami_gadget_ioctl.h"
 #define HIDG_MINORS	4
 
 static int major, minors;
 static struct class *hidg_class;
 static DEFINE_IDA(hidg_ida);
 static DEFINE_MUTEX(hidg_ida_lock); /* protects access to hidg_ida */
+static HID_PACKET hid_data;
+static unsigned char UsbHIDActive = 0;
+static unsigned char DataReceived = 0;
 
 /*-------------------------------------------------------------------------*/
 /*                            HID gadget struct                            */
@@ -280,138 +284,16 @@
 	&ct_func_string_table,
 	NULL,
 };
-
-/*-------------------------------------------------------------------------*/
-/*                              Char Device                                */
-
-static ssize_t f_hidg_intout_read(struct file *file, char __user *buffer,
-				  size_t count, loff_t *ptr)
+static int FillLedPacket(int Data)
 {
-	struct f_hidg *hidg = file->private_data;
-	struct f_hidg_req_list *list;
-	struct usb_request *req;
-	unsigned long flags;
-	int ret;
-
-	if (!count)
-		return 0;
-
-	if (!access_ok(buffer, count))
-		return -EFAULT;
-
-	spin_lock_irqsave(&hidg->read_spinlock, flags);
-
-#define READ_COND_INTOUT (!list_empty(&hidg->completed_out_req))
-
-	/* wait for at least one buffer to complete */
-	while (!READ_COND_INTOUT) {
-		spin_unlock_irqrestore(&hidg->read_spinlock, flags);
-		if (file->f_flags & O_NONBLOCK)
-			return -EAGAIN;
-
-		if (wait_event_interruptible(hidg->read_queue, READ_COND_INTOUT))
-			return -ERESTARTSYS;
-
-		spin_lock_irqsave(&hidg->read_spinlock, flags);
-	}
-
-	/* pick the first one */
-	list = list_first_entry(&hidg->completed_out_req,
-				struct f_hidg_req_list, list);
-
-	/*
-	 * Remove this from list to protect it from beign free()
-	 * while host disables our function
-	 */
-	list_del(&list->list);
-
-	req = list->req;
-	count = min_t(unsigned int, count, req->actual - list->pos);
-	spin_unlock_irqrestore(&hidg->read_spinlock, flags);
-
-	/* copy to user outside spinlock */
-	count -= copy_to_user(buffer, req->buf + list->pos, count);
-	list->pos += count;
-
-	/*
-	 * if this request is completely handled and transfered to
-	 * userspace, remove its entry from the list and requeue it
-	 * again. Otherwise, we will revisit it again upon the next
-	 * call, taking into account its current read position.
-	 */
-	if (list->pos == req->actual) {
-		kfree(list);
-
-		req->length = hidg->report_length;
-		ret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);
-		if (ret < 0) {
-			free_ep_req(hidg->out_ep, req);
-			return ret;
-		}
-	} else {
-		spin_lock_irqsave(&hidg->read_spinlock, flags);
-		list_add(&list->list, &hidg->completed_out_req);
-		spin_unlock_irqrestore(&hidg->read_spinlock, flags);
-
-		wake_up(&hidg->read_queue);
-	}
-
-	return count;
-}
-
-#define READ_COND_SSREPORT (hidg->set_report_buf != NULL)
-
-static ssize_t f_hidg_ssreport_read(struct file *file, char __user *buffer,
-				    size_t count, loff_t *ptr)
-{
-	struct f_hidg *hidg = file->private_data;
-	char *tmp_buf = NULL;
-	unsigned long flags;
-
-	if (!count)
-		return 0;
-
-	spin_lock_irqsave(&hidg->read_spinlock, flags);
-
-	while (!READ_COND_SSREPORT) {
-		spin_unlock_irqrestore(&hidg->read_spinlock, flags);
-		if (file->f_flags & O_NONBLOCK)
-			return -EAGAIN;
-
-		if (wait_event_interruptible(hidg->read_queue, READ_COND_SSREPORT))
-			return -ERESTARTSYS;
-
-		spin_lock_irqsave(&hidg->read_spinlock, flags);
-	}
-
-	count = min_t(unsigned int, count, hidg->set_report_length);
-	tmp_buf = hidg->set_report_buf;
-	hidg->set_report_buf = NULL;
-
-	spin_unlock_irqrestore(&hidg->read_spinlock, flags);
-
-	if (tmp_buf != NULL) {
-		count -= copy_to_user(buffer, tmp_buf, count);
-		kfree(tmp_buf);
-	} else {
-		count = -ENOMEM;
-	}
-
-	wake_up(&hidg->read_queue);
-
-	return count;
+	hid_data.DataLen = 1;
+	hid_data.Data = (uint8)Data;
+	DataReceived = 1;
+	return 1;
 }
 
-static ssize_t f_hidg_read(struct file *file, char __user *buffer,
-			   size_t count, loff_t *ptr)
-{
-	struct f_hidg *hidg = file->private_data;
-
-	if (hidg->use_out_ep)
-		return f_hidg_intout_read(file, buffer, count, ptr);
-	else
-		return f_hidg_ssreport_read(file, buffer, count, ptr);
-}
+/*-------------------------------------------------------------------------*/
+/*                              Char Device                                */
 
 static void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)
 {
@@ -433,6 +315,7 @@
 			    size_t count, loff_t *offp)
 {
 	struct f_hidg *hidg  = file->private_data;
+	struct usb_composite_dev *cdev = hidg->func.config->cdev;
 	struct usb_request *req;
 	unsigned long flags;
 	ssize_t status = -ENOMEM;
@@ -440,6 +323,7 @@
 	if (!access_ok(buffer, count))
 		return -EFAULT;
 
+	usb_gadget_wakeup(cdev->gadget);
 	spin_lock_irqsave(&hidg->write_spinlock, flags);
 
 	if (!hidg->req) {
@@ -454,10 +338,20 @@
 		spin_unlock_irqrestore(&hidg->write_spinlock, flags);
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
-
+		
+		/*
+		//Due to retry send data will be locked when write queue will busy or write failed.
+		//Modify to interruptible timeout and setup 5ms for daemon process needs.
 		if (wait_event_interruptible_exclusive(
 				hidg->write_queue, WRITE_COND))
 			return -ERESTARTSYS;
+		*/
+		status = wait_event_interruptible_timeout(hidg->write_queue, WRITE_COND,5);
+		if(status == 0) {
+			return -EAGAIN;
+		} else if (status == -ERESTARTSYS) {
+			return -ERESTARTSYS;
+		}
 
 		spin_lock_irqsave(&hidg->write_spinlock, flags);
 	}
@@ -525,6 +419,95 @@
 	return status;
 }
 
+// ref to ffs_ep0_ioctl, dev_ioctl, printer_ioctl.
+static long ami_f_hid_ioctl(struct file *fd, unsigned int code, unsigned long arg)
+{
+	struct f_hidg *hidg = fd->private_data;
+	int			status = 0;
+	struct f_hidg_req_list *list;
+	struct usb_request *req;
+	unsigned long flags;
+	int ret,count = 1;
+	
+	/* handle ioctls */
+
+	/* TODO */
+	switch (code) {
+		case USB_KEYBD_LED:
+			spin_lock_irqsave(&hidg->read_spinlock, flags);
+			if (fd->f_flags & O_NONBLOCK)
+				return -EAGAIN;
+		#define READ_COND (!list_empty(&hidg->completed_out_req))
+			/* wait for at least one buffer to complete */
+			while (!READ_COND) {
+				spin_unlock_irqrestore(&hidg->read_spinlock, flags);
+				if (wait_event_interruptible(hidg->read_queue, READ_COND))
+					return -ERESTARTSYS;
+				spin_lock_irqsave(&hidg->read_spinlock, flags);
+			}
+
+			/* pick the first one */
+			list = list_first_entry(&hidg->completed_out_req,
+						struct f_hidg_req_list, list);
+
+			/*
+			 * Remove this from list to protect it from beign free()
+			 * while host disables our function
+			 */
+			list_del(&list->list);
+
+			req = list->req;
+			count = min_t(unsigned int, count, req->actual - list->pos);
+			spin_unlock_irqrestore(&hidg->read_spinlock, flags);
+			FillLedPacket(* (int *)req->buf + list->pos);
+
+			/* copy to user outside spinlock */
+			count -= copy_to_user((void __user *)arg, req->buf + list->pos, count);
+			list->pos += count;
+
+			/*
+			 * if this request is completely handled and transfered to
+			 * userspace, remove its entry from the list and requeue it
+			 * again. Otherwise, we will revisit it again upon the next
+			 * call, taking into account its current read position.
+			 */
+
+			if (list->pos == req->actual) {
+				kfree(list);
+
+				req->length = hidg->report_length;
+				ret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);
+				if (ret < 0) {
+					free_ep_req(hidg->out_ep, req);
+					return -1;
+				}
+			} else {
+				spin_lock_irqsave(&hidg->read_spinlock, flags);
+				list_add(&list->list, &hidg->completed_out_req);
+				spin_unlock_irqrestore(&hidg->read_spinlock, flags);
+				wake_up(&hidg->read_queue);
+			}
+			break;
+
+		case USB_KEYBD_LED_NO_WAIT:
+			if(DataReceived == 0) {
+				return -1;
+			} else {
+				status = copy_to_user((void __user *)arg, &hid_data.Data, sizeof(hid_data.Data));
+			}
+			break;
+		case USB_KEYBD_LED_RESET:	
+			hid_data.Data = 0;
+			hid_data.DataLen = 0;
+			break;
+
+		default:
+			/* could not handle ioctl */
+			status = -ENOTTY;
+	}
+
+	return status;
+}
 static __poll_t f_hidg_poll(struct file *file, poll_table *wait)
 {
 	struct f_hidg	*hidg  = file->private_data;
@@ -536,13 +519,8 @@
 	if (WRITE_COND)
 		ret |= EPOLLOUT | EPOLLWRNORM;
 
-	if (hidg->use_out_ep) {
-		if (READ_COND_INTOUT)
-			ret |= EPOLLIN | EPOLLRDNORM;
-	} else {
-		if (READ_COND_SSREPORT)
-			ret |= EPOLLIN | EPOLLRDNORM;
-	}
+	if (READ_COND)
+		ret |= EPOLLIN | EPOLLRDNORM;
 
 	return ret;
 }
@@ -650,7 +633,8 @@
 	struct usb_request		*req  = cdev->req;
 	int status = 0;
 	__u16 value, length;
-
+	
+	UsbHIDActive = 1;
 	value	= __le16_to_cpu(ctrl->wValue);
 	length	= __le16_to_cpu(ctrl->wLength);
 
@@ -908,9 +892,9 @@
 	.open		= f_hidg_open,
 	.release	= f_hidg_release,
 	.write		= f_hidg_write,
-	.read		= f_hidg_read,
 	.poll		= f_hidg_poll,
 	.llseek		= noop_llseek,
+	.unlocked_ioctl = ami_f_hid_ioctl	// TODO....
 };
 
 static int hidg_bind(struct usb_configuration *c, struct usb_function *f)
@@ -1261,6 +1245,19 @@
 	usb_free_all_descriptors(f);
 }
 
+static void hidg_resume(struct usb_function *f)
+{
+	UsbHIDActive = 1;
+}
+
+static void hidg_suspend(struct usb_function *f)
+{
+	//clear hid data
+	hid_data.Data = 0;
+	hid_data.DataLen = 0;
+	UsbHIDActive = 0;
+}
+
 static struct usb_function *hidg_alloc(struct usb_function_instance *fi)
 {
 	struct f_hidg *hidg;
@@ -1314,6 +1311,8 @@
 	hidg->func.disable = hidg_disable;
 	hidg->func.setup   = hidg_setup;
 	hidg->func.free_func = hidg_free;
+	hidg->func.resume = hidg_resume;
+	hidg->func.suspend = hidg_suspend;
 
 	/* this could me made configurable at some point */
 	hidg->qlen	   = 4;
--- linux-5.4.85/drivers/usb/gadget/function/storage_common.c	2021-04-15 16:08:43.569746436 +0800
+++ linux-5.4.85-new/drivers/usb/gadget/function/storage_common.c	2021-04-22 10:44:29.433745805 +0800
@@ -241,15 +241,7 @@
 
 	num_sectors = size >> blkbits; /* File size in logic-block-size blocks */
 	min_sectors = 1;
-	if (curlun->cdrom) {
-		min_sectors = 300;	/* Smallest track is 300 frames */
-		if (num_sectors >= 256*60*75) {
-			num_sectors = 256*60*75 - 1;
-			LINFO(curlun, "file too big: %s\n", filename);
-			LINFO(curlun, "using only first %d blocks\n",
-					(int) num_sectors);
-		}
-	}
+
 	if (num_sectors < min_sectors) {
 		LINFO(curlun, "file too small: %s\n", filename);
 		rc = -ETOOSMALL;
--- linux-5.4.85/drivers/usb/gadget/function/f_mass_storage.c	2021-04-15 16:08:43.205753753 +0800
+++ linux-5.4.85-new/drivers/usb/gadget/function/f_mass_storage.c	2021-04-28 16:52:44.639029534 +0800
@@ -316,6 +316,42 @@
 	char inquiry_string[INQUIRY_STRING_LEN];
 };
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+#define MAX_AMI_USB_PKT_BUF	(sizeof(GADGET_SCSI_PACKET) + MAX_SCSI_DATA)
+
+typedef struct AMI_GADGET_EVENT_STATUS_PRIV{
+	uint8	MediaEventCode;
+	uint8	MediaStatus;
+	uint8	additional_media_eject;		// For media unload request from remote that cannot handle via media event status(e.g. hard disk drive or ALL AMI mass-storage on Windows Host) with SCSI command: START_STOP.
+										// value: MEDIA_EVENT_ID_NO_EVENT, MEDIA_EVENT_ID_EJECT_REQUEST.
+} PACKED AMI_GADGET_EVENT_STATUS_PRIV;
+
+typedef struct AMI_GADGET_PRIV {
+	// private data for each lun of mass storage.
+	// u8 redirect_mode: Indicate the redirect_mode;
+	// 0: file-backed mode(handle SCSI command via origin gadget functions).
+	// 1: virtual device mode(bypass SCSI command to remote client).
+	// u8 redirect_mode;
+	uint8 *usb_pkt_res;
+	AMI_GADGET_EVENT_STATUS_PRIV media_event_status;	// For SCSI command: 0x4A(GET EVENT/STATUS NOTIFICATION) response.
+	// u8 test;
+} PACKED AMI_GADGET_PRIV;
+
+enum gadget_mass_storage_node_type_id {
+	// Indicated the type and usage(HD/CD) of device node for current mass-storage gadget.
+	// Base on the attribute of lun: cdrom. 0: HD, 1: CD. 
+	GADGET_MASS_STORAGE_NODE_TYPE_ID_HD = 0,	// HDD
+	GADGET_MASS_STORAGE_NODE_TYPE_ID_CD = 1,	// CD-ROM
+	GADGET_MASS_STORAGE_NODE_TYPE_ID_MAX = 2,
+	GADGET_MASS_STORAGE_NODE_TYPE_ID_INVALID = 2,
+};
+
+#define MAX_AMI_LUNS				(4)	// as max ami luns supported for cd and hd.
+#define KERNEL_WAIT_TIMEOUT			(5*HZ)	// the time for kernel to wait remote response. default: 5 seconds in jiffies with wait_event_interruptible_timeout.
+#define MAX_AMI_VENDOR_USB_LUNS		(1)	// "ONLY ONE instance" for IPMI USB between kernel fsg thread with its' device node...
+
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
 struct fsg_dev {
 	struct usb_function	function;
 	struct usb_gadget	*gadget;	/* Copy of cdev->gadget */
@@ -331,8 +367,36 @@
 
 	struct usb_ep		*bulk_in;
 	struct usb_ep		*bulk_out;
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	int				minor;	// Store the corresponding device minor number.
+	u8				node_type;	// Indicated the type and usage(HD/CD) of device node. 0: HD, 1: CD. Base on the attribute of lun: cdrom.
+	struct cdev			cdev;	// For creating device node. not same as "struct usb_composite_dev *cdev";
+	spinlock_t		lock;		/* lock this structure */
+	AMI_GADGET_PRIV	ami_gadget_priv[MAX_AMI_LUNS];
+	u8			mass_storage_status;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 };
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+#define MSG_CLASS_NAME				"msg"	// a class under /sys/class/, for short of "Mass Storage Gadget"...
+#define MSG_NODE_NAME_PREFIX		"usb"	// device node name.
+#define MSG_MINORS					(2)	// minors indicates the maxium number of device node that allow to create under /dev/.
+										// One node is for CD, and the other one is for HD
+static int major, minors;
+static struct class *msg_class;	// a class for mass storage gadget.
+static DEFINE_IDA(msg_ida);
+static DEFINE_MUTEX(msg_ida_lock); /* protects access to msg_ida */
+void gmsg_ami_init_device(struct fsg_dev *fsg, const unsigned int node_type_id);
+static uint8 cd_usb_hw_res_pkt[MAX_AMI_LUNS][MAX_AMI_USB_PKT_BUF];
+static uint8 hd_usb_hw_res_pkt[MAX_AMI_LUNS][MAX_AMI_USB_PKT_BUF];
+int ami_do_cmnd_to_ami_scsi_protocol(const struct fsg_common *common, GADGET_SCSI_PACKET *pReqPkt);
+
+static int ami_event_notification_kernel_cd_load(struct fsg_dev *fsg, const unsigned int Instance);
+static int ami_event_notification_kernel_hd_load(struct fsg_dev *fsg, const unsigned int Instance);
+static int ami_kernel_medium_unload(struct fsg_dev *fsg, const unsigned int Instance);	// Unload the medium from kernel for remote cd/hd exit, cause of no scsi command help to eject CD/HD from remote side if the host OS is Windows.
+
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
 static inline int __fsg_is_set(struct fsg_common *common,
 			       const char *func, unsigned line)
 {
@@ -1084,7 +1148,7 @@
 	else
 		memcpy(buf + 8, common->inquiry_string,
 		       sizeof(common->inquiry_string));
-	return 36;
+	return common->data_size_from_cmnd;// send more as host required, CANNOT hard code with 36, once EVPD is 1.// 36;
 }
 
 static int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)
@@ -1793,6 +1857,93 @@
 			mask, needs_medium, name);
 }
 
+static int ami_do_get_event_status_notification(struct fsg_common *common, struct fsg_buffhd *bh)
+{	// SCSI command: 0X4A(GET EVENT STATUS NOTIFICATION).
+	u8 *buf = (u8 *) bh->buf;
+	int instance = 0;
+	GADGET_SCSI_PACKET *pResPkt = NULL;
+	uint8_t *pResData;
+	int len;
+	AMI_GADGET_PRIV *pAMI_gadget_priv;
+	AMI_GADGET_EVENT_STATUS_PRIV *pAMI_media_event_status_priv;
+	SCSI_GET_EVENT_STATUS_NOTIFICATION_PACKET *pResMediaEventStatus;
+	uint8 MediaEventCode;
+	uint8 MediaStatus;
+
+	if (MAX_AMI_LUNS <= common->lun)
+	{
+		printk("LUN %d ami_do_get_event_status_notification overflow\n", common->lun);
+		return -EFAULT;
+	}
+
+	instance = common->lun;
+	pAMI_gadget_priv = &common->fsg->ami_gadget_priv[instance];
+
+	/*
+	 **********************************************************************************************
+	 * Handle the commnad by kernel side. No user side waiting.
+	 * Just copy the cbw to req not res, cause of the request never send to uppler layer.
+	 **********************************************************************************************
+	 */
+
+	ami_do_cmnd_to_ami_scsi_protocol(common, (GADGET_SCSI_PACKET*)pAMI_gadget_priv->usb_pkt_res);
+
+	pAMI_media_event_status_priv = (AMI_GADGET_EVENT_STATUS_PRIV*)&pAMI_gadget_priv->media_event_status;
+
+	pResPkt = (GADGET_SCSI_PACKET*)pAMI_gadget_priv->usb_pkt_res;
+
+	pResData = (uint8_t*)&pResPkt->Data;
+
+	pResMediaEventStatus = (SCSI_GET_EVENT_STATUS_NOTIFICATION_PACKET*)pResData;
+
+	MediaEventCode = pAMI_media_event_status_priv->MediaEventCode;
+
+	MediaStatus = pAMI_media_event_status_priv->MediaStatus;
+
+	pResPkt->DataLen = common->data_size_from_cmnd;
+
+	len = pResPkt->DataLen;
+
+	// Filling response data of event status.
+	pResMediaEventStatus->EventLength = (len - sizeof(pResMediaEventStatus->EventLength));
+	
+	pResMediaEventStatus->NotificationClass = NOTIFICATION_CLASS_ID_MEDIA;
+	
+	pResMediaEventStatus->SupportEventClass = 0xDE;
+	
+	pResMediaEventStatus->MediaEventCode = MediaEventCode;
+	
+	pResMediaEventStatus->MediaStatus = MediaStatus;
+	
+	pResMediaEventStatus->StartSlot = 0x00;
+	
+	pResMediaEventStatus->EndSlot = 0x00;
+
+#if(0)	// DEBUG
+	printk("node type %d LUN %d event %02X status %02X\n", common->fsg->node_type, common->lun, MediaEventCode, MediaStatus);
+#endif
+
+	memcpy(buf, pResData, pResPkt->DataLen);
+	
+	if (0 == len)
+	{
+		printk("WARNING! LUN %d No handler ami_do_get_event_status_notification len %d \n", common->lun, len);
+	}
+
+	// Update the media status within each lun when every time command send.
+	// work as a state machine.
+	if ((MediaEventCode == MEDIA_EVENT_ID_MEDIA_REMOVAL) && (MediaStatus == 0x00)) {
+		pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_EJECT_REQUEST;
+		pAMI_media_event_status_priv->MediaStatus = MEDIA_PRESENT;
+	} else if (MediaStatus == MEDIA_PRESENT) {
+		pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_MEDIA_REMOVAL;
+		pAMI_media_event_status_priv->MediaStatus = TRAY_OPEN;
+	} else
+		pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_NO_EVENT;
+
+	return len;
+}
+
 static int do_scsi_command(struct fsg_common *common)
 {
 	struct fsg_buffhd	*bh;
@@ -1813,13 +1964,15 @@
 	common->phase_error = 0;
 	common->short_packet_received = 0;
 
+	ami_kernel_medium_unload(common->fsg, common->lun); // To unload the medium if possible for remote cd/hd exit.
+
 	down_read(&common->filesem);	/* We're using the backing file */
 	switch (common->cmnd[0]) {
 
 	case INQUIRY:
 		common->data_size_from_cmnd = common->cmnd[4];
 		reply = check_command(common, 6, DATA_DIR_TO_HOST,
-				      (1<<4), 0,
+				      (1<<1) | (1<<2) | (1<<4), 0,
 				      "INQUIRY");
 		if (reply == 0)
 			reply = do_inquiry(common, bh);
@@ -1932,7 +2085,7 @@
 		common->data_size_from_cmnd =
 			get_unaligned_be16(&common->cmnd[7]);
 		reply = check_command(common, 10, DATA_DIR_TO_HOST,
-				      (7<<6) | (1<<1), 1,
+				      (7<<6) | (1<<1) | (1 << 2), 1,
 				      "READ TOC");
 		if (reply == 0)
 			reply = do_read_toc(common, bh);
@@ -2028,6 +2181,16 @@
 			reply = do_write(common);
 		break;
 
+	case GET_EVENT_STATUS_NOTIFICATION:	// Additional for AMI SPEC.
+		common->data_size_from_cmnd =
+			get_unaligned_be16(&common->cmnd[7]);
+		reply = check_command(common, 10, DATA_DIR_TO_HOST,
+				      (1<<1) | (1<<4) | (3<<7), 0,
+				      "GET EVENT STATUS NOTIFICATION");
+		if (reply == 0)
+			reply = ami_do_get_event_status_notification(common, bh);
+		break;
+
 	/*
 	 * Some mandatory commands that we recognize but don't implement.
 	 * They don't mean much in this setting.  It's left as an exercise
@@ -2070,6 +2233,47 @@
 	return 0;
 }
 
+int ami_do_cmnd_to_ami_scsi_protocol(const struct fsg_common *common, GADGET_SCSI_PACKET *pReqPkt)
+{	// For IPMI USB, convert cdb command to AMI SCSI protocol for any redireciton mode().
+	SCSI_COMMAND_PACKET *pScsiPkt;
+	int rc = -1;
+	if (!pReqPkt)
+		return -EFAULT;
+
+	/*scsi CDB filling */
+	pScsiPkt = &pReqPkt->CommandPkt;
+	memcpy(pScsiPkt, common->cmnd, common->cmnd_size);
+	
+	/* gadget scsi packet filling */
+	if (DATA_DIR_TO_HOST == common->data_dir)
+	{	// data from remote client to host.
+		pReqPkt->ReadLen		= common->data_size;
+		pReqPkt->DataLen		= usb_long(0);
+	}
+	else
+	{	// data from host to remote client.
+		pReqPkt->ReadLen		= common->data_size;
+		if (0 == pReqPkt->ReadLen)
+		{	// dir == none.
+			// printk("TODO: no handler for dir none remote scsi, op: %02X\n", pScsiPkt->OpCode);
+		}
+		else
+		{	// dir == From HOST
+			// pReqPkt->DataLen = ???; // get the length from for each write command in do_scsi_command().
+		}
+		
+		// pReqPkt->DataLen		= usb_long(MassData->ScsiDataLen);
+		// TODO:
+		// memcpy(&(iUsbScsiPkt->Data),&(MassData->ScsiData),MassData->ScsiDataLen);
+	}
+	
+	pReqPkt->CurrentLUN = common->lun;
+
+	rc = 0;
+	return rc;
+}
+
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -2078,6 +2282,11 @@
 	struct usb_request	*req = bh->outreq;
 	struct bulk_cb_wrap	*cbw = req->buf;
 	struct fsg_common	*common = fsg->common;
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	u8 instance = 0;
+	AMI_GADGET_PRIV *pAMI_gadget_priv;
+	int node_type_id;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 
 	/* Was this a real packet?  Should it be ignored? */
 	if (req->status || test_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))
@@ -2142,6 +2351,22 @@
 	else
 		common->curlun = NULL;
 	common->tag = cbw->Tag;
+
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+		node_type_id = fsg->node_type;
+		instance = cbw->Lun; // the instance for AMI scsi protocol "MUST" be from the Lun of CBW as the lun of struct common...
+		if (MAX_AMI_LUNS > instance)
+		{
+			pAMI_gadget_priv = &common->fsg->ami_gadget_priv[instance];
+//			ami_do_cbw_to_ami_scsi_protocol(common, bh, (GADGET_SCSI_PACKET*)pAMI_gadget_priv->usb_pkt_req);
+		}
+		else
+		{	// check boundary.
+			printk("node type %d LUN %d received_cbw overflow\n", node_type_id, instance);
+		}
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
+
 	return 0;
 }
 
@@ -2888,9 +3113,469 @@
 		kfree(common);
 }
 
-
 /*-------------------------------------------------------------------------*/
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+/* Functions for remote request and response */
+void gmsg_ami_init_device(struct fsg_dev *fsg, const unsigned int node_type_id)
+{
+	int i = 0;
+	int max_luns = 0;
+	int count = 0;
+	AMI_GADGET_PRIV *pAMI_gadget_priv = NULL;
+	AMI_GADGET_PRIV *pAMI_gadget_vendor_priv = NULL;
+	
+	if (NULL == fsg)
+	{
+		printk("CRIT!!!, invalid fsg");
+		return ;
+	}
+	
+	if ( GADGET_MASS_STORAGE_NODE_TYPE_ID_MAX <= node_type_id)
+	{	// check boundary.
+		printk("invalid node type %d \n", node_type_id);
+		return ;
+	}
+	
+	count = (sizeof(fsg->ami_gadget_priv)/sizeof(AMI_GADGET_PRIV));
+	max_luns = min(MAX_AMI_LUNS, count);
+	// printk("valid max luns %d for node type %d\n", max_luns, node_type_id);
+	// Initialize wait_queue and buffers.
+	
+	switch(node_type_id)
+	{
+		case GADGET_MASS_STORAGE_NODE_TYPE_ID_CD:
+		{
+
+			for (i = 0; i < max_luns; i += 1)
+			{
+				pAMI_gadget_priv = &fsg->ami_gadget_priv[i];
+				if (NULL == pAMI_gadget_priv)
+				{
+					printk("invalid lun %d for node type %d to init\n", i, node_type_id);
+					continue;
+				}// printk("valid lun %d for node type %d to init\n", i, node_type_id);				
+
+				memset(&cd_usb_hw_res_pkt[i], 0x00, sizeof (cd_usb_hw_res_pkt[0]));
+				pAMI_gadget_priv->usb_pkt_res = cd_usb_hw_res_pkt[i];
+			}
+			break;
+		}
+		case GADGET_MASS_STORAGE_NODE_TYPE_ID_HD:
+		{
+			for (i = 0; i < max_luns; i += 1)
+			{
+				pAMI_gadget_priv = &fsg->ami_gadget_priv[i];
+				if (NULL == pAMI_gadget_priv)
+				{
+					printk("invalid lun %d for node type %d to init\n", i, node_type_id);
+					continue;
+				}// printk("valid lun %d for node type %d to init\n", i, node_type_id);
+				
+				memset(&hd_usb_hw_res_pkt[i], 0x00, sizeof (hd_usb_hw_res_pkt[0]));
+				pAMI_gadget_priv->usb_pkt_res = hd_usb_hw_res_pkt[i];
+			}
+			break;
+		}
+		default:
+		{
+			// do nothing.
+			printk("unknow node type %d", node_type_id);
+			break;
+		}
+	}
+}
+
+/* Functions for Device node */
+static int f_msg_release(struct inode *inode, struct file *fd)
+{
+	fd->private_data = NULL;
+	return 0;
+}
+
+static int f_msg_open(struct inode *inode, struct file *fd)
+{
+	struct fsg_dev *fsg =
+		container_of(inode->i_cdev, struct fsg_dev, cdev);
+
+	fd->private_data = fsg;
+	return 0;
+}
+
+static int ami_event_notification_remote_cd_eject(struct fsg_dev *fsg, GADGET_SCSI_PACKET *pResPkt)
+{	// handle the eject event of cd from remote.
+	struct fsg_common *common = fsg->common;
+	unsigned int node_type_id;
+	uint8 instance;
+	AMI_GADGET_PRIV *pAMI_gadget_priv = NULL;
+	AMI_GADGET_EVENT_STATUS_PRIV *pAMI_media_event_status_priv;
+	
+	if (NULL == fsg)
+	{
+		printk("CRIT!!!, invalid fsg");
+		return -1;
+	}
+	
+	if (NULL == common)
+	{
+		printk("CRIT!!!, invalid fsg_common");
+		return -1;
+	}
+	
+	if (!pResPkt)
+		return -EFAULT;
+	
+	node_type_id = fsg->node_type;
+	
+	if (__copy_from_user((void *)(&instance), &pResPkt->CurrentLUN, sizeof(uint8)))
+	{
+		printk ("ami_event_notification_remote_cd_eject: __copy_from_user failed\n");
+		return -EINVAL;
+	}
+	
+	if ( GADGET_MASS_STORAGE_NODE_TYPE_ID_CD != node_type_id)
+	{	// check boundary.
+		printk("invalid node type %d \n", node_type_id);
+		return -1;
+	}
+	
+	if ( MAX_AMI_LUNS <= instance)
+	{	// check boundary.
+		printk("ami_event_notification_remote_cd_eject invalid instance %d for node type %d\n", instance, node_type_id);
+		return -1;
+	}
+	
+	pAMI_gadget_priv = &fsg->ami_gadget_priv[instance];
+	if (NULL == pAMI_gadget_priv)
+	{
+		printk("CRIT!!!, invalid priv\n");
+		return -1;
+	}
+
+	// Update the media event status for each lun of cd.
+	pAMI_media_event_status_priv = &pAMI_gadget_priv->media_event_status;
+	
+	pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_MEDIA_REMOVAL;
+	
+	pAMI_media_event_status_priv->MediaStatus = 0x00;
+	
+	pAMI_media_event_status_priv->additional_media_eject = MEDIA_EVENT_ID_EJECT_REQUEST;	// For CD eject event with Windows Host.
+
+	return 0; // all right.
+}
+
+static int ami_event_notification_kernel_cd_load(struct fsg_dev *fsg, const unsigned int Instance)
+{	// handle the load event of cd from kernel.
+	struct fsg_common *common = fsg->common;
+	unsigned int node_type_id;
+	AMI_GADGET_PRIV *pAMI_gadget_priv = NULL;
+	AMI_GADGET_EVENT_STATUS_PRIV *pAMI_media_event_status_priv;
+	
+	if (NULL == fsg)
+	{
+		printk("CRIT!!!, invalid fsg");
+		return -1;
+	}
+	
+	if (NULL == common)
+	{
+		printk("CRIT!!!, invalid fsg_common");
+		return -1;
+	}
+	
+	node_type_id = fsg->node_type;
+	
+	if ( GADGET_MASS_STORAGE_NODE_TYPE_ID_CD != node_type_id)
+	{	// check boundary.
+		printk("invalid node type %d \n", node_type_id);
+		return -1;
+	}
+	
+	if ( MAX_AMI_LUNS <= Instance)
+	{	// check boundary.
+		printk("cd load event invalid instance %d for node type %d\n", Instance, node_type_id);
+		return -1;
+	}
+	
+	pAMI_gadget_priv = &fsg->ami_gadget_priv[Instance];
+	if (NULL == pAMI_gadget_priv)
+	{
+		printk("CRIT!!!, invalid priv\n");
+		return -1;
+	}
+	
+	// Update the media event status for each lun of cd.
+	pAMI_media_event_status_priv = &pAMI_gadget_priv->media_event_status;
+	
+	pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_NEW_MEDIA;
+	
+	pAMI_media_event_status_priv->MediaStatus = MEDIA_PRESENT;
+	
+	pAMI_media_event_status_priv->additional_media_eject = MEDIA_EVENT_ID_NO_EVENT;	// For CD eject event with Windows Host.
+	
+	return 0; // all right.
+}
+
+static int ami_event_notifacation_remote_hd_eject(struct fsg_dev *fsg, GADGET_SCSI_PACKET *pResPkt)
+{	// handle the eject event of hd from remote.
+	struct fsg_common *common = fsg->common;
+	unsigned int node_type_id;
+	uint8 instance;
+	AMI_GADGET_PRIV *pAMI_gadget_priv = NULL;
+	AMI_GADGET_EVENT_STATUS_PRIV *pAMI_media_event_status_priv;
+
+	if (NULL == fsg)
+	{
+		printk("CRIT!!!, invalid fsg");
+		return -1;
+	}
+	
+	if (NULL == common)
+	{
+		printk("CRIT!!!, invalid fsg_common");
+		return -1;
+	}
+	
+	if (!pResPkt)
+		return -EFAULT;
+	
+	node_type_id = fsg->node_type;
+	
+	if (__copy_from_user((void *)(&instance), &pResPkt->CurrentLUN, sizeof(uint8)))
+	{
+		printk ("ami_event_notifacation_remote_hd_eject: __copy_from_user failed\n");
+		return -EINVAL;
+	}
+	
+	if ( GADGET_MASS_STORAGE_NODE_TYPE_ID_HD != node_type_id)
+	{	// check boundary.
+		printk("invalid node type %d \n", node_type_id);
+		return -1;
+	}
+	
+	if ( MAX_AMI_LUNS <= instance)
+	{	// check boundary.
+		printk("ami_event_notifacation_remote_hd_eject invalid instance %d for node type %d\n", instance, node_type_id);
+		return -1;
+	}
+	
+	pAMI_gadget_priv = &fsg->ami_gadget_priv[instance];
+	if (NULL == pAMI_gadget_priv)
+	{
+		printk("CRIT!!!, invalid priv\n");
+		return -1;
+	}
+
+	// Update the media event status for each lun of hd.
+	pAMI_media_event_status_priv = &pAMI_gadget_priv->media_event_status;
+	
+	pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_EJECT_REQUEST;
+	
+	pAMI_media_event_status_priv->MediaStatus = MEDIA_PRESENT;
+	
+	pAMI_media_event_status_priv->additional_media_eject = MEDIA_EVENT_ID_EJECT_REQUEST;
+
+	return 0; // all right.
+}
+
+static int ami_event_notification_kernel_hd_load(struct fsg_dev *fsg, const unsigned int Instance)
+{	// handle the load event of hd from kernel.
+	struct fsg_common *common = fsg->common;
+	unsigned int node_type_id;
+	AMI_GADGET_PRIV *pAMI_gadget_priv = NULL;
+	AMI_GADGET_EVENT_STATUS_PRIV *pAMI_media_event_status_priv;
+	
+	if (NULL == fsg)
+	{
+		printk("CRIT!!!, invalid fsg");
+		return -1;
+	}
+	
+	if (NULL == common)
+	{
+		printk("CRIT!!!, invalid fsg_common");
+		return -1;
+	}
+	
+	node_type_id = fsg->node_type;
+	
+	if ( GADGET_MASS_STORAGE_NODE_TYPE_ID_HD != node_type_id)
+	{	// check boundary.
+		printk("invalid node type %d \n", node_type_id);
+		return -1;
+	}
+	
+	if ( MAX_AMI_LUNS <= Instance)
+	{	// check boundary.
+		printk("hd load event invalid instance %d for node type %d\n", Instance, node_type_id);
+		return -1;
+	}
+	
+	pAMI_gadget_priv = &fsg->ami_gadget_priv[Instance];
+	if (NULL == pAMI_gadget_priv)
+	{
+		printk("CRIT!!!, invalid priv\n");
+		return -1;
+	}
+	
+	// Update the media event status for each lun of hd.
+	pAMI_media_event_status_priv = &pAMI_gadget_priv->media_event_status;
+	
+	pAMI_media_event_status_priv->MediaEventCode = MEDIA_EVENT_ID_NEW_MEDIA;
+	
+	pAMI_media_event_status_priv->MediaStatus = MEDIA_PRESENT;
+	
+	pAMI_media_event_status_priv->additional_media_eject = MEDIA_EVENT_ID_NO_EVENT;
+	
+	return 0; // all right.
+}
+
+static int ami_kernel_medium_unload(struct fsg_dev *fsg, const unsigned int Instance)
+{	// handle the unload event of cd/hd in kernel for remote cd/hd exit.
+	struct fsg_common *common = fsg->common;
+	struct fsg_lun	*unloadlun = common->curlun;
+	unsigned int node_type_id;
+	AMI_GADGET_PRIV *pAMI_gadget_priv = NULL;
+	AMI_GADGET_EVENT_STATUS_PRIV *pAMI_media_event_status_priv;
+
+	if (NULL == fsg)
+	{
+		printk("CRIT!!!, invalid fsg");
+		return -1;
+	}
+	
+	if (NULL == common)
+	{
+		printk("CRIT!!!, invalid fsg_common");
+		return -1;
+	}
+	
+	node_type_id = fsg->node_type;
+
+	if (GADGET_MASS_STORAGE_NODE_TYPE_ID_MAX <= node_type_id)
+	{	// check boundary.
+		 printk("invalid node type %d \n", node_type_id);
+		return -1;
+	}
+	
+	if ( MAX_AMI_LUNS <= Instance)
+	{	// check boundary.
+		printk("unload event invalid instance %d for node type %d\n", Instance, node_type_id);
+		return -1;
+	}
+	
+	pAMI_gadget_priv = &fsg->ami_gadget_priv[Instance];
+	if (NULL == pAMI_gadget_priv)
+	{
+		printk("CRIT!!!, invalid priv\n");
+		return -1;
+	}
+	
+	// Stop the media for each lun of mass-storage.
+	pAMI_media_event_status_priv = &pAMI_gadget_priv->media_event_status;
+
+	switch(pAMI_media_event_status_priv->additional_media_eject)
+	{
+		case MEDIA_EVENT_ID_NO_EVENT:	// nothing to do.
+			break;
+		case MEDIA_EVENT_ID_EJECT_REQUEST:	// unload the media of cd/hd if possible.
+			if (NULL == unloadlun)
+			{	// nothing to do.
+				break;
+			}
+			// printk("try to unload node type %d lun %d \n", node_type_id, Instance);
+			// Mind the sem...
+			// down_read(&common->filesem);
+			// down_write(&common->filesem);
+			fsg_lun_close(unloadlun); // close the lun causes the status of eject with SCSI command: 0x03(REQUEST SENSE), and it helps to notify the host that the disk is no longer available.
+			// up_write(&common->filesem);
+			// up_read(&common->filesem);
+			pAMI_media_event_status_priv->additional_media_eject = MEDIA_EVENT_ID_NO_EVENT;
+			// printk("DBG!!! node type %d lun %d mode %d unload\n", node_type_id, Instance, pAMI_gadget_priv->redirect_mode);
+//			if (GADGET_REDIRECTION_MODE_BYPASS == pAMI_gadget_priv->redirect_mode)
+//			{	// once stop the media redirection, set mode to origin to avoid the timeout of request.
+//				pAMI_gadget_priv->redirect_mode = GADGET_REDIRECTION_MODE_ORIGIN;
+//			}
+			
+			// printk("node type %d lun %d unload ok\n", node_type_id, Instance);
+			break;
+		default:
+			printk("WARN!!! node type %d lun %d unknown status %d\n", node_type_id, Instance, pAMI_media_event_status_priv->additional_media_eject);
+			break;
+	}
+//	printk("ami_kernel_medium_unload <= \n");
+	return 0; // all right.
+}
+
+// ref to ffs_ep0_ioctl, dev_ioctl, printer_ioctl.
+static long ami_f_msg_ioctl(struct file *fd, unsigned int code, unsigned long arg)
+{
+	struct fsg_dev *fsg = fd->private_data;
+	struct fsg_common *common = fsg->common;
+	uint8 Instance = common->lun;
+	// struct usb_gadget *gadget = fsg->gadget; // for gadget ioctl....
+	// unsigned long		flags;
+	unsigned int node_type_id;
+	LUN_INFO_CMD lun_info;
+	int			status = 0;
+
+	DBG(fsg, "ami_f_msg_ioctl: cmd=0x%4.4x, arg=%lu\n", code, arg);
+	
+	node_type_id = fsg->node_type;
+	
+	if (GADGET_MASS_STORAGE_NODE_TYPE_ID_MAX <= node_type_id)
+	{
+		printk("invalid node type %d\n", node_type_id);
+		return -1;
+	}
+	
+	if (MAX_AMI_LUNS <= common->lun)
+	{
+		printk("invalid lun %d for node type %d\n", Instance, node_type_id);
+		return -1;
+	}
+
+	/* handle ioctls */
+
+	/* TODO */
+	// spin_lock_irqsave(&fsg->lock, flags);
+	
+	// status = gadget->ops->ioctl (gadget, code, value);
+	switch (code) {
+		case USB_CDROM_EXIT:	// cd ejection from remote.
+			status = ami_event_notification_remote_cd_eject(fsg, (GADGET_SCSI_PACKET *)arg);
+			if (status)
+			{
+				printk("something error with cd to send eject: %d\n", status);
+			}
+			break;
+		case USB_HDISK_EXIT:	// hd ejection from remote.
+			status = ami_event_notifacation_remote_hd_eject(fsg, (GADGET_SCSI_PACKET *)arg);
+			if (status)
+			{
+				printk("something error with hd to send eject: %d\n", status);
+			}
+			break;	
+		default:
+			/* could not handle ioctl */
+			DBG(fsg, "ami_f_msg_ioctl: ERROR cmd=0x%4.4xis not supported\n",
+					code);
+			status = -ENOTTY;
+	}
+
+	// spin_unlock_irqrestore(&fsg->lock, flags);
+
+	return status;
+}
+
+static const struct file_operations f_msg_fops = {
+	.owner		= THIS_MODULE,
+	.open		= f_msg_open,
+	.release	= f_msg_release,
+	.unlocked_ioctl = ami_f_msg_ioctl	// TODO....
+};
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
 static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct fsg_dev		*fsg = fsg_from_func(f);
@@ -2902,6 +3587,7 @@
 	int			ret;
 	struct fsg_opts		*opts;
 
+
 	/* Don't allow to bind if we don't have at least one LUN */
 	ret = _fsg_common_get_max_lun(common);
 	if (ret < 0) {
@@ -2915,7 +3601,6 @@
 					  fsg->common->can_stall);
 		if (ret)
 			return ret;
-		fsg_common_set_inquiry_string(fsg->common, NULL, NULL);
 	}
 
 	if (!common->thread_task) {
@@ -2989,6 +3674,34 @@
 	return i;
 }
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+
+static inline int gmsg_get_minor(void)
+{
+	int ret;
+
+	ret = ida_simple_get(&msg_ida, 0, 0, GFP_KERNEL);
+	if (ret >= MSG_MINORS) {
+		ida_simple_remove(&msg_ida, ret);
+		ret = -ENODEV;
+	}
+
+	return ret;
+}
+
+static inline void gmsg_put_minor(int minor)
+{
+	mutex_lock(&msg_ida_lock);
+
+	ida_simple_remove(&msg_ida, minor);
+	if (ida_is_empty(&msg_ida))
+		gmsg_cleanup();
+
+	mutex_unlock(&msg_ida_lock);
+}
+
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
 /****************************** ALLOCATE FUNCTION *************************/
 
 static void fsg_unbind(struct usb_configuration *c, struct usb_function *f)
@@ -3042,8 +3755,41 @@
 {
 	struct fsg_lun_opts *opts = to_fsg_lun_opts(item);
 	struct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);
-
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	int ret = 0;
+	
+	ret = fsg_store_file(opts->lun, &fsg_opts->common->filesem, page, len);
+	// set up the event status for each lun only once the fsg is available when file loaded.
+	if (NULL == fsg_opts->common->fsg)
+	{	// the fsg is not available before fsg_setup()...
+		return ret;
+	}
+	else
+	{
+		if (0 > ret)
+		{	// somehting error, skip the set up of event status for each lun.
+			return ret;
+		}
+		// printk("DBG!fsg_lun_opts_file_store opt lun %d\n", opts->lun_id);
+		// printk("DBG!fsg_lun_opts_file_store %d\n", fsg_opts->common->fsg->node_type);
+		switch(fsg_opts->common->fsg->node_type)
+		{
+			case GADGET_MASS_STORAGE_NODE_TYPE_ID_CD:
+				ami_event_notification_kernel_cd_load(fsg_opts->common->fsg, opts->lun_id);
+				break;
+			case GADGET_MASS_STORAGE_NODE_TYPE_ID_HD:
+				ami_event_notification_kernel_hd_load(fsg_opts->common->fsg, opts->lun_id);
+				break;
+			default:
+				printk("ERR!unknown node type %d\n", fsg_opts->common->fsg->node_type);
+				break;
+		}
+	}
+	return ret;	// all right.
+	
+#elif(0 == ENABLE_MASS_STORAGE_NODE)
 	return fsg_store_file(opts->lun, &fsg_opts->common->filesem, page, len);
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 }
 
 CONFIGFS_ATTR(fsg_lun_opts_, file);
@@ -3338,6 +4084,12 @@
 	struct fsg_opts *opts;
 
 	opts = fsg_opts_from_func_inst(fi);
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	if (0 <= opts->minor)
+	{
+		gmsg_put_minor(opts->minor);
+	}
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 	fsg_common_release(opts->common);
 	kfree(opts);
 }
@@ -3347,6 +4099,10 @@
 	struct fsg_opts *opts;
 	struct fsg_lun_config config;
 	int rc;
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	struct usb_function_instance *ret;
+	int status = 0;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 
 	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
 	if (!opts)
@@ -3375,6 +4131,28 @@
 
 	opts->lun0.lun = opts->common->luns[0];
 	opts->lun0.lun_id = 0;
+	
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	mutex_lock(&msg_ida_lock);
+
+	if (ida_is_empty(&msg_ida)) {
+		status = gmsg_setup(NULL, MSG_MINORS);
+		if (status)  {
+			ret = ERR_PTR(status);
+			kfree(opts);
+			goto unlock;
+		}
+	}
+	opts->minor = gmsg_get_minor();
+	if (opts->minor < 0) {
+		ret = ERR_PTR(opts->minor);
+		if (ida_is_empty(&msg_ida))
+			gmsg_cleanup();
+		goto unlock;
+	}
+unlock:
+	mutex_unlock(&msg_ida_lock);
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 
 	config_group_init_type_name(&opts->func_inst.group, "", &fsg_func_type);
 
@@ -3404,6 +4182,12 @@
 	opts->refcnt--;
 	mutex_unlock(&opts->lock);
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	if(fsg->minor >= GADGET_MASS_STORAGE_NODE_TYPE_ID_HD) {
+		device_destroy(msg_class, MKDEV(major, fsg->minor));
+		cdev_del(&fsg->cdev);
+	}
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 	kfree(fsg);
 }
 
@@ -3412,6 +4196,11 @@
 	struct fsg_opts *opts = fsg_opts_from_func_inst(fi);
 	struct fsg_common *common = opts->common;
 	struct fsg_dev *fsg;
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	struct device		*device;
+	dev_t			dev;
+	int ret = 0;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 
 	fsg = kzalloc(sizeof(*fsg), GFP_KERNEL);
 	if (unlikely(!fsg))
@@ -3420,7 +4209,9 @@
 	mutex_lock(&opts->lock);
 	opts->refcnt++;
 	mutex_unlock(&opts->lock);
-
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	fsg->minor = opts->minor;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 	fsg->function.name	= FSG_DRIVER_DESC;
 	fsg->function.bind	= fsg_bind;
 	fsg->function.unbind	= fsg_unbind;
@@ -3431,7 +4222,42 @@
 
 	fsg->common               = common;
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	if(fsg->minor >= GADGET_MASS_STORAGE_NODE_TYPE_ID_HD) {
+		/* create char device */
+		cdev_init(&fsg->cdev, &f_msg_fops);
+		dev = MKDEV(major, fsg->minor);
+		ret = cdev_add(&fsg->cdev, dev, 1);
+		if (ret)
+			goto cdev_fail;
+
+		// get the lun info to indicate the node type for node name and further use.
+	#if(0)	// DBG
+		printk("DBG!fsg_alloc lun %d\n", common->lun);
+		printk("DBG!fsg_alloc cdrom %d\n", common->luns[common->lun]->cdrom);
+	#endif
+		fsg->node_type = common->luns[common->lun]->cdrom;
+		
+		device = device_create(msg_class, NULL, dev, NULL,
+					   "%s%s", MSG_NODE_NAME_PREFIX, (!fsg->node_type)?"hd":"cd"); // Deivce node named as usbhd/usbcd.
+		if (IS_ERR(device)) {
+			ret = PTR_ERR(device);
+			goto del;
+		}
+
+		gmsg_ami_init_device(fsg, fsg->node_type);
+	}
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
 	return &fsg->function;
+
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+del:
+	cdev_del(&fsg->cdev);
+cdev_fail:
+	ERROR(fsg, "cdev add fail\n");
+	return &fsg->function;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 }
 
 DECLARE_USB_FUNCTION_INIT(mass_storage, fsg_alloc_inst, fsg_alloc);
@@ -3474,3 +4300,43 @@
 	cfg->fsg_num_buffers = fsg_num_buffers;
 }
 EXPORT_SYMBOL_GPL(fsg_config_from_params);
+
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+int gmsg_setup(struct usb_gadget *g, int count)
+{
+	int status;
+	dev_t dev;
+
+	msg_class = class_create(THIS_MODULE, MSG_CLASS_NAME);
+	if (IS_ERR(msg_class)) {
+		status = PTR_ERR(msg_class);
+		msg_class = NULL;
+		pr_err("unable to create usb_gadget MSG class %d\n", status);
+		return status;
+	}
+
+	status = alloc_chrdev_region(&dev, 0, count, MSG_CLASS_NAME);
+	if (status) {
+		pr_err("MSG alloc_chrdev_region %d\n", status);
+		class_destroy(msg_class);
+		msg_class = NULL;
+		return status;
+	}
+
+	major = MAJOR(dev);
+	minors = count;
+
+	return 0;
+}
+
+void gmsg_cleanup(void)
+{
+	if (major) {
+		unregister_chrdev_region(MKDEV(major, 0), minors);
+		major = minors = 0;
+	}
+
+	class_destroy(msg_class);
+	msg_class = NULL;
+}
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
--- linux-5.4.85/drivers/usb/gadget/function/f_mass_storage.h	2021-04-15 16:08:43.241753029 +0800
+++ linux-5.4.85-new/drivers/usb/gadget/function/f_mass_storage.h	2021-04-22 11:14:51.500603165 +0800
@@ -5,6 +5,8 @@
 #include <linux/usb/composite.h>
 #include "storage_common.h"
 
+#define ENABLE_MASS_STORAGE_NODE	(1)	// let bind() able to create a node(name: usb) under /dev/. refer to f_hid.c...
+
 struct fsg_module_parameters {
 	char		*file[FSG_MAX_LUNS];
 	bool		ro[FSG_MAX_LUNS];
@@ -82,6 +84,9 @@
 	 */
 	struct mutex			lock;
 	int				refcnt;
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+	int minor;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
 };
 
 struct fsg_lun_config {
@@ -141,4 +146,19 @@
 			    const struct fsg_module_parameters *params,
 			    unsigned int fsg_num_buffers);
 
+#if (1 == ENABLE_MASS_STORAGE_NODE)
+#include "ami_gadget_ioctl.h"	// for ami media redirection.
+#include <linux/cdev.h>	// need for struct cdev...
+#define  usb_long(x)	(x)
+#define MAX_SCSI_DATA 	(64*2048)
+int gmsg_setup(struct usb_gadget *g, int count);
+void gmsg_cleanup(void);
+
+typedef struct LUN_INFO_CMD {
+	u8 type;	// device type:cd/hd.
+	u8 lun;	// lun idx.
+	u8 mode;	// redirect mode.
+}PACKED LUN_INFO_CMD;
+#endif // end #if (1 == ENABLE_MASS_STORAGE_NODE)
+
 #endif /* USB_F_MASS_STORAGE_H */
