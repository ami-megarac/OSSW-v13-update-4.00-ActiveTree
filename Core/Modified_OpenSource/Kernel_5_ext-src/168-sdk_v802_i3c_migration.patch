diff -Naur  linux_org/drivers/i3c/i3cdev.c linux/drivers/i3c/i3cdev.c
--- linux_org/drivers/i3c/i3cdev.c	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/i3cdev.c	2022-08-03 11:04:36.040235800 +0800
@@ -316,7 +316,6 @@
 	i3cdev->dev = device_create(i3cdev_class, &i3c->dev,
 				    MKDEV(MAJOR(i3cdev_number), i3cdev->id),
 				    NULL, "i3c-%s", dev_name(&i3c->dev));
-//				    NULL, "bus!i3c!%s", dev_name(&i3c->dev));					
 	if (IS_ERR(i3cdev->dev)) {
 		res = PTR_ERR(i3cdev->dev);
 		goto error;
diff -Naur  linux_org/drivers/i3c/i3c-ibi-mqueue.c linux/drivers/i3c/i3c-ibi-mqueue.c
--- linux_org/drivers/i3c/i3c-ibi-mqueue.c	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/i3c-ibi-mqueue.c	2022-08-03 21:59:43.066721046 +0800
@@ -55,7 +55,7 @@
 	memcpy(&msg->buf[msg->len], buf, payload->len - sizeof(status));
 	msg->len += payload->len - sizeof(status);
 
-	/* if last fragment, notidy and update pointers */
+	/* if last fragment, notify and update pointers */
 	if (status & IBI_STATUS_LAST_FRAG) {
 		/* check pending-read-notification */
 		if (IS_MDB_PENDING_READ_NOTIFY(msg->buf[0])) {
@@ -67,14 +67,6 @@
 				},
 			};
 
-			/*
-			 * Aspeed slave devices need for additional delay for
-			 * preparing the pending data
-			 */
-			if (I3C_PID_MANUF_ID(dev->desc->info.pid) ==
-			    PID_MANUF_ID_ASPEED) {
-				mdelay(10);
-			}
 			i3c_device_do_priv_xfers(dev, xfers, 1);
 
 			msg->len = xfers[0].len;
@@ -200,6 +192,7 @@
 
 	kernfs_put(mq->kn);
 	sysfs_remove_bin_file(&i3cdev->dev.kobj, &mq->bin);
+
 	return 0;
 }
 
diff -Naur  linux_org/drivers/i3c/i3c-mux-imx3102.c linux/drivers/i3c/i3c-mux-imx3102.c
--- linux_org/drivers/i3c/i3c-mux-imx3102.c	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/i3c-mux-imx3102.c	2022-08-03 21:59:42.906723020 +0800
@@ -204,6 +204,7 @@
 	kernfs_put(imx3102->kn);
 	sysfs_remove_bin_file(&dev->kobj, &imx3102->ownership);
 	devm_kfree(dev, imx3102);
+
 	return 0;
 }
 
diff -Naur  linux_org/drivers/i3c/i3c-slave-eeprom.c linux/drivers/i3c/i3c-slave-eeprom.c
--- linux_org/drivers/i3c/i3c-slave-eeprom.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/i3c/i3c-slave-eeprom.c	2022-08-03 21:59:43.090720751 +0800
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2022 Aspeed Technology Inc.
+ */
+
+#include <linux/i3c/master.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+
+struct eeprom_data {
+	struct bin_attribute bin;
+	struct work_struct prep_rdata;
+	spinlock_t buffer_lock;
+	u16 buffer_idx;
+	u16 address_mask;
+	u8 num_address_bytes;
+
+	struct i3c_master_controller *i3c_controller;
+	u8 buffer[];
+};
+
+static void i3c_slave_eeprom_prep_rdata(struct work_struct *work)
+{
+	struct eeprom_data *eeprom = container_of(work, struct eeprom_data, prep_rdata);
+	struct i3c_slave_payload read_data, notify;
+	u32 mdb = IBI_MDB_ID(0b101, 0x1f);
+
+	notify.len = 1;
+	notify.data = &mdb;
+
+	read_data.len = eeprom->address_mask - eeprom->buffer_idx + 1;
+	read_data.data = &eeprom->buffer[eeprom->buffer_idx];
+	i3c_master_put_read_data(eeprom->i3c_controller, &read_data, &notify);
+}
+
+static void i3c_slave_eeprom_callback(struct i3c_master_controller *master,
+				      const struct i3c_slave_payload *payload)
+{
+	struct eeprom_data *eeprom = dev_get_drvdata(&master->dev);
+	int wr_len;
+	u8 *buf = (u8 *)payload->data;
+
+	if (!payload->len)
+		return;
+
+	if (eeprom->num_address_bytes == 2)
+		eeprom->buffer_idx = ((u16)buf[0] << 8) | buf[1];
+	else
+		eeprom->buffer_idx = (u16)buf[0];
+
+	wr_len = payload->len - eeprom->num_address_bytes;
+
+	pr_debug("len = %d, index=%d, wr_len=%d\n", payload->len,
+		 eeprom->buffer_idx, wr_len);
+
+	if (wr_len > 0) {
+		if (eeprom->buffer_idx + wr_len > eeprom->address_mask) {
+			u16 len = eeprom->address_mask - eeprom->buffer_idx + 1;
+
+			memcpy(&eeprom->buffer[eeprom->buffer_idx],
+			       &buf[eeprom->num_address_bytes], len);
+			memcpy(&eeprom->buffer[0],
+			       &buf[eeprom->num_address_bytes + len],
+			       wr_len - len);
+		} else {
+			memcpy(&eeprom->buffer[eeprom->buffer_idx],
+			       &buf[eeprom->num_address_bytes], wr_len);
+		}
+
+		eeprom->buffer_idx += wr_len;
+		eeprom->buffer_idx &= eeprom->address_mask;
+	}
+
+	/* prepare the read data outside of interrupt context */
+	schedule_work(&eeprom->prep_rdata);
+}
+
+static ssize_t i3c_slave_eeprom_bin_read(struct file *filp,
+					 struct kobject *kobj,
+					 struct bin_attribute *attr, char *buf,
+					 loff_t off, size_t count)
+{
+	struct eeprom_data *eeprom;
+	unsigned long flags;
+
+	eeprom = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&eeprom->buffer_lock, flags);
+	memcpy(buf, &eeprom->buffer[off], count);
+	spin_unlock_irqrestore(&eeprom->buffer_lock, flags);
+
+	return count;
+}
+
+static ssize_t i3c_slave_eeprom_bin_write(struct file *filp,
+					  struct kobject *kobj,
+					  struct bin_attribute *attr, char *buf,
+					  loff_t off, size_t count)
+{
+	struct eeprom_data *eeprom;
+	unsigned long flags;
+
+	eeprom = dev_get_drvdata(container_of(kobj, struct device, kobj));
+
+	spin_lock_irqsave(&eeprom->buffer_lock, flags);
+	memcpy(&eeprom->buffer[off], buf, count);
+	spin_unlock_irqrestore(&eeprom->buffer_lock, flags);
+
+	return count;
+}
+
+int i3c_slave_eeprom_probe(struct i3c_master_controller *master)
+{
+	struct eeprom_data *eeprom;
+	int ret;
+	struct i3c_slave_setup req = {};
+	struct device *dev = &master->dev;
+
+	/* fixed parameters for testing: size 64 bytes, address size is 1 byte */
+	unsigned int size = 64;
+	unsigned int flag_addr16 = 0;
+
+	eeprom = devm_kzalloc(dev, sizeof(struct eeprom_data) + size, GFP_KERNEL);
+	if (!eeprom)
+		return -ENOMEM;
+
+	eeprom->num_address_bytes = flag_addr16 ? 2 : 1;
+	eeprom->address_mask = size - 1;
+	spin_lock_init(&eeprom->buffer_lock);
+	dev_set_drvdata(dev, eeprom);
+
+	memset(eeprom->buffer, 0xff, size);
+
+	sysfs_bin_attr_init(&eeprom->bin);
+	eeprom->bin.attr.name = "slave-eeprom";
+	eeprom->bin.attr.mode = 0600;
+	eeprom->bin.read = i3c_slave_eeprom_bin_read;
+	eeprom->bin.write = i3c_slave_eeprom_bin_write;
+	eeprom->bin.size = size;
+
+	eeprom->i3c_controller = master;
+
+	ret = sysfs_create_bin_file(&dev->kobj, &eeprom->bin);
+	if (ret)
+		return ret;
+
+	INIT_WORK(&eeprom->prep_rdata, i3c_slave_eeprom_prep_rdata);
+
+	req.handler = i3c_slave_eeprom_callback;
+	req.max_payload_len = size;
+	req.num_slots = 1;
+
+	ret = i3c_master_register_slave(master, &req);
+	if (ret) {
+		sysfs_remove_bin_file(&dev->kobj, &eeprom->bin);
+		return ret;
+	}
+
+	return 0;
+}
+
+int i3c_slave_eeprom_remove(struct i3c_master_controller *master)
+{
+	struct device *dev = &master->dev;
+	struct eeprom_data *eeprom = dev_get_drvdata(dev);
+
+	i3c_master_unregister_slave(master);
+	sysfs_remove_bin_file(&dev->kobj, &eeprom->bin);
+
+	return 0;
+}
diff -Naur  linux_org/drivers/i3c/i3c-slave-mqueue.c linux/drivers/i3c/i3c-slave-mqueue.c
--- linux_org/drivers/i3c/i3c-slave-mqueue.c	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/i3c-slave-mqueue.c	2022-08-03 21:59:43.074720947 +0800
@@ -16,6 +16,7 @@
 #define MQ_QUEUE_NEXT(x)	(((x) + 1) & (MQ_QUEUE_SIZE - 1))
 
 #define IBI_STATUS_LAST_FRAG	BIT(24)
+#define MQ_MDB			IBI_MDB_ID(0b101, 0x1f)
 
 struct mq_msg {
 	int len;
@@ -35,6 +36,7 @@
 	struct mq_msg queue[MQ_QUEUE_SIZE];
 
 	struct i3c_master_controller *i3c_controller;
+	u8 mdb;
 };
 
 static void i3c_slave_mqueue_callback(struct i3c_master_controller *master,
@@ -98,16 +100,30 @@
 					  loff_t pos, size_t count)
 {
 	struct mq_queue *mq;
-	unsigned long flags;
-	struct i3c_slave_payload payload;
+	struct i3c_slave_payload payload, ibi;
+	u8 *data;
 
-	payload.data = buf;
-	payload.len = count;
 	mq = dev_get_drvdata(container_of(kobj, struct device, kobj));
 
-	spin_lock_irqsave(&mq->lock, flags);
-	i3c_master_send_sir(mq->i3c_controller, &payload);
-	spin_unlock_irqrestore(&mq->lock, flags);
+	if (IS_MDB_PENDING_READ_NOTIFY(mq->mdb)) {
+		ibi.data = &mq->mdb;
+		ibi.len = 1;
+		payload.data = buf;
+		payload.len = count;
+		i3c_master_put_read_data(mq->i3c_controller, &payload, &ibi);
+	} else {
+		data = kmalloc(count + 1, GFP_KERNEL);
+		if (!data)
+			return -ENOMEM;
+
+		data[0] = mq->mdb;
+		memcpy(&data[1], buf, count);
+
+		payload.data = data;
+		payload.len = count + 1;
+		i3c_master_send_sir(mq->i3c_controller, &payload);
+		kfree(data);
+	}
 
 	return count;
 }
@@ -149,6 +165,7 @@
 	mq->bin.size = MQ_MSGBUF_SIZE * MQ_QUEUE_SIZE;
 
 	mq->i3c_controller = master;
+	mq->mdb = MQ_MDB;
 
 	ret = sysfs_create_bin_file(&dev->kobj, &mq->bin);
 	if (ret)
diff -Naur  linux_org/drivers/i3c/Kconfig linux/drivers/i3c/Kconfig
--- linux_org/drivers/i3c/Kconfig	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/Kconfig	2022-08-03 21:59:43.090720751 +0800
@@ -56,9 +56,19 @@
 	  Userspace can get the messages by reading sysfs file that this driver
 	  exposes.
 
+config I3C_MUX_IMX3102
+	bool "IMX/IML3102 I3C multiplexer driver"
+	default y
+	select REGMAP_I3C
+	help
+	  Say y to enable Renesas IMX3102 I3C 2:1 multiplexer.
+
+choice
+	prompt "I3C secondary master / slave mode driver selection"
+	default I3C_SLAVE_MQUEUE
+
 config I3C_SLAVE_MQUEUE
 	bool "I3C mqueue (message queue) secondary master and slave driver"
-	default y
 	help
 	  Some protocols over I3C are designed for bi-directional transferring
 	  messages by using I3C Master Write protocol. This driver is used to
@@ -67,12 +77,11 @@
 	  Userspace can get the messages by reading sysfs file that this driver
 	  exposes.
 
-config I3C_MUX_IMX3102
-	bool "IMX/IML3102 I3C multiplexer driver"
-	default y
-	select REGMAP_I3C
+config I3C_SLAVE_EEPROM
+	bool "I3C EEPROM secondary master and slave driver"
 	help
-	  Say y to enable Renesas IMX3102 I3C 2:1 multiplexer.
+	  This driver makes the slave mode I3C controller simulate the EEPROM.
+endchoice
 
 source "drivers/i3c/master/Kconfig"
 endif # I3C
diff -Naur  linux_org/drivers/i3c/Makefile linux/drivers/i3c/Makefile
--- linux_org/drivers/i3c/Makefile	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/Makefile	2022-08-03 21:59:43.090720751 +0800
@@ -5,4 +5,5 @@
 obj-$(CONFIG_I3C)		+= master/
 obj-$(CONFIG_I3C_IBI_MQUEUE) 	+= i3c-ibi-mqueue.o
 obj-$(CONFIG_I3C_SLAVE_MQUEUE) 	+= i3c-slave-mqueue.o
+obj-$(CONFIG_I3C_SLAVE_EEPROM) 	+= i3c-slave-eeprom.o
 obj-$(CONFIG_I3C_MUX_IMX3102) 	+= i3c-mux-imx3102.o
diff -Naur  linux_org/drivers/i3c/master/ast2600-i3c-global.c linux/drivers/i3c/master/ast2600-i3c-global.c
--- linux_org/drivers/i3c/master/ast2600-i3c-global.c	2022-07-25 16:14:55.326763581 +0800
+++ linux/drivers/i3c/master/ast2600-i3c-global.c	2022-08-03 21:59:42.882723317 +0800
@@ -127,12 +127,6 @@
 		.of_match_table = of_match_ptr(aspeed_i3c_of_match),
 	},
 };
-
-//static int __init aspeed_i3c_global_init(void)
-//{
-//	return platform_driver_register(&aspeed_i3c_driver);
-//}
-//postcore_initcall(aspeed_i3c_global_init);
 module_platform_driver(aspeed_i3c_driver);
 
 MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
diff -Naur  linux_org/drivers/i3c/master/ast2600-i3c-master.c linux/drivers/i3c/master/ast2600-i3c-master.c
--- linux_org/drivers/i3c/master/ast2600-i3c-master.c	2022-07-25 16:14:55.330763524 +0800
+++ linux/drivers/i3c/master/ast2600-i3c-master.c	2022-08-03 23:21:27.281378785 +0800
@@ -28,6 +28,8 @@
 #define DEV_CTRL_ENABLE			BIT(31)
 #define DEV_CTRL_RESUME			BIT(30)
 #define DEV_CTRL_AUTO_HJ_DISABLE	BIT(27)
+#define DEV_CTRL_SLAVE_MDB		GENMASK(23, 16)
+#define DEV_CTRL_SLAVE_PEC_EN		BIT(10)
 #define DEV_CRTL_IBI_PAYLOAD_EN		BIT(9)
 #define DEV_CTRL_HOT_JOIN_NACK		BIT(8)
 #define DEV_CTRL_I2C_SLAVE_PRESENT	BIT(7)
@@ -55,6 +57,9 @@
 #define COMMAND_PORT_ARG_DATA_LEN_MAX	65536
 #define COMMAND_PORT_TRANSFER_ARG	0x01
 
+#define COMMAND_ATTR_SLAVE_DATA		0x0
+#define COMMAND_PORT_SLAVE_DATA_LEN	GENMASK(31, 16)
+
 #define COMMAND_PORT_SDA_DATA_BYTE_3(x)	(((x) << 24) & GENMASK(31, 24))
 #define COMMAND_PORT_SDA_DATA_BYTE_2(x)	(((x) << 16) & GENMASK(23, 16))
 #define COMMAND_PORT_SDA_DATA_BYTE_1(x)	(((x) << 8) & GENMASK(15, 8))
@@ -77,7 +82,10 @@
 #define RESPONSE_ERROR_OVER_UNDER_FLOW	6
 #define RESPONSE_ERROR_TRANSF_ABORT	8
 #define RESPONSE_ERROR_I2C_W_NACK_ERR	9
+#define RESPONSE_ERROR_EARLY_TERMINATE	10
 #define RESPONSE_PORT_TID(x)		(((x) & GENMASK(27, 24)) >> 24)
+#define   TID_MASTER_WRITE_DATA		0b1000
+#define   TID_CCC_WRITE_DATA		0b1111
 #define RESPONSE_PORT_DATA_LEN(x)	((x) & GENMASK(15, 0))
 
 #define RX_TX_DATA_PORT			0x14
@@ -131,6 +139,11 @@
 					 RESET_CTRL_RESP_QUEUE	              |\
 					 RESET_CTRL_CMD_QUEUE	              |\
 					 RESET_CTRL_SOFT)
+#define RESET_CTRL_QUEUES		(RESET_CTRL_IBI_QUEUE	              |\
+					 RESET_CTRL_RX_FIFO	              |\
+					 RESET_CTRL_TX_FIFO	              |\
+					 RESET_CTRL_RESP_QUEUE	              |\
+					 RESET_CTRL_CMD_QUEUE)
 
 #define SLV_EVENT_CTRL			0x38
 #define SLV_EVENT_CTRL_MWL_UPD		BIT(7)
@@ -170,8 +183,7 @@
 					INTR_TX_THLD_STAT |		\
 					INTR_RX_THLD_STAT)
 #define INTR_MASTER_MASK		(INTR_TRANSFER_ERR_STAT |	\
-					 INTR_RESP_READY_STAT	|	\
-					 INTR_IBI_THLD_STAT)
+					 INTR_RESP_READY_STAT)
 #define INTR_2ND_MASTER_MASK		(INTR_TRANSFER_ERR_STAT |	\
 					 INTR_RESP_READY_STAT	|	\
 					 INTR_IBI_UPDATED_STAT  |	\
@@ -224,17 +236,17 @@
 #define DEVICE_CTRL_ROLE_SLAVE		1
 #define SCL_I3C_OD_TIMING		0xb4
 #define SCL_I3C_PP_TIMING		0xb8
-#define SCL_I3C_TIMING_HCNT(x)		(((x) << 16) & GENMASK(23, 16))
-#define SCL_I3C_TIMING_LCNT(x)		((x) & GENMASK(7, 0))
+#define SCL_I3C_TIMING_HCNT		GENMASK(23, 16)
+#define SCL_I3C_TIMING_LCNT		GENMASK(7, 0)
 #define SCL_I3C_TIMING_CNT_MIN		5
 
 #define SCL_I2C_FM_TIMING		0xbc
-#define SCL_I2C_FM_TIMING_HCNT(x)	(((x) << 16) & GENMASK(31, 16))
-#define SCL_I2C_FM_TIMING_LCNT(x)	((x) & GENMASK(15, 0))
+#define SCL_I2C_FM_TIMING_HCNT		GENMASK(31, 16)
+#define SCL_I2C_FM_TIMING_LCNT		GENMASK(15, 0)
 
 #define SCL_I2C_FMP_TIMING		0xc0
-#define SCL_I2C_FMP_TIMING_HCNT(x)	(((x) << 16) & GENMASK(23, 16))
-#define SCL_I2C_FMP_TIMING_LCNT(x)	((x) & GENMASK(15, 0))
+#define SCL_I2C_FMP_TIMING_HCNT		GENMASK(23, 16)
+#define SCL_I2C_FMP_TIMING_LCNT		GENMASK(15, 0)
 
 #define SCL_EXT_LCNT_TIMING		0xc8
 #define SCL_EXT_LCNT_4(x)		(((x) << 24) & GENMASK(31, 24))
@@ -243,11 +255,18 @@
 #define SCL_EXT_LCNT_1(x)		((x) & GENMASK(7, 0))
 
 #define SCL_EXT_TERMN_LCNT_TIMING	0xcc
+#define SDA_HOLD_SWITCH_DLY_TIMING	0xd0
+#define SDA_TX_HOLD			GENMASK(18, 16)
+#define   SDA_TX_HOLD_MIN		0b001
+#define   SDA_TX_HOLD_MAX		0b111
+#define SDA_PP_OD_SWITCH_DLY		GENMASK(10, 8)
+#define SDA_OD_PP_SWITCH_DLY		GENMASK(2, 0)
 #define BUS_FREE_TIMING			0xd4
 #define BUS_I3C_AVAILABLE_TIME(x)	(((x) << 16) & GENMASK(31, 16))
 #define BUS_I3C_MST_FREE(x)		((x) & GENMASK(15, 0))
 
 #define BUS_IDLE_TIMING			0xd8
+#define SCL_LOW_MST_EXT_TIMEOUT		0xdc
 #define I3C_VER_ID			0xe0
 #define I3C_VER_TYPE			0xe4
 #define EXTENDED_CAPABILITY		0xe8
@@ -276,18 +295,28 @@
 #define I3C_BUS_SDR2_SCL_RATE		6000000
 #define I3C_BUS_SDR3_SCL_RATE		4000000
 #define I3C_BUS_SDR4_SCL_RATE		2000000
+#define I3C_BUS_I2C_STD_TLOW_MIN_NS	4700
+#define I3C_BUS_I2C_STD_THIGH_MIN_NS	4000
+#define I3C_BUS_I2C_STD_TR_MAX_NS	1000
+#define I3C_BUS_I2C_STD_TF_MAX_NS	300
 #define I3C_BUS_I2C_FM_TLOW_MIN_NS	1300
 #define I3C_BUS_I2C_FM_THIGH_MIN_NS	600
+#define I3C_BUS_I2C_FM_TR_MAX_NS	300
+#define I3C_BUS_I2C_FM_TF_MAX_NS	300
 #define I3C_BUS_I2C_FMP_TLOW_MIN_NS	500
 #define I3C_BUS_I2C_FMP_THIGH_MIN_NS	260
+#define I3C_BUS_I2C_FMP_TR_MAX_NS	120
+#define I3C_BUS_I2C_FMP_TF_MAX_NS	120
+#define I3C_BUS_JESD403_PP_TLOW_MIN_NS	35
+#define I3C_BUS_JESD403_PP_THIGH_MIN_NS	35
+#define I3C_BUS_JESD403_PP_TR_MAX_NS	5
+#define I3C_BUS_JESD403_PP_TF_MAX_NS	5
 #define I3C_BUS_THIGH_MAX_NS		41
-#define I3C_BUS_JESD300_OP_TLOW_MIN_NS	500
-#define I3C_BUS_JESD300_OP_THIGH_MIN_NS	260
-#define I3C_BUS_JESD300_PP_TLOW_MIN_NS	35
-#define I3C_BUS_JESD300_PP_THIGH_MIN_NS	35
+
 #define I3C_BUS_EXT_TERMN_CNT		4
+#define JESD403_TIMED_RESET_NS_DEF	52428800
 
-#define XFER_TIMEOUT (msecs_to_jiffies(1000))
+#define XFER_TIMEOUT			(msecs_to_jiffies(1000))
 
 #define ast_setbits(x, set)		writel(readl(x) | (set), x)
 #define ast_clrsetbits(x, clr, set)	writel((readl(x) & ~(clr)) | (set), x)
@@ -363,6 +392,17 @@
 				 const struct i3c_slave_payload *payload);
 	} slave_data;
 	struct completion sir_complete;
+
+	struct {
+		unsigned long core_rate;
+		unsigned long core_period;
+		u32 i3c_od_scl_freq;
+		u32 i3c_od_scl_low;
+		u32 i3c_od_scl_high;
+		u32 i3c_pp_scl_freq;
+		u32 i3c_pp_scl_low;
+		u32 i3c_pp_scl_high;
+	} timing;
 };
 
 struct aspeed_i3c_i2c_dev_data {
@@ -436,6 +476,12 @@
 	       master->regs + DEVICE_CTRL);
 }
 
+static void aspeed_i3c_master_resume(struct aspeed_i3c_master *master)
+{
+	writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_RESUME,
+	       master->regs + DEVICE_CTRL);
+}
+
 static void aspeed_i3c_master_set_role(struct aspeed_i3c_master *master)
 {
 	u32 reg;
@@ -591,13 +637,13 @@
 	}
 }
 
-static inline void aspeed_i3c_master_read_rx_fifo(struct aspeed_i3c_master *master,
+static void aspeed_i3c_master_read_rx_fifo(struct aspeed_i3c_master *master,
 					      u8 *bytes, int nbytes)
 {
 	aspeed_i3c_master_read_fifo(master, RX_TX_DATA_PORT, bytes, nbytes);
 }
 
-static inline void aspeed_i3c_master_read_ibi_fifo(struct aspeed_i3c_master *master,
+static void aspeed_i3c_master_read_ibi_fifo(struct aspeed_i3c_master *master,
 					       u8 *bytes, int nbytes)
 {
 	aspeed_i3c_master_read_fifo(master, IBI_QUEUE_DATA, bytes, nbytes);
@@ -831,8 +877,7 @@
 
 	if (ret < 0) {
 		aspeed_i3c_master_dequeue_xfer_locked(master, xfer);
-		writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_RESUME,
-		       master->regs + DEVICE_CTRL);
+		aspeed_i3c_master_resume(master);
 	}
 
 	xfer = list_first_entry_or_null(&master->xferqueue.list,
@@ -852,7 +897,7 @@
 };
 
 static struct i3c_scl_timing_cfg jesd403_timing_cfg[5] = {
-	{ .fscl = I3C_BUS_TYP_I3C_SCL_RATE, .period_hi = 35, .period_lo = 45 },
+	{ .fscl = I3C_BUS_TYP_I3C_SCL_RATE, .period_hi = 40, .period_lo = 40 },
 	{ .fscl = I3C_BUS_SDR1_SCL_RATE, .period_hi = 50, .period_lo = 75 },
 	{ .fscl = I3C_BUS_SDR2_SCL_RATE, .period_hi = 65, .period_lo = 100 },
 	{ .fscl = I3C_BUS_SDR3_SCL_RATE, .period_hi = 100, .period_lo = 150 },
@@ -872,20 +917,63 @@
 	return &jesd403_timing_cfg[0];
 }
 
+static int calc_i2c_clk(struct aspeed_i3c_master *master, unsigned long fscl,
+			u16 *hcnt, u16 *lcnt)
+{
+	unsigned long core_rate, core_period;
+	u32 period_cnt, margin;
+	u32 hcnt_min, lcnt_min;
+
+	core_rate = master->timing.core_rate;
+	core_period = master->timing.core_period;
+
+	if (fscl <= 100000) {
+		lcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_STD_TLOW_MIN_NS +
+						I3C_BUS_I2C_STD_TF_MAX_NS,
+					core_period);
+		hcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_STD_THIGH_MIN_NS +
+						I3C_BUS_I2C_STD_TR_MAX_NS,
+					core_period);
+	} else if (fscl <= 400000) {
+		lcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FM_TLOW_MIN_NS +
+						I3C_BUS_I2C_FM_TF_MAX_NS,
+					core_period);
+		hcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FM_THIGH_MIN_NS +
+						I3C_BUS_I2C_FM_TR_MAX_NS,
+					core_period);
+	} else {
+		lcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FMP_TLOW_MIN_NS +
+						I3C_BUS_I2C_FMP_TF_MAX_NS,
+					core_period);
+		hcnt_min = DIV_ROUND_UP(I3C_BUS_I2C_FMP_THIGH_MIN_NS +
+						I3C_BUS_I2C_FMP_TR_MAX_NS,
+					core_period);
+	}
+
+	period_cnt = DIV_ROUND_UP(core_rate, fscl);
+	margin = (period_cnt - hcnt_min - lcnt_min) >> 1;
+	*lcnt = lcnt_min + margin;
+	*hcnt = max(period_cnt - *lcnt, hcnt_min);
+
+	return 0;
+}
+
 static int aspeed_i3c_clk_cfg(struct aspeed_i3c_master *master)
 {
 	unsigned long core_rate, core_period;
 	u32 scl_timing;
 	u16 hcnt, lcnt;
 
-	core_rate = clk_get_rate(master->core_clk);
-	if (!core_rate)
-		return -EINVAL;
-
-	core_period = DIV_ROUND_UP(1000000000, core_rate);
+	core_rate = master->timing.core_rate;
+	core_period = master->timing.core_period;
 
 	/* I3C PP mode */
-	if (master->base.jdec_spd) {
+	if (master->timing.i3c_pp_scl_high && master->timing.i3c_pp_scl_low) {
+		hcnt = DIV_ROUND_CLOSEST(master->timing.i3c_pp_scl_high,
+					 core_period);
+		lcnt = DIV_ROUND_CLOSEST(master->timing.i3c_pp_scl_low,
+					 core_period);
+	} else if (master->base.jdec_spd) {
 		struct i3c_scl_timing_cfg *pp_timing;
 
 		pp_timing = ast2600_i3c_jesd403_scl_search(
@@ -901,47 +989,69 @@
 		if (lcnt < SCL_I3C_TIMING_CNT_MIN)
 			lcnt = SCL_I3C_TIMING_CNT_MIN;
 	}
-	scl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);
+	hcnt = min_t(u16, hcnt, FIELD_MAX(SCL_I3C_TIMING_HCNT));
+	lcnt = min_t(u16, lcnt, FIELD_MAX(SCL_I3C_TIMING_LCNT));
+	scl_timing = FIELD_PREP(SCL_I3C_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I3C_TIMING_LCNT, lcnt);
 	writel(scl_timing, master->regs + SCL_I3C_PP_TIMING);
 
-	if (!(readl(master->regs + DEVICE_CTRL) & DEV_CTRL_I2C_SLAVE_PRESENT)) {
-		scl_timing = BUS_I3C_AVAILABLE_TIME(0xffff);
-		scl_timing |= BUS_I3C_MST_FREE(lcnt);
-		writel(scl_timing, master->regs + BUS_FREE_TIMING);
-	}
-
-	/* I2C FM+ mode */
-	lcnt = DIV_ROUND_UP(I3C_BUS_I2C_FMP_TLOW_MIN_NS, core_period);
-	hcnt = DIV_ROUND_UP(core_rate, I3C_BUS_I2C_FM_PLUS_SCL_RATE) - lcnt;
-	scl_timing = SCL_I2C_FMP_TIMING_HCNT(hcnt) | SCL_I2C_FMP_TIMING_LCNT(lcnt);
-	writel(scl_timing, master->regs + SCL_I2C_FMP_TIMING);
-
 	/* I3C OD mode:
-	 * JESD300-5 timing constrain for I2C/I3C OP mode
+	 * User defined
+	 *     check if hcnt/lcnt exceed the max value of the register
+	 *
+	 * JESD403 timing constrain for I2C/I3C OP mode
 	 *     tHIGH > 260, tLOW > 500 (same with MIPI 1.1 FMP constrain)
 	 *
 	 * MIPI 1.1 timing constrain for I3C OP mode
 	 *     tHIGH < 41, tLOW > 200
 	 */
-	if (master->base.jdec_spd) {
-		lcnt = lcnt > 0xff ? 0xff : lcnt;
-		hcnt = hcnt > 0xff ? 0xff : hcnt;
-		scl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);
+	if (master->timing.i3c_od_scl_high && master->timing.i3c_od_scl_low) {
+		hcnt = DIV_ROUND_CLOSEST(master->timing.i3c_od_scl_high,
+					 core_period);
+		lcnt = DIV_ROUND_CLOSEST(master->timing.i3c_od_scl_low,
+					 core_period);
+	} else if (master->base.jdec_spd) {
+		calc_i2c_clk(master, I3C_BUS_I2C_FM_PLUS_SCL_RATE, &hcnt, &lcnt);
 	} else {
 		lcnt = DIV_ROUND_UP(I3C_BUS_TLOW_OD_MIN_NS, core_period);
-		scl_timing = readl(master->regs + SCL_I3C_PP_TIMING) & ~GENMASK(7, 0);
-		scl_timing |= SCL_I3C_TIMING_LCNT(lcnt);
+		scl_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+		hcnt = FIELD_GET(SCL_I3C_TIMING_HCNT, scl_timing);
 	}
+	hcnt = min_t(u16, hcnt, FIELD_MAX(SCL_I3C_TIMING_HCNT));
+	lcnt = min_t(u16, lcnt, FIELD_MAX(SCL_I3C_TIMING_LCNT));
+	scl_timing = FIELD_PREP(SCL_I3C_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I3C_TIMING_LCNT, lcnt);
 	writel(scl_timing, master->regs + SCL_I3C_OD_TIMING);
 
 	/* I2C FM mode */
-	hcnt = DIV_ROUND_UP(I3C_BUS_I2C_FM_THIGH_MIN_NS, core_period);
-	lcnt = DIV_ROUND_UP(core_rate, I3C_BUS_I2C_FM_SCL_RATE) - hcnt;
-	if (lcnt * core_period < I3C_BUS_I2C_FM_TLOW_MIN_NS)
-		lcnt = DIV_ROUND_UP(I3C_BUS_I2C_FM_TLOW_MIN_NS, core_period);
-	scl_timing = SCL_I2C_FM_TIMING_HCNT(hcnt) | SCL_I2C_FM_TIMING_LCNT(lcnt);
+	calc_i2c_clk(master, master->base.bus.scl_rate.i2c, &hcnt, &lcnt);
+	scl_timing = FIELD_PREP(SCL_I2C_FM_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I2C_FM_TIMING_LCNT, lcnt);
 	writel(scl_timing, master->regs + SCL_I2C_FM_TIMING);
 
+	/*
+	 * I3C register 0xd4[15:0] BUS_FREE_TIMING used to control several parameters:
+	 * - tCAS & tCASr (tHD_STA in JESD403)
+	 * - tCBP & tCBPr (tSU_STO in JESD403)
+	 * - bus free time between a STOP condition and a START condition
+	 *
+	 * The constraints of these two parameters are different in different bus contexts
+	 * - MIPI I3C, mixed bus: 0xd4[15:0] = I2C SCL low period (handled in aspeed_i2c_clk_cfg)
+	 * - MIPI I3C, pure bus : 0xd4[15:0] = I3C SCL PP low period
+	 * - JESD403            : 0xd4[15:0] = I3C SCL OD low period
+	 */
+	if (!(readl(master->regs + DEVICE_CTRL) & DEV_CTRL_I2C_SLAVE_PRESENT)) {
+		if (master->base.jdec_spd)
+			scl_timing = readl(master->regs + SCL_I3C_OD_TIMING);
+		else
+			scl_timing = readl(master->regs + SCL_I3C_PP_TIMING);
+
+		lcnt = FIELD_GET(SCL_I3C_TIMING_LCNT, scl_timing);
+		scl_timing = BUS_I3C_AVAILABLE_TIME(0xffff);
+		scl_timing |= BUS_I3C_MST_FREE(lcnt);
+		writel(scl_timing, master->regs + BUS_FREE_TIMING);
+	}
+
 	/* Extend SDR: use PP mode hcnt */
 	scl_timing = readl(master->regs + SCL_I3C_PP_TIMING);
 	hcnt = scl_timing >> 16;
@@ -967,22 +1077,19 @@
 	u16 hcnt, lcnt;
 	u32 scl_timing;
 
-	core_rate = clk_get_rate(master->core_clk);
-	if (!core_rate)
-		return -EINVAL;
-
-	core_period = DIV_ROUND_UP(1000000000, core_rate);
+	core_rate = master->timing.core_rate;
+	core_period = master->timing.core_period;
 
-	lcnt = DIV_ROUND_UP(I3C_BUS_I2C_FMP_TLOW_MIN_NS, core_period);
-	hcnt = DIV_ROUND_UP(core_rate, I3C_BUS_I2C_FM_PLUS_SCL_RATE) - lcnt;
-	scl_timing = SCL_I2C_FMP_TIMING_HCNT(hcnt) |
-		     SCL_I2C_FMP_TIMING_LCNT(lcnt);
+	calc_i2c_clk(master, I3C_BUS_I2C_FM_PLUS_SCL_RATE, &hcnt, &lcnt);
+	hcnt = min_t(u16, hcnt, FIELD_MAX(SCL_I2C_FMP_TIMING_HCNT));
+	lcnt = min_t(u16, lcnt, FIELD_MAX(SCL_I2C_FMP_TIMING_LCNT));
+	scl_timing = FIELD_PREP(SCL_I2C_FMP_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I2C_FMP_TIMING_LCNT, lcnt);
 	writel(scl_timing, master->regs + SCL_I2C_FMP_TIMING);
 
-	lcnt = DIV_ROUND_UP(I3C_BUS_I2C_FM_TLOW_MIN_NS, core_period);
-	hcnt = DIV_ROUND_UP(core_rate, I3C_BUS_I2C_FM_SCL_RATE) - lcnt;
-	scl_timing = SCL_I2C_FM_TIMING_HCNT(hcnt) |
-		     SCL_I2C_FM_TIMING_LCNT(lcnt);
+	calc_i2c_clk(master, master->base.bus.scl_rate.i2c, &hcnt, &lcnt);
+	scl_timing = FIELD_PREP(SCL_I2C_FM_TIMING_HCNT, hcnt) |
+		     FIELD_PREP(SCL_I2C_FM_TIMING_LCNT, lcnt);
 	writel(scl_timing, master->regs + SCL_I2C_FM_TIMING);
 
 	scl_timing = BUS_I3C_AVAILABLE_TIME(0xffff);
@@ -1065,7 +1172,13 @@
 	writel(INTR_ALL, master->regs + INTR_STATUS);
 	if (master->secondary) {
 		writel(INTR_2ND_MASTER_MASK, master->regs + INTR_STATUS_EN);
-		writel(INTR_2ND_MASTER_MASK, master->regs + INTR_SIGNAL_EN);
+		/*
+		 * No need for INTR_IBI_UPDATED_STAT signal, check this bit
+		 * when INTR_RESP_READY_STAT signal is up.  This can guarantee
+		 * the SIR payload is ACKed by the master.
+		 */
+		writel(INTR_2ND_MASTER_MASK & ~INTR_IBI_UPDATED_STAT,
+		       master->regs + INTR_SIGNAL_EN);
 	} else {
 		writel(INTR_MASTER_MASK, master->regs + INTR_STATUS_EN);
 		writel(INTR_MASTER_MASK, master->regs + INTR_SIGNAL_EN);
@@ -1251,7 +1364,8 @@
 	else
 		ret = aspeed_i3c_ccc_set(master, ccc);
 
-	if ((ccc->id == I3C_CCC_SETAASA) || (ccc->id == I3C_CCC_SETHID))
+	if ((ccc->id == I3C_CCC_SETAASA) || (ccc->id == I3C_CCC_SETHID) ||
+	    (ccc->id == I3C_CCC_DEVCTRL))
 		writel(i3c_pp_timing, master->regs + SCL_I3C_PP_TIMING);
 
 	return ret;
@@ -1275,8 +1389,8 @@
 	if (IS_MANUF_ID_ASPEED(pid) &&
 	    (IS_PART_ID_AST2600_SERIES(pid) || IS_PART_ID_AST1030_A0(pid))) {
 		ret = i3c_master_setmrl_locked(
-			m, i3cdev->info.dyn_addr, CONFIG_ASPEED_I3C_MRL,
-			CONFIG_ASPEED_I3C_IBI_MAX_PAYLOAD);
+			m, i3cdev->info.dyn_addr, CONFIG_AST2600_I3C_MRL,
+			CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD);
 	}
 
 	return ret;
@@ -1595,7 +1709,7 @@
 	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
 	unsigned int nrxwords = 0, ntxwords = 0;
 	struct aspeed_i3c_xfer *xfer;
-	int speed, i, ret = 0;
+	int i, ret = 0;
 
 	if (!i2c_nxfers)
 		return 0;
@@ -1620,8 +1734,6 @@
 
 	data->index = aspeed_i3c_master_sync_hw_dat(master, dev->addr);
 
-	speed = (master->base.bus.scl_rate.i2c == I3C_BUS_I2C_FM_PLUS_SCL_RATE) ? 1 : 0;
-
 	for (i = 0; i < i2c_nxfers; i++) {
 		struct aspeed_i3c_cmd *cmd = &xfer->cmds[i];
 
@@ -1630,7 +1742,6 @@
 
 		cmd->cmd_lo = COMMAND_PORT_TID(i) |
 			      COMMAND_PORT_DEV_INDEX(data->index) |
-			      COMMAND_PORT_SPEED(speed) |
 			      COMMAND_PORT_ROC;
 
 		if (i2c_xfers[i].flags & I2C_M_RD) {
@@ -1644,6 +1755,11 @@
 
 		if (i == (i2c_nxfers - 1))
 			cmd->cmd_lo |= COMMAND_PORT_TOC;
+
+		dev_dbg(master->dev,
+			"%s:cmd_hi=0x%08x cmd_lo=0x%08x tx_len=%d rx_len=%d\n",
+			__func__, cmd->cmd_hi, cmd->cmd_lo, cmd->tx_len,
+			cmd->rx_len);
 	}
 
 	aspeed_i3c_master_enqueue_xfer(master, xfer);
@@ -1695,7 +1811,7 @@
 	kfree(data);
 }
 
-static void aspeed_i3c_master_slave_event_handler(struct aspeed_i3c_master *master)
+static void aspeed_i3c_slave_event_handler(struct aspeed_i3c_master *master)
 {
 	u32 event = readl(master->regs + SLV_EVENT_CTRL);
 	u32 cm_state =
@@ -1703,8 +1819,7 @@
 
 	if (cm_state == CM_ST_STS_HALT) {
 		dev_dbg(master->dev, "slave in halt state\n");
-		writel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_RESUME,
-		       master->regs + DEVICE_CTRL);
+		aspeed_i3c_master_resume(master);
 	}
 
 	dev_dbg(master->dev, "slave event=%08x\n", event);
@@ -1719,6 +1834,52 @@
 	writel(event, master->regs + SLV_EVENT_CTRL);
 }
 
+static void aspeed_i3c_slave_resp_handler(struct aspeed_i3c_master *master,
+					  u32 status)
+{
+	int i, has_error = 0;
+	u32 resp, nbytes, nresp;
+	u8 error, tid;
+	u32 *buf = master->slave_data.buf;
+	struct i3c_slave_payload payload;
+
+	nresp = readl(master->regs + QUEUE_STATUS_LEVEL);
+	nresp = QUEUE_STATUS_LEVEL_RESP(nresp);
+
+	for (i = 0; i < nresp; i++) {
+		resp = readl(master->regs + RESPONSE_QUEUE_PORT);
+		error = RESPONSE_PORT_ERR_STATUS(resp);
+		nbytes = RESPONSE_PORT_DATA_LEN(resp);
+		tid = RESPONSE_PORT_TID(resp);
+
+		if (error) {
+			has_error = 1;
+			if (error == RESPONSE_ERROR_EARLY_TERMINATE)
+				dev_dbg(master->dev,
+					"early termination, remain length %d\n",
+					nbytes);
+		}
+
+		if (!error && nbytes) {
+			aspeed_i3c_master_read_rx_fifo(master, (u8 *)buf, nbytes);
+
+			payload.len = nbytes;
+			payload.data = buf;
+			/* currently only support master write transfer */
+			if (master->slave_data.callback && (tid == TID_MASTER_WRITE_DATA))
+				master->slave_data.callback(&master->base, &payload);
+		}
+	}
+
+	if (status & INTR_IBI_UPDATED_STAT)
+		complete(&master->sir_complete);
+
+	if (has_error) {
+		writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+		aspeed_i3c_master_resume(master);
+	}
+}
+
 static irqreturn_t aspeed_i3c_master_irq_handler(int irq, void *dev_id)
 {
 	struct aspeed_i3c_master *master = dev_id;
@@ -1731,50 +1892,57 @@
 		return IRQ_NONE;
 	}
 
-	spin_lock(&master->xferqueue.lock);
-	if (!master->secondary)
-		aspeed_i3c_master_end_xfer_locked(master, status);
-	if (status & INTR_TRANSFER_ERR_STAT)
-		writel(INTR_TRANSFER_ERR_STAT, master->regs + INTR_STATUS);
-	spin_unlock(&master->xferqueue.lock);
+	if (master->secondary) {
+		if (status & INTR_READ_REQ_RECV_STAT)
+			dev_dbg(master->dev, "read queue received\n");
 
-	if (status & INTR_IBI_UPDATED_STAT)
-		complete(&master->sir_complete);
+		if (status & INTR_RESP_READY_STAT)
+			aspeed_i3c_slave_resp_handler(master, status);
 
-	if (master->secondary && (status & INTR_RESP_READY_STAT)) {
-		int i, j;
-		u32 resp, nbytes, nwords;
-		u32 nresp = QUEUE_STATUS_LEVEL_RESP(
-			readl(master->regs + QUEUE_STATUS_LEVEL));
-		u32 *buf = master->slave_data.buf;
-		struct i3c_slave_payload payload;
-
-		for (i = 0; i < nresp; i++) {
-			resp = readl(master->regs + RESPONSE_QUEUE_PORT);
-			nbytes = RESPONSE_PORT_DATA_LEN(resp);
-			nwords = (nbytes + 3) >> 2;
-			for (j = 0; j < nwords; j++)
-				buf[j] = readl(master->regs + RX_TX_DATA_PORT);
+		if (status & INTR_CCC_UPDATED_STAT)
+			aspeed_i3c_slave_event_handler(master);
+	} else {
+		spin_lock(&master->xferqueue.lock);
+		aspeed_i3c_master_end_xfer_locked(master, status);
+		if (status & INTR_TRANSFER_ERR_STAT)
+			writel(INTR_TRANSFER_ERR_STAT, master->regs + INTR_STATUS);
+		spin_unlock(&master->xferqueue.lock);
 
-			payload.len = nbytes;
-			payload.data = buf;
-			if (master->slave_data.callback)
-				master->slave_data.callback(&master->base,
-							    &payload);
-		}
+		if (status & INTR_IBI_THLD_STAT)
+			aspeed_i3c_master_demux_ibis(master);
 	}
 
-	if (status & INTR_IBI_THLD_STAT)
-		aspeed_i3c_master_demux_ibis(master);
-
-	if (status & INTR_CCC_UPDATED_STAT)
-		aspeed_i3c_master_slave_event_handler(master);
-
 	writel(status, master->regs + INTR_STATUS);
 
 	return IRQ_HANDLED;
 }
 
+static void aspeed_i3c_master_enable_ibi_irq(struct aspeed_i3c_master *master)
+{
+	u32 reg;
+
+	reg = readl(master->regs + INTR_STATUS_EN);
+	reg |= INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_STATUS_EN);
+
+	reg = readl(master->regs + INTR_SIGNAL_EN);
+	reg |= INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_SIGNAL_EN);
+}
+
+static void aspeed_i3c_master_disable_ibi_irq(struct aspeed_i3c_master *master)
+{
+	u32 reg;
+
+	reg = readl(master->regs + INTR_STATUS_EN);
+	reg &= ~INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_STATUS_EN);
+
+	reg = readl(master->regs + INTR_SIGNAL_EN);
+	reg &= ~INTR_IBI_THLD_STAT;
+	writel(reg, master->regs + INTR_SIGNAL_EN);
+}
+
 static int aspeed_i3c_master_disable_ibi(struct i3c_dev_desc *dev)
 {
 	struct i3c_master_controller *m = i3c_dev_get_master(dev);
@@ -1819,6 +1987,13 @@
 		dev_grp->mask.set &= ~DEV_ADDR_TABLE_IBI_WITH_DATA;
 		dev_grp->mask.set |= DEV_ADDR_TABLE_SIR_REJECT;
 	}
+
+	sirmap = readl(master->regs + IBI_SIR_REQ_REJECT);
+	if (sirmap == IBI_REQ_REJECT_ALL)
+		aspeed_i3c_master_disable_ibi_irq(master);
+	else
+		aspeed_i3c_master_enable_ibi_irq(master);
+
 	spin_unlock_irqrestore(&master->ibi.lock, flags);
 
 	return ret;
@@ -1842,6 +2017,8 @@
 
 	dev_grp->mask.clr |= DEV_ADDR_TABLE_SIR_REJECT;
 	dev_grp->mask.set &= ~DEV_ADDR_TABLE_SIR_REJECT;
+	if (IS_MANUF_ID_ASPEED(dev->info.pid))
+		dev_grp->mask.set |= DEV_ADDR_TABLE_IBI_PEC_EN;
 	if (dev->info.bcr & I3C_BCR_IBI_PAYLOAD)
 		dev_grp->mask.set |= DEV_ADDR_TABLE_IBI_WITH_DATA;
 
@@ -1870,6 +2047,12 @@
 		spin_unlock_irqrestore(&master->ibi.lock, flags);
 	}
 
+	sirmap = readl(master->regs + IBI_SIR_REQ_REJECT);
+	if (sirmap == IBI_REQ_REJECT_ALL)
+		aspeed_i3c_master_disable_ibi_irq(master);
+	else
+		aspeed_i3c_master_enable_ibi_irq(master);
+
 	return ret;
 }
 
@@ -1950,42 +2133,56 @@
 	return 0;
 }
 
-static int aspeed_i3c_maser_send_sir(struct i3c_master_controller *m,
-				 struct i3c_slave_payload *payload)
+static int aspeed_i3c_master_send_sir(struct i3c_master_controller *m,
+				      struct i3c_slave_payload *payload)
 {
 	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
-	uint32_t slv_event, intr_req, act_len;
-	void *buf;
+	uint32_t slv_event, intr_req, reg, thld_ctrl;
+	uint8_t *data = (uint8_t *)payload->data;
 
 	slv_event = readl(master->regs + SLV_EVENT_CTRL);
 	if ((slv_event & SLV_EVENT_CTRL_SIR_EN) == 0)
 		return -EPERM;
 
-	buf = kzalloc(CONFIG_ASPEED_I3C_IBI_MAX_PAYLOAD, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
+	if (!payload)
+		return -ENXIO;
+
+	if (payload->len > (CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD + 1)) {
+		dev_err(master->dev,
+			"input length %d exceeds max ibi payload size %d\n",
+			payload->len, CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD + 1);
+		return -E2BIG;
+	}
 
-	memcpy(buf, payload->data, payload->len);
 	init_completion(&master->sir_complete);
 
-	act_len = payload->len;
-	/*
-	 * AST2600 HW does not export the max ibi payload length to the
-	 * software interface, so we can only send fixed length SIR.
-	 *
-	 * Another consideration is if the bus main master is AST2600,
-	 * it cannot receive IBI with data length (4n + 1) including the
-	 * MDB.  Which means the length of the user payload must not be
-	 * 4n bytes.  Thus we pad 3 bytes for workaround.
-	 */
-	act_len = CONFIG_ASPEED_I3C_IBI_MAX_PAYLOAD;
-	if ((act_len & 0x3) == 0x0)
-		act_len += 3;
+	reg = readl(master->regs + DEVICE_CTRL);
+	reg &= ~DEV_CTRL_SLAVE_MDB;
+	reg |= FIELD_PREP(DEV_CTRL_SLAVE_MDB, data[0]) |
+	       FIELD_PREP(DEV_CTRL_SLAVE_PEC_EN, 1);
+	writel(reg, master->regs + DEVICE_CTRL);
+
+	aspeed_i3c_master_wr_tx_fifo(master, data, payload->len);
+
+	reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, payload->len);
+	writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+	thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+	thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+	thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(1);
+	writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
 
-	aspeed_i3c_master_wr_tx_fifo(master, buf, act_len);
 	writel(1, master->regs + SLV_INTR_REQ);
-	wait_for_completion(&master->sir_complete);
-	kfree(buf);
+	if (!wait_for_completion_timeout(&master->sir_complete, XFER_TIMEOUT)) {
+		dev_err(master->dev, "send sir timeout\n");
+		writel(RESET_CTRL_RX_FIFO | RESET_CTRL_TX_FIFO |
+			       RESET_CTRL_RESP_QUEUE | RESET_CTRL_CMD_QUEUE,
+		       master->regs + RESET_CTRL);
+	}
+
+	reg = readl(master->regs + DEVICE_CTRL);
+	reg &= ~DEV_CTRL_SLAVE_PEC_EN;
+	writel(reg, master->regs + DEVICE_CTRL);
 
 	intr_req = readl(master->regs + SLV_INTR_REQ);
 	if (SLV_INTR_REQ_IBI_STS(intr_req) != SLV_IBI_STS_OK) {
@@ -1998,6 +2195,115 @@
 	return 0;
 }
 
+static int aspeed_i3c_master_put_read_data(struct i3c_master_controller *m,
+					   struct i3c_slave_payload *data,
+					   struct i3c_slave_payload *ibi_notify)
+{
+	struct aspeed_i3c_master *master = to_aspeed_i3c_master(m);
+	u32 reg, thld_ctrl;
+	u8 *buf;
+
+	if (!data)
+		return -ENXIO;
+
+	if (ibi_notify) {
+		buf = (u8 *)ibi_notify->data;
+		init_completion(&master->sir_complete);
+
+		reg = readl(master->regs + DEVICE_CTRL);
+		reg &= ~DEV_CTRL_SLAVE_MDB;
+		reg |= FIELD_PREP(DEV_CTRL_SLAVE_MDB, buf[0]) |
+		       FIELD_PREP(DEV_CTRL_SLAVE_PEC_EN, 1);
+		writel(reg, master->regs + DEVICE_CTRL);
+
+		aspeed_i3c_master_wr_tx_fifo(master, buf, ibi_notify->len);
+
+		reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, ibi_notify->len);
+		writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+		thld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);
+		thld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;
+		thld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(1);
+		writel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);
+	}
+
+	buf = (u8 *)data->data;
+	aspeed_i3c_master_wr_tx_fifo(master, buf, data->len);
+
+	reg = FIELD_PREP(COMMAND_PORT_SLAVE_DATA_LEN, data->len);
+	writel(reg, master->regs + COMMAND_QUEUE_PORT);
+
+	if (ibi_notify) {
+		writel(1, master->regs + SLV_INTR_REQ);
+		if (!wait_for_completion_timeout(&master->sir_complete,
+						 XFER_TIMEOUT)) {
+			dev_err(master->dev, "send sir timeout\n");
+			writel(RESET_CTRL_QUEUES, master->regs + RESET_CTRL);
+		}
+
+		reg = readl(master->regs + DEVICE_CTRL);
+		reg &= ~DEV_CTRL_SLAVE_PEC_EN;
+		writel(reg, master->regs + DEVICE_CTRL);
+	}
+
+	return 0;
+}
+
+static int aspeed_i3c_master_timing_config(struct aspeed_i3c_master *master,
+					   struct device_node *np)
+{
+	u32 val, reg;
+	u32 timed_reset_scl_low_ns;
+	u32 sda_tx_hold_ns;
+
+	master->timing.core_rate = clk_get_rate(master->core_clk);
+	if (!master->timing.core_rate) {
+		dev_err(master->dev, "core clock rate not found\n");
+		return -EINVAL;
+	}
+
+	/* core_period is in nanosecond */
+	master->timing.core_period =
+		DIV_ROUND_UP(1000000000, master->timing.core_rate);
+
+	/* setup default timing configuration */
+	sda_tx_hold_ns = SDA_TX_HOLD_MIN * master->timing.core_period;
+	timed_reset_scl_low_ns = JESD403_TIMED_RESET_NS_DEF;
+
+	/* parse configurations from DT */
+	if (!of_property_read_u32(np, "i3c-pp-scl-hi-period-ns", &val))
+		master->timing.i3c_pp_scl_high = val;
+
+	if (!of_property_read_u32(np, "i3c-pp-scl-lo-period-ns", &val))
+		master->timing.i3c_pp_scl_low = val;
+
+	if (!of_property_read_u32(np, "i3c-od-scl-hi-period-ns", &val))
+		master->timing.i3c_od_scl_high = val;
+
+	if (!of_property_read_u32(np, "i3c-od-scl-lo-period-ns", &val))
+		master->timing.i3c_od_scl_low = val;
+
+	if (!of_property_read_u32(np, "sda-tx-hold-ns", &val))
+		sda_tx_hold_ns = val;
+
+	if (!of_property_read_u32(np, "timed-reset-scl-low-ns", &val))
+		timed_reset_scl_low_ns = val;
+
+	val = clamp((u32)DIV_ROUND_CLOSEST(sda_tx_hold_ns,
+					   master->timing.core_period),
+		    (u32)SDA_TX_HOLD_MIN, (u32)SDA_TX_HOLD_MAX);
+	reg = readl(master->regs + SDA_HOLD_SWITCH_DLY_TIMING);
+	reg &= ~SDA_TX_HOLD;
+	reg |= FIELD_PREP(SDA_TX_HOLD, val);
+	writel(reg, master->regs + SDA_HOLD_SWITCH_DLY_TIMING);
+
+	val = DIV_ROUND_CLOSEST(timed_reset_scl_low_ns,
+				master->timing.core_period);
+	writel(val, master->regs + SCL_LOW_MST_EXT_TIMEOUT);
+
+	return 0;
+}
+
 static const struct i3c_master_controller_ops aspeed_i3c_ops = {
 	.bus_init = aspeed_i3c_master_bus_init,
 	.bus_cleanup = aspeed_i3c_master_bus_cleanup,
@@ -2019,7 +2325,8 @@
 	.recycle_ibi_slot = aspeed_i3c_master_recycle_ibi_slot,
 	.register_slave = aspeed_i3c_master_register_slave,
 	.unregister_slave = aspeed_i3c_master_unregister_slave,
-	.send_sir = aspeed_i3c_maser_send_sir,
+	.send_sir = aspeed_i3c_master_send_sir,
+	.put_read_data = aspeed_i3c_master_put_read_data,
 };
 
 static int aspeed_i3c_probe(struct platform_device *pdev)
@@ -2075,6 +2382,10 @@
 	else
 		master->secondary = false;
 
+	ret = aspeed_i3c_master_timing_config(master, np);
+	if (ret)
+		goto err_assert_rst;
+
 	/* Information regarding the FIFOs/QUEUEs depth */
 	ret = readl(master->regs + QUEUE_STATUS_LEVEL);
 	master->caps.cmdfifodepth = QUEUE_STATUS_LEVEL_CMD(ret);
diff -Naur  linux_org/drivers/i3c/master/dw-i3c-master.c linux/drivers/i3c/master/dw-i3c-master.c
--- linux_org/drivers/i3c/master/dw-i3c-master.c	2022-07-25 16:14:52.482804126 +0800
+++ linux/drivers/i3c/master/dw-i3c-master.c	2022-08-05 11:32:13.302921757 +0800
@@ -962,7 +962,7 @@
 	return 0;
 }
 
-static void aspeed_i3c_master_set_info(struct dw_i3c_master *master,
+static int aspeed_i3c_master_set_info(struct dw_i3c_master *master,
 				       struct i3c_device_info *info)
 {
 #define ASPEED_SCU_REV_ID_REG 0x14
@@ -974,7 +974,11 @@
 
 	writel(PID_MANUF_ID_ASPEED << 1, master->regs + SLV_MIPI_PID_VALUE);
 
-	scu = syscon_regmap_lookup_by_compatible("aspeed,aspeed-scu");
+	scu = syscon_regmap_lookup_by_phandle(master->dev->of_node, "aspeed,scu");
+	if (IS_ERR(scu)) {
+		dev_err(master->dev, "cannot to find SCU regmap\n");
+		return -ENODEV;
+	}
 	regmap_read(scu, ASPEED_SCU_REV_ID_REG, &reg);
 	part_id = ASPEED_HW_REV(reg);
 	inst_id = master->base.bus.id;
@@ -988,6 +992,8 @@
 	info->bcr = SLV_CHAR_GET_BCR(reg);
 	info->pid = (u64)readl(master->regs + SLV_MIPI_PID_VALUE) << 32;
 	info->pid |= readl(master->regs + SLV_PID_VALUE);
+
+	return 0;
 };
 
 static int dw_i3c_master_bus_init(struct i3c_master_controller *m)
@@ -1034,8 +1040,11 @@
 	}
 
 	memset(&info, 0, sizeof(info));
-	if (master->is_aspeed)
-		aspeed_i3c_master_set_info(master, &info);
+	if (master->is_aspeed) {
+		ret = aspeed_i3c_master_set_info(master, &info);
+		if (ret < 0)
+			return ret;
+	}
 
 	ret = i3c_master_get_free_addr(m, 0);
 	if (ret < 0)
@@ -1227,8 +1236,8 @@
 	if (IS_MANUF_ID_ASPEED(pid) &&
 	    (IS_PART_ID_AST2600_SERIES(pid) || IS_PART_ID_AST1030_A0(pid))) {
 		ret = i3c_master_setmrl_locked(
-			m, i3cdev->info.dyn_addr, CONFIG_ASPEED_I3C_MRL,
-			CONFIG_ASPEED_I3C_IBI_MAX_PAYLOAD);
+			m, i3cdev->info.dyn_addr, CONFIG_AST2600_I3C_MRL,
+			CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD);
 	}
 
 	return ret;
@@ -1932,7 +1941,7 @@
 	if ((slv_event & SLV_EVENT_CTRL_SIR_EN) == 0)
 		return -EPERM;
 
-	buf = kzalloc(CONFIG_ASPEED_I3C_IBI_MAX_PAYLOAD, GFP_KERNEL);
+	buf = kzalloc(CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
@@ -1950,7 +1959,7 @@
 		 * MDB.  Which means the length of the user payload must not be
 		 * 4n bytes.  Thus we pad 3 bytes for workaround.
 		 */
-		act_len = CONFIG_ASPEED_I3C_IBI_MAX_PAYLOAD;
+		act_len = CONFIG_AST2600_I3C_IBI_MAX_PAYLOAD;
 		if ((act_len & 0x3) == 0x0)
 			act_len += 3;
 	}
diff -Naur  linux_org/drivers/i3c/master/Kconfig linux/drivers/i3c/master/Kconfig
--- linux_org/drivers/i3c/master/Kconfig	2022-07-25 16:14:55.330763524 +0800
+++ linux/drivers/i3c/master/Kconfig	2022-08-03 21:59:42.882723317 +0800
@@ -22,23 +22,26 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called dw-i3c-master.
 
-config ASPEED_I3C_MASTER
-	tristate "Aspeed I3C master driver"
+config AST2600_I3C_MASTER
+	tristate "Aspeed AST2600 I3C master driver"
 	depends on I3C
+	depends on HAS_IOMEM
 	depends on MACH_ASPEED_G6
-	select DW_I3C_MASTER
 	help
-	  Aspeed I3C master controller is a Synopsys DesignWare I3C controller
-	  plus additional global control.
+	  Support for Aspeed AST2600 MIPI I3C Controller.
 
-if ASPEED_I3C_MASTER
-config ASPEED_I3C_IBI_MAX_PAYLOAD
+	  This driver can also be built as a module.  If so, the module
+	  will be called ast2600-i3c-master.
+
+if AST2600_I3C_MASTER
+config AST2600_I3C_IBI_MAX_PAYLOAD
 	int "Max IBI payload size"
 	default 255
 
-config ASPEED_I3C_MRL
+config AST2600_I3C_MRL
 	int "Max read length"
 	default 256
+
 config AST2600_I3C_CCC_WORKAROUND
 	bool "Workaround for AST2600A1 errata item#30"
 	default n
diff -Naur  linux_org/drivers/i3c/master/Makefile linux/drivers/i3c/master/Makefile
--- linux_org/drivers/i3c/master/Makefile	2022-07-25 16:14:55.330763524 +0800
+++ linux/drivers/i3c/master/Makefile	2022-08-03 21:59:42.882723317 +0800
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
 obj-$(CONFIG_CDNS_I3C_MASTER)		+= i3c-master-cdns.o
 obj-$(CONFIG_DW_I3C_MASTER)		+= dw-i3c-master.o
-obj-$(CONFIG_ASPEED_I3C_MASTER)		+= ast2600-i3c-global.o ast2600-i3c-master.o
+obj-$(CONFIG_AST2600_I3C_MASTER)	+= ast2600-i3c-global.o ast2600-i3c-master.o
diff -Naur  linux_org/drivers/i3c/master.c linux/drivers/i3c/master.c
--- linux_org/drivers/i3c/master.c	2022-07-25 16:14:55.330763524 +0800
+++ linux/drivers/i3c/master.c	2022-08-03 21:59:43.090720751 +0800
@@ -1317,7 +1317,7 @@
 	    slot_status == I3C_ADDR_SLOT_I2C_DEV)
 		return -EINVAL;
 
-	if (master->jdec_spd) {
+	if (master->jdec_spd && dev->boardinfo) {
 		dev->info.pid = dev->boardinfo->pid;
 		dev->info.dcr = dev->boardinfo->dcr;
 		dev->info.bcr = dev->boardinfo->bcr;
@@ -1627,14 +1627,9 @@
 {
 	int ret;
 
-	if (master->jdec_spd) {
-		ret = i3c_master_sethid_locked(master);
-		ret = i3c_master_setaasa_locked(master);
-	} else {
-		i3c_bus_maintenance_lock(&master->bus);
-		ret = master->ops->do_daa(master);
-		i3c_bus_maintenance_unlock(&master->bus);
-	}
+	i3c_bus_maintenance_lock(&master->bus);
+	ret = master->ops->do_daa(master);
+	i3c_bus_maintenance_unlock(&master->bus);
 
 	if (ret)
 		return ret;
@@ -1891,6 +1886,18 @@
 	if (master->jdec_spd && master->bus.mode != I3C_BUS_MODE_PURE)
 		return 0;
 
+	if (master->jdec_spd) {
+		i3c_bus_maintenance_lock(&master->bus);
+		i3c_master_sethid_locked(master);
+		i3c_master_setaasa_locked(master);
+		i3c_bus_maintenance_unlock(&master->bus);
+
+		i3c_bus_normaluse_lock(&master->bus);
+		i3c_master_register_new_i3c_devs(master);
+		i3c_bus_normaluse_unlock(&master->bus);
+		return 0;
+	}
+
 	ret = i3c_master_do_daa(master);
 	if (ret)
 		dev_dbg(&master->dev,
@@ -2697,6 +2704,11 @@
 	if (master->secondary)
 		i3c_slave_mqueue_probe(master);
 #endif
+
+#ifdef CONFIG_I3C_SLAVE_EEPROM
+	if (master->secondary)
+		i3c_slave_eeprom_probe(master);
+#endif
 	i3c_bus_normaluse_unlock(&master->bus);
 
 	return 0;
@@ -2884,10 +2896,32 @@
 int i3c_master_send_sir(struct i3c_master_controller *master,
 			struct i3c_slave_payload *payload)
 {
+	int ret;
+
 	if (!master->ops->send_sir)
 		return -ENOTSUPP;
 
-	return master->ops->send_sir(master, payload);
+	i3c_bus_normaluse_lock(&master->bus);
+	ret = master->ops->send_sir(master, payload);
+	i3c_bus_normaluse_unlock(&master->bus);
+
+	return ret;
+}
+
+int i3c_master_put_read_data(struct i3c_master_controller *master,
+			     struct i3c_slave_payload *data,
+			     struct i3c_slave_payload *ibi_notify)
+{
+	int ret;
+
+	if (!master->ops->put_read_data)
+		return -ENOTSUPP;
+
+	i3c_bus_normaluse_lock(&master->bus);
+	ret = master->ops->put_read_data(master, data, ibi_notify);
+	i3c_bus_normaluse_unlock(&master->bus);
+
+	return ret;
 }
 
 int i3c_for_each_dev(void *data, int (*fn)(struct device *, void *))
diff -Naur  linux_org/include/linux/bitfield.h linux/include/linux/bitfield.h
--- linux_org/include/linux/bitfield.h	2022-03-11 18:22:39.000000000 +0800
+++ linux/include/linux/bitfield.h	2022-08-05 11:32:13.314921607 +0800
@@ -56,6 +56,19 @@
 	})
 
 /**
+ * FIELD_MAX() - produce the maximum value representable by a field
+ * @_mask: shifted mask defining the field's length and position
+ *
+ * FIELD_MAX() returns the maximum value that can be held in the field
+ * specified by @_mask.
+ */
+#define FIELD_MAX(_mask)						\
+	({								\
+		__BF_FIELD_CHECK(_mask, 0ULL, 0ULL, "FIELD_MAX: ");	\
+		(typeof(_mask))((_mask) >> __bf_shf(_mask));		\
+	})
+
+/**
  * FIELD_FIT() - check if value fits in the field
  * @_mask: shifted mask defining the field's length and position
  * @_val:  value to test against the field
@@ -110,6 +123,7 @@
 {
 	return field / field_multiplier(field);
 }
+#define field_max(field)	((typeof(field))field_mask(field))
 #define ____MAKE_OP(type,base,to,from)					\
 static __always_inline __##type type##_encode_bits(base v, base field)	\
 {									\
diff -Naur  linux_org/include/linux/i3c/master.h linux/include/linux/i3c/master.h
--- linux_org/include/linux/i3c/master.h	2022-07-25 16:14:55.330763524 +0800
+++ linux/include/linux/i3c/master.h	2022-08-03 21:59:43.090720751 +0800
@@ -462,6 +462,9 @@
 	int (*unregister_slave)(struct i3c_master_controller *master);
 	int (*send_sir)(struct i3c_master_controller *master,
 			struct i3c_slave_payload *payload);
+	int (*put_read_data)(struct i3c_master_controller *master,
+			     struct i3c_slave_payload *data,
+			     struct i3c_slave_payload *ibi_notify);
 };
 
 /**
@@ -683,6 +686,15 @@
 int i3c_master_unregister_slave(struct i3c_master_controller *master);
 int i3c_master_send_sir(struct i3c_master_controller *master,
 			struct i3c_slave_payload *payload);
+/**
+ * i3c_master_put_read_data() - put read data and optionally notify primary master
+ * @master: master object in slave mode
+ * @data: data structure to be read
+ * @ibi_notify: IBI data (including MDB) to notify primary master device
+ */
+int i3c_master_put_read_data(struct i3c_master_controller *master,
+			     struct i3c_slave_payload *data,
+			     struct i3c_slave_payload *ibi_notify);
 /*
  * Slave message queue driver API
  */
@@ -690,4 +702,9 @@
 int i3c_slave_mqueue_probe(struct i3c_master_controller *master);
 int i3c_slave_mqueue_remove(struct i3c_master_controller *master);
 #endif
+
+#ifdef CONFIG_I3C_SLAVE_EEPROM
+int i3c_slave_eeprom_probe(struct i3c_master_controller *master);
+int i3c_slave_eeprom_remove(struct i3c_master_controller *master);
+#endif
 #endif /* I3C_MASTER_H */
