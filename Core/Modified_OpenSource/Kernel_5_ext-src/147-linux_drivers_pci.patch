diff -Naur ori_linux/include/linux/aspeed_pcie_io.h linux/include/linux/aspeed_pcie_io.h
--- ori_linux/include/linux/aspeed_pcie_io.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/linux/aspeed_pcie_io.h	2022-03-17 23:14:01.000000000 +0800
@@ -0,0 +1,19 @@
+/*
+ * arch/arm/mach-ixp4xx/include/mach/io.h
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright (C) 2002-2005  MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARM_ARCH_IO_H
+#define __ASM_ARM_ARCH_IO_H
+
+extern u8 aspeed_pcie_inb(u32 addr);
+extern void aspeed_pcie_outb(u8 value, u32 addr);
+
+#endif /* __ASM_ARM_ARCH_IO_H */
diff -Naur ori_linux/drivers/pci/controller/aspeed-h2x.c linux/drivers/pci/controller/aspeed-h2x.c
--- ori_linux/drivers/pci/controller/aspeed-h2x.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/pci/controller/aspeed-h2x.c	2022-03-17 23:14:01.000000000 +0800
@@ -0,0 +1,594 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * H2X driver for the Aspeed SoC
+ *
+ */
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/of_irq.h>
+#include <linux/of_pci.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/reset.h>
+#include <asm/io.h>
+
+#include <linux/aspeed_pcie_io.h>
+
+#include "h2x-ast2600.h"
+#include "../pci.h"
+
+#ifdef CONFIG_HOTPLUG_PCI
+static int hotplug_event;
+module_param(hotplug_event, int, 0644);
+MODULE_PARM_DESC(hotplug_event, "Using sw flag mechanism for hot-plug events or not");
+#endif
+
+/* reg 0x24 */
+#define PCIE_TX_IDLE			BIT(31)
+
+#define PCIE_STATUS_OF_TX		GENMASK(25, 24)
+#define	PCIE_RC_TX_COMPLETE		0
+#define	PCIE_RC_L_TX_COMPLETE	BIT(24)
+#define	PCIE_RC_H_TX_COMPLETE	BIT(25)
+
+#define PCIE_TRIGGER_TX			BIT(0)
+
+/* reg 0x80, 0xC0 */
+#define PCIE_RX_TAG_MASK		GENMASK(23, 16)
+#define PCIE_RX_DMA_EN			BIT(9)
+#define PCIE_RX_LINEAR			BIT(8)
+#define PCIE_RX_MSI_SEL			BIT(7)
+#define PCIE_RX_MSI_EN			BIT(6)
+#define PCIE_1M_ADDRESS_EN		BIT(5)
+#define PCIE_UNLOCK_RX_BUFF		BIT(4)
+#define PCIE_RX_TLP_TAG_MATCH	BIT(3)
+#define PCIE_Wait_RX_TLP_CLR	BIT(2)
+#define PCIE_RC_RX_ENABLE		BIT(1)
+#define PCIE_RC_ENABLE			BIT(0)
+
+/* reg 0x88, 0xC8 : RC ISR */
+#define PCIE_RC_CPLCA_ISR		BIT(6)
+#define PCIE_RC_CPLUR_ISR		BIT(5)
+#define PCIE_RC_RX_DONE_ISR		BIT(4)
+
+#define PCIE_RC_INTD_ISR		BIT(3)
+#define PCIE_RC_INTC_ISR		BIT(2)
+#define PCIE_RC_INTB_ISR		BIT(1)
+#define PCIE_RC_INTA_ISR		BIT(0)
+
+struct aspeed_h2x_info {
+	void __iomem *reg_base;
+	int irq;
+	u8 txTag;
+	struct reset_control *reset;
+};
+
+struct aspeed_h2x_info *aspeed_h2x;
+
+extern u8 aspeed_pcie_inb(u32 addr)
+{
+	int timeout = 0;
+	void __iomem *pcie_rc_base = aspeed_h2x->reg_base + 0xc0;
+	
+	printk("aspeed_pcie_inb addr %x \n", addr);
+	writel(BIT(4) | readl(pcie_rc_base), pcie_rc_base);
+
+	writel(0x02000001, aspeed_h2x->reg_base + 0x10);
+	writel(0x00002000 | (0x1 << (addr & 0x3)), aspeed_h2x->reg_base + 0x14);
+	writel(addr & (~0x3), aspeed_h2x->reg_base + 0x18);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x1c);
+
+	//trigger
+	writel((readl(aspeed_h2x->reg_base + 0x24) & 0xf) | PCIE_TRIGGER_TX, aspeed_h2x->reg_base + 0x24); 	
+
+	//wait tx idle
+	while(!(readl(aspeed_h2x->reg_base + 0x24) & PCIE_TX_IDLE)) {
+		timeout++;
+		if(timeout > 10000) {
+			printk("aspeed_pcie_inb timeout\n");
+			return 0xff;
+		}
+	};
+
+	//write clr tx idle
+	writel(1, aspeed_h2x->reg_base + 0x08);
+
+	timeout = 0;
+
+	while(!(readl(pcie_rc_base + 0x08) & PCIE_RC_RX_DONE_ISR)) {
+		timeout++;
+		if(timeout > 10) {
+			break;
+		}
+		mdelay(1);
+	}
+	writel(readl(pcie_rc_base + 0x08), pcie_rc_base + 0x08);
+//	writel(BIT(4) | readl(pcie_rc_base), pcie_rc_base);
+	return ((readl(pcie_rc_base + 0x0C) >> ((addr & 0x3) * 8)) & 0xff);
+
+}
+
+EXPORT_SYMBOL_GPL(aspeed_pcie_inb);
+
+extern void aspeed_pcie_outb(u8 value, u32 addr)
+{
+	int timeout = 0;
+	u32 wvalue = value;
+	void __iomem *pcie_rc_base = aspeed_h2x->reg_base + 0xc0;
+	printk("aspeed_pcie_outb addr %x \n", addr);
+
+	writel(BIT(4) | readl(pcie_rc_base), pcie_rc_base);
+
+	writel(0x42000001, aspeed_h2x->reg_base + 0x10);
+	writel(0x00002000 | (0x1 << (addr & 0x3)), aspeed_h2x->reg_base + 0x14);
+	writel(addr & (~0x3), aspeed_h2x->reg_base + 0x18);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x1c);
+
+	writel((wvalue << (8 * (addr & 0x3))), aspeed_h2x->reg_base + 0x20);
+
+	//trigger
+	writel((readl(aspeed_h2x->reg_base + 0x24) & 0xf) | PCIE_TRIGGER_TX, aspeed_h2x->reg_base + 0x24); 		
+
+	//wait tx idle
+	while(!(readl(aspeed_h2x->reg_base + 0x24) & PCIE_TX_IDLE)) {
+		timeout++;
+		if(timeout > 10000) {
+			printk("aspeed_pcie_outb timeout\n");
+			return;
+		}
+	};
+
+	//write clr tx idle
+	writel(1, aspeed_h2x->reg_base + 0x08);
+
+	while(!(readl(pcie_rc_base + 0x08) & PCIE_RC_RX_DONE_ISR));
+	writel(readl(pcie_rc_base + 0x08), pcie_rc_base + 0x08);
+	writel(BIT(4) | readl(pcie_rc_base), pcie_rc_base);
+	
+}
+
+EXPORT_SYMBOL_GPL(aspeed_pcie_outb);
+
+extern int aspeed_h2x_rd_conf(struct pci_bus *bus, unsigned int devfn, 
+				int where, int size, u32 *val)
+{
+	struct aspeed_pcie *pcie = bus->sysdata;
+	u32 timeout = 0;
+	u32 bdf_offset;
+	int rx_done_fail = 0;	
+	u32 type = 0;
+
+	//H2X80[4] (unlock) is write-only.
+	//Driver may set H2X80[4]=1 before triggering next TX config.
+	writel(BIT(4) | readl(pcie->h2x_rc_base), pcie->h2x_rc_base);
+
+	if(bus->number)
+		type = 1;
+	else
+		type = 0;
+
+	bdf_offset = (bus->number << 24) |
+					(PCI_SLOT(devfn) << 19) |
+					(PCI_FUNC(devfn) << 16) |
+					(where & ~3);
+
+	aspeed_h2x->txTag %= 0x7;
+
+	writel(0x04000001 | (type << 24), aspeed_h2x->reg_base + 0x10);
+	writel(0x0000200f | (aspeed_h2x->txTag << 8), aspeed_h2x->reg_base + 0x14);
+	writel(bdf_offset, aspeed_h2x->reg_base + 0x18);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x1c);
+
+	//trigger tx
+	writel((readl(aspeed_h2x->reg_base + 0x24) & 0xf) | PCIE_TRIGGER_TX, aspeed_h2x->reg_base + 0x24);
+
+	//wait tx idle
+	while(!(readl(aspeed_h2x->reg_base + 0x24) & PCIE_TX_IDLE)) {
+		timeout++;
+		if(timeout > 10000) {
+//			printk("time out b : %d, d : %d, f: %d \n", bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));
+			*val = 0xffffffff;
+			goto out;
+		}
+	};
+
+	//write clr tx idle
+	writel(1, aspeed_h2x->reg_base + 0x08);
+
+	timeout = 0;
+	//check tx status 
+	switch(readl(aspeed_h2x->reg_base + 0x24) & PCIE_STATUS_OF_TX) {
+		case PCIE_RC_L_TX_COMPLETE:
+			while(!(readl(aspeed_h2x->reg_base + 0x88) & PCIE_RC_RX_DONE_ISR)) {
+				timeout++;
+				if(timeout > 10) {
+					rx_done_fail = 1;
+					*val = 0xffffffff;
+					break;
+				}
+				mdelay(1);
+			}
+			if(!rx_done_fail) {
+				if(readl(aspeed_h2x->reg_base + 0x94) & BIT(13)) {
+					*val = 0xffffffff;
+				} else
+					*val = readl(aspeed_h2x->reg_base + 0x8C);
+			}
+			writel(BIT(4) | readl(aspeed_h2x->reg_base + 0x80), aspeed_h2x->reg_base + 0x80);
+			writel(readl(aspeed_h2x->reg_base + 0x88), aspeed_h2x->reg_base + 0x88);
+			break;
+		case PCIE_RC_H_TX_COMPLETE:
+			while(!(readl(aspeed_h2x->reg_base + 0xC8) & PCIE_RC_RX_DONE_ISR)) {
+				timeout++;
+				if(timeout > 10) {
+					rx_done_fail = 1;
+					*val = 0xffffffff;
+					break;
+				}
+				mdelay(1);
+			}
+			if(!rx_done_fail) {
+				if(readl(aspeed_h2x->reg_base + 0xD4) & BIT(13)) {
+					*val = 0xffffffff;
+				} else
+					*val = readl(aspeed_h2x->reg_base + 0xCC);
+			}
+			writel(BIT(4) | readl(aspeed_h2x->reg_base + 0xC0), aspeed_h2x->reg_base + 0xC0);
+			writel(readl(aspeed_h2x->reg_base + 0xC8), aspeed_h2x->reg_base + 0xC8);
+			break;
+		default:	//read rc data
+			*val = readl(aspeed_h2x->reg_base + 0x0C);
+			break;
+	}
+
+	switch (size) {
+		case 1:
+			*val = (*val >> ((where & 3) * 8)) & 0xff;
+			break;
+		case 2:
+			*val = (*val >> ((where & 2) * 8)) & 0xffff;
+			break;
+	}
+
+#ifdef CONFIG_HOTPLUG_PCI
+	if ((where == 0x9a) && (bus->number == 0x0) &&
+		(PCI_SLOT(devfn) == 0x8) && (PCI_FUNC(devfn) == 0x0) &&
+		hotplug_event)
+		*val |= PCI_EXP_SLTSTA_ABP;
+#endif
+out:
+	aspeed_h2x->txTag++;
+	
+	return PCIBIOS_SUCCESSFUL;
+
+}
+EXPORT_SYMBOL_GPL(aspeed_h2x_rd_conf);
+
+extern int
+aspeed_h2x_wr_conf(struct pci_bus *bus, unsigned int devfn, 
+				int where, int size, u32 val)
+{
+	u32 timeout = 0;
+	u32 type = 0;
+	u32 shift = 8 * (where & 3);
+	u32 bdf_offset;
+	u8 byte_en = 0;
+	struct aspeed_pcie *pcie = bus->sysdata;
+
+#ifdef CONFIG_HOTPLUG_PCI
+	if ((where == 0x9a) && (bus->number == 0x0) &&
+		(PCI_SLOT(devfn) == 0x8) && (PCI_FUNC(devfn) == 0x0) &&
+		hotplug_event && (val & PCI_EXP_SLTSTA_ABP)) {
+		hotplug_event = 0;
+		return PCIBIOS_SUCCESSFUL;
+	}
+#endif
+	writel(BIT(4) | readl(pcie->h2x_rc_base), pcie->h2x_rc_base);
+
+	switch (size) {
+	case 1:
+		switch(where % 4) {
+			case 0:
+				byte_en = 0x1;		
+				break;
+			case 1:
+				byte_en = 0x2;
+				break;
+			case 2:
+				byte_en = 0x4;
+				break;	
+			case 3:
+				byte_en = 0x8;
+				break;			
+		}
+		val = (val & 0xff) << shift;
+		break;
+	case 2:
+		switch((where >> 1) % 2 ) {
+			case 0:
+				byte_en = 0x3;
+				break;
+			case 1:
+				byte_en = 0xc;
+				break;
+		}
+		val = (val & 0xffff) << shift;		
+		break;
+	default:
+		byte_en = 0xf;
+		break;
+	}
+	
+	if(bus->number)
+		type = 1;
+	else
+		type = 0;
+		
+	bdf_offset = (bus->number << 24) | (PCI_SLOT(devfn) << 19) |
+					(PCI_FUNC(devfn) << 16) | (where & ~3);
+	
+	aspeed_h2x->txTag %= 0x7;
+	
+	writel(0x44000001 | (type << 24), aspeed_h2x->reg_base + 0x10);
+	writel(0x00002000 | (aspeed_h2x->txTag << 8) | byte_en, aspeed_h2x->reg_base + 0x14);
+	writel(bdf_offset, aspeed_h2x->reg_base + 0x18);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x1C);
+	
+	writel(val, aspeed_h2x->reg_base + 0x20);
+	
+	//trigger tx
+	writel((readl(aspeed_h2x->reg_base + 0x24) & 0xf) | PCIE_TRIGGER_TX, aspeed_h2x->reg_base + 0x24); 
+	
+//wait tx idle
+	while(!(readl(aspeed_h2x->reg_base + 0x24) & BIT(31))) {
+		timeout++;
+		if(timeout > 10000) {
+			printk("time out \n");
+			goto out;
+		}
+	};
+
+	//write clr tx idle
+	writel(1, aspeed_h2x->reg_base + 0x08);
+
+	timeout = 0;
+	//check tx status and clr rx done int
+	switch(readl(aspeed_h2x->reg_base + 0x24) & PCIE_STATUS_OF_TX) {
+		case PCIE_RC_L_TX_COMPLETE:
+			while(!(readl(aspeed_h2x->reg_base + 0x88) & PCIE_RC_RX_DONE_ISR)) {
+				timeout++;
+				if(timeout > 10) {
+					break;
+				}
+				mdelay(1);
+			}
+			writel(PCIE_RC_RX_DONE_ISR, aspeed_h2x->reg_base + 0x88);
+
+			break;
+		case PCIE_RC_H_TX_COMPLETE:
+			while(!(readl(aspeed_h2x->reg_base + 0xC8) & PCIE_RC_RX_DONE_ISR)) {
+				timeout++;
+				if(timeout > 10) {
+					break;
+				}
+				mdelay(1);
+			}
+			writel(PCIE_RC_RX_DONE_ISR, aspeed_h2x->reg_base + 0xC8);
+			break;
+	}
+
+out:
+	aspeed_h2x->txTag++;
+
+	return PCIBIOS_SUCCESSFUL;
+
+}
+EXPORT_SYMBOL_GPL(aspeed_h2x_wr_conf);
+
+/* INTx Functions */
+extern void aspeed_h2x_intx_ack_irq(struct irq_data *d)
+{
+	struct irq_desc *desc = irq_to_desc(d->irq);
+	struct aspeed_pcie *pcie = irq_desc_get_chip_data(desc);
+
+	writel(readl(pcie->h2x_rc_base + 0x04) | BIT(d->hwirq), pcie->h2x_rc_base + 0x04);
+}
+
+extern void aspeed_h2x_intx_mask_irq(struct irq_data *d)
+{
+	struct irq_desc *desc = irq_to_desc(d->irq);
+	struct aspeed_pcie *pcie = irq_desc_get_chip_data(desc);
+
+	writel(readl(pcie->h2x_rc_base + 0x04) & ~BIT(d->hwirq), pcie->h2x_rc_base + 0x04);
+}
+
+extern void aspeed_h2x_intx_unmask_irq(struct irq_data *d)
+{
+	struct irq_desc *desc = irq_to_desc(d->irq);
+	struct aspeed_pcie *pcie = irq_desc_get_chip_data(desc);
+
+	//Enable IRQ ..
+	writel(readl(pcie->h2x_rc_base + 0x04) | BIT(d->hwirq), pcie->h2x_rc_base + 0x04);
+}
+
+extern void aspeed_h2x_msi_enable(struct aspeed_pcie *pcie)
+{
+	writel(0xffffffff, pcie->h2x_rc_base + 0x20);
+	writel(0xffffffff, pcie->h2x_rc_base + 0x24);
+}
+
+extern void aspeed_h2x_rc_intr_handler(struct aspeed_pcie *pcie)
+{
+	u32 bit;	
+	u32 virq;
+	unsigned long status;
+	int i;
+	unsigned long intx = readl(pcie->h2x_rc_base + 0x08) & 0xf;
+
+	//intx isr
+	if(intx) {
+		for_each_set_bit(bit, &intx, 32) {
+			virq = irq_find_mapping(pcie->leg_domain, bit);
+			if (virq)
+				generic_handle_irq(virq);
+			else
+				dev_err(pcie->dev, "unexpected Int - X\n");
+		}
+	}
+	//msi isr
+	for (i = 0; i < 2; i++) {
+		status = readl(pcie->h2x_rc_base + 0x28 + (i * 4));
+//		printk("aspeed_pcie_intr_handler  status %lx \n", status);
+		writel(status, pcie->h2x_rc_base + 0x28 + (i * 4));
+//		printk("read  status %x \n", readl(pcie->h2xreg_base + 0xe8 + (i * 4)));
+		if (!status)
+				continue;
+
+		for_each_set_bit(bit, &status, 32) {
+			if(i) {
+				bit += 32;
+			}
+			virq = irq_find_mapping(pcie->msi_domain, bit);
+//			printk("[%d] : find bit %d mapping irq #%d \n", i, bit, virq);
+			if (virq)
+				generic_handle_irq(virq);
+			else
+				dev_err(pcie->dev, "unexpected MSI\n");
+		}
+	}
+}
+
+extern void aspeed_h2x_workaround(struct aspeed_pcie *pcie)
+{
+	u32 timeout = 0;
+
+	writel(BIT(4) | readl(pcie->h2x_rc_base), pcie->h2x_rc_base);
+
+	writel(0x74000001, aspeed_h2x->reg_base + 0x10);
+	writel(0x00400050, aspeed_h2x->reg_base + 0x14);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x18);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x1c);
+
+	writel(0x1a, aspeed_h2x->reg_base + 0x20);
+
+	//trigger tx
+	writel(PCIE_TRIGGER_TX, aspeed_h2x->reg_base + 0x24);
+
+	//wait tx idle
+	while(!(readl(aspeed_h2x->reg_base + 0x24) & BIT(31))) {
+		timeout++;
+		if(timeout > 1000) {
+			return;
+		}
+	};
+
+	//write clr tx idle
+	writel(1, aspeed_h2x->reg_base + 0x08);
+	timeout = 0;
+
+	//check tx status and clr rx done int
+	while(!(readl(pcie->h2x_rc_base + 0x08) & PCIE_RC_RX_DONE_ISR)) {
+		timeout++;
+		if(timeout > 10) {
+			break;
+		}
+		mdelay(1);
+	}
+	writel(PCIE_RC_RX_DONE_ISR, pcie->h2x_rc_base + 0x08);
+
+}
+EXPORT_SYMBOL(aspeed_h2x_workaround);
+
+extern void aspeed_h2x_rc_init(struct aspeed_pcie *pcie)
+{
+	pcie->h2x_rc_base = aspeed_h2x->reg_base + pcie->rc_offset;
+
+	//todo clr intx isr 
+	writel(0x0, pcie->h2x_rc_base + 0x04);
+
+	//clr msi isr 
+	writel(0xFFFFFFFF, pcie->h2x_rc_base + 0x28);
+	writel(0xFFFFFFFF, pcie->h2x_rc_base + 0x2c);
+
+	//rc_l
+	writel( PCIE_RX_DMA_EN | PCIE_RX_LINEAR | PCIE_RX_MSI_SEL | PCIE_RX_MSI_EN |
+			PCIE_Wait_RX_TLP_CLR | PCIE_RC_RX_ENABLE | PCIE_RC_ENABLE,
+	pcie->h2x_rc_base);
+	//assign debug tx tag
+	writel(0x28, pcie->h2x_rc_base + 0x3C);
+}
+
+static int aspeed_h2x_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	if (!(aspeed_h2x = devm_kzalloc(&pdev->dev, sizeof(struct aspeed_h2x_info), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (NULL == res) {
+		dev_err(&pdev->dev, "cannot get IORESOURCE_MEM\n");
+		return -ENOENT;
+	}
+
+	aspeed_h2x->reg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (!aspeed_h2x->reg_base) {
+		return -EIO;
+	}
+#if 0
+	aspeed_h2x->irq = platform_get_irq(pdev, 0);
+	if (aspeed_h2x->irq < 0) {
+		dev_err(&pdev->dev, "no irq specified\n");
+		return -ENOENT;
+	}
+#endif
+
+	aspeed_h2x->reset = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(aspeed_h2x->reset)) {
+		dev_err(&pdev->dev, "can't get h2x reset\n");
+		return PTR_ERR(aspeed_h2x->reset);
+	}
+	aspeed_h2x->txTag = 0;
+
+	//scu init
+	reset_control_assert(aspeed_h2x->reset);
+	reset_control_deassert(aspeed_h2x->reset);
+
+	//init
+	writel(0x1, aspeed_h2x->reg_base + 0x00);
+
+	//ahb to pcie rc 
+	writel(0xe0006000, aspeed_h2x->reg_base + 0x60);
+	writel(0x00000000, aspeed_h2x->reg_base + 0x64);
+	writel(0xFFFFFFFF, aspeed_h2x->reg_base + 0x68);
+	return 0;
+}
+
+
+static const struct of_device_id aspeed_h2x_of_match[] = {
+	{ .compatible = "aspeed,ast2600-h2x", },
+	{},
+};
+
+static struct platform_driver aspeed_h2x_driver = {
+	.driver = {
+		.name	= "aspeed-h2x",
+		.of_match_table = aspeed_h2x_of_match,
+	},
+	.probe = aspeed_h2x_probe,
+};
+
+static int __init aspeed_h2x_init(void)
+{
+	return platform_driver_register(&aspeed_h2x_driver);
+}
+
+arch_initcall(aspeed_h2x_init);
diff -Naur ori_linux/drivers/pci/controller/h2x-ast2600.h linux/drivers/pci/controller/h2x-ast2600.h
--- ori_linux/drivers/pci/controller/h2x-ast2600.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/pci/controller/h2x-ast2600.h	2022-03-17 23:14:01.000000000 +0800
@@ -0,0 +1,52 @@
+#ifndef __H2X_ASPEED_H_INCLUDED
+#define __H2X_ASPEED_H_INCLUDED
+
+#include <linux/reset.h>
+#include <linux/irqdomain.h>
+#include <linux/aspeed_pcie_io.h>
+
+struct aspeed_pcie {
+	struct device *dev;
+
+	void __iomem *pciereg_base;
+	void __iomem *h2x_rc_base;
+	u32 irq;	
+	u32 rc_offset;
+	u32 msi_address;	
+
+	struct reset_control *reset;
+	/* PCIe operations */
+	struct pci_ops aspeed_pcie_ops;
+
+	struct resource mem;
+	unsigned int busnr;
+
+	/* INTx IRQ Domain operations */	
+	struct irq_domain *leg_domain;
+	struct irq_chip aspeed_h2x_intx_chip;	
+	struct irq_domain_ops intx_domain_ops;
+
+	// msi
+	struct irq_domain *msi_domain;
+	struct msi_controller aspeed_pcie_msi_chip;
+	struct irq_chip aspeed_msi_irq_chip;
+	struct irq_domain_ops msi_domain_ops;
+};
+
+extern void aspeed_h2x_intx_ack_irq(struct irq_data *d);
+extern void aspeed_h2x_intx_mask_irq(struct irq_data *d);
+extern void aspeed_h2x_intx_unmask_irq(struct irq_data *d);
+extern void aspeed_h2x_msi_enable(struct aspeed_pcie *pcie);
+extern void aspeed_h2x_rc_intr_handler(struct aspeed_pcie *pcie);
+
+extern int aspeed_h2x_rd_conf(struct pci_bus *bus, unsigned int devfn, 
+				int where, int size, u32 *val);
+
+extern int aspeed_h2x_wr_conf(struct pci_bus *bus, unsigned int devfn, 
+				int where, int size, u32 val);
+
+extern void aspeed_h2x_workaround(struct aspeed_pcie *pcie);
+
+extern void aspeed_h2x_rc_init(struct aspeed_pcie *pcie);
+
+#endif
diff -Naur ori_linux/drivers/pci/controller/Kconfig linux/drivers/pci/controller/Kconfig
--- ori_linux/drivers/pci/controller/Kconfig	2021-06-03 14:59:17.000000000 +0800
+++ linux/drivers/pci/controller/Kconfig	2022-03-20 22:27:58.000000000 +0800
@@ -3,6 +3,12 @@
 menu "PCI controller drivers"
 	depends on PCI
 
+config PCIE_ASPEED
+	bool "ASPEED PCIe controller"
+	depends on ARCH_ASPEED
+	help
+	 Enables support for the PCIe controller in the ASPEED BMC SoC.
+
 config PCI_MVEBU
 	bool "Marvell EBU PCIe controller"
 	depends on ARCH_MVEBU || ARCH_DOVE || COMPILE_TEST
diff -Naur ori_linux/drivers/pci/controller/Makefile linux/drivers/pci/controller/Makefile
--- ori_linux/drivers/pci/controller/Makefile	2021-06-03 14:59:17.000000000 +0800
+++ linux/drivers/pci/controller/Makefile	2022-03-20 22:28:12.000000000 +0800
@@ -1,4 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_PCIE_ASPEED) += pcie-aspeed.o aspeed-h2x.o
 obj-$(CONFIG_PCIE_CADENCE) += pcie-cadence.o
 obj-$(CONFIG_PCIE_CADENCE_HOST) += pcie-cadence-host.o
 obj-$(CONFIG_PCIE_CADENCE_EP) += pcie-cadence-ep.o
diff -Naur ori_linux/drivers/pci/controller/pcie-aspeed.c linux/drivers/pci/controller/pcie-aspeed.c
--- ori_linux/drivers/pci/controller/pcie-aspeed.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/pci/controller/pcie-aspeed.c	2022-03-17 23:14:01.000000000 +0800
@@ -0,0 +1,544 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PCIE driver for the Aspeed SoC
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+
+#include <linux/delay.h>
+
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/spinlock.h>
+#include <linux/msi.h>
+
+#include <linux/of_pci.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/regmap.h>
+#include <linux/irqdomain.h>
+#include <linux/mfd/syscon.h>
+
+#include "h2x-ast2600.h"
+#include "../pci.h"
+
+#define MAX_LEGACY_IRQS			4
+#define MAX_MSI_HOST_IRQS		64
+
+/*	PCI Host Controller registers */
+#define ASPEED_PCIE_CLASS_CODE		0x04
+#define ASPEED_PCIE_GLOBAL			0x30
+#define ASPEED_PCIE_CFG_DIN			0x50
+#define ASPEED_PCIE_CFG3			0x58
+#define ASPEED_PCIE_LOCK			0x7C
+#define ASPEED_PCIE_LINK			0xC0
+#define ASPEED_PCIE_INT				0xC4
+#define ASPEED_PCIE_LINK_STS		0xD0
+/*	AST_PCIE_CFG2			0x04 */
+#define PCIE_CFG_CLASS_CODE(x)	(x << 8)
+#define PCIE_CFG_REV_ID(x)		(x)
+/*	PEHR10: Miscellaneous Control 10H Register */
+#define DATALINK_REPORT_CAPABLE	BIT(4)
+/*	PEHR14: Miscellaneous Control 14H Register */
+#define HOTPLUG_CAPABLE_ENABLE	BIT(6)
+#define HOTPLUG_SURPRISE_ENABLE	BIT(5)
+#define ATTENTION_BUTTON_ENALBE	BIT(0)
+/*	PEHR30: Miscellaneous Control 30H Register */
+/* Disable RC synchronous reset when link up to link down*/
+#define RC_SYNC_RESET_DISABLE	BIT(20)
+#define ROOT_COMPLEX_ID(x)		(x << 4)
+#define PCIE_RC_SLOT_ENABLE		BIT(1)
+/*	AST_PCIE_LOCK			0x7C */
+#define PCIE_UNLOCK				0xa8
+/*	AST_PCIE_LINK			0xC0 */
+#define PCIE_LINK_STS			BIT(5)
+/*  ASPEED_PCIE_LINK_STS	0xD0 */
+#define PCIE_LINK_5G			BIT(17)
+#define PCIE_LINK_2_5G			BIT(16)
+
+#ifdef CONFIG_PCI_MSI
+static DECLARE_BITMAP(msi_irq_in_use, MAX_MSI_HOST_IRQS);
+
+/* MSI functions */
+
+/**
+ * aspeed_pcie_destroy_msi - Free MSI number
+ * @irq: IRQ to be freed
+ */
+static void aspeed_pcie_destroy_msi(unsigned int irq)
+{
+	struct msi_desc *msi;
+	struct aspeed_pcie *pcie;
+	struct irq_data *d = irq_get_irq_data(irq);
+	irq_hw_number_t hwirq = irqd_to_hwirq(d);
+
+	if (!test_bit(hwirq, msi_irq_in_use)) {
+		msi = irq_get_msi_desc(irq);
+		pcie = msi_desc_to_pci_sysdata(msi);
+		dev_err(pcie->dev, "Trying to free unused MSI#%d\n", irq);
+	} else {
+		clear_bit(hwirq, msi_irq_in_use);
+	}
+}
+
+/**
+ * aspeed_pcie_assign_msi - Allocate MSI number
+ *
+ * Return: A valid IRQ on success and error value on failure.
+ */
+static int aspeed_pcie_assign_msi(void)
+{
+	int pos;
+
+	pos = find_first_zero_bit(msi_irq_in_use, MAX_MSI_HOST_IRQS);
+	if (pos < MAX_MSI_HOST_IRQS)
+		set_bit(pos, msi_irq_in_use);
+	else
+		return -ENOSPC;
+
+	return pos;
+}
+
+static int aspeed_msi_alloc_region(int no_irqs)
+{
+	int msi;
+
+	msi = bitmap_find_free_region(msi_irq_in_use, MAX_MSI_HOST_IRQS,
+			order_base_2(no_irqs));
+	return msi;
+}
+
+/**
+ * aspeed_msi_teardown_irq - Destroy the MSI
+ * @chip: MSI Chip descriptor
+ * @irq: MSI IRQ to destroy
+ */
+static void aspeed_msi_teardown_irq(struct msi_controller *chip,
+				    unsigned int irq)
+{
+	aspeed_pcie_destroy_msi(irq);
+	irq_dispose_mapping(irq);
+}
+
+/**
+ * aspeed_pcie_msi_setup_irq - Setup MSI request
+ * @chip: MSI chip pointer
+ * @pdev: PCIe device pointer
+ * @desc: MSI descriptor pointer
+ *
+ * Return: '0' on success and error value on failure
+ */
+static int aspeed_pcie_msi_setup_irq(struct msi_controller *chip,
+				     struct pci_dev *pdev,
+				     struct msi_desc *desc)
+{
+	struct aspeed_pcie *pcie = pdev->bus->sysdata;
+	unsigned int irq;
+	int hwirq;
+	struct msi_msg msg;
+
+	hwirq = aspeed_pcie_assign_msi();
+	if (hwirq < 0)
+		return hwirq;
+
+	irq = irq_find_mapping(pcie->msi_domain, hwirq);
+	if (!irq) {
+		clear_bit(irq, msi_irq_in_use);
+		return -EINVAL;
+	}
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_hi = 0;
+	msg.address_lo = pcie->msi_address;
+	msg.data = hwirq;
+
+	pci_write_msi_msg(irq, &msg);
+
+	return 0;
+}
+
+
+static int aspeed_pcie_msi_setup_irqs(struct msi_controller *chip,
+					struct pci_dev *pdev, int nvec, int type)
+{
+	struct aspeed_pcie *pcie = pdev->bus->sysdata;
+	struct msi_desc *desc;
+	struct msi_msg msg;
+	unsigned int irq;
+	int hwirq;
+	int i;
+
+	/* MSI-X interrupts are not supported */
+	if (type == PCI_CAP_ID_MSIX)
+		return -EINVAL;
+
+	WARN_ON(!list_is_singular(&pdev->dev.msi_list));
+	desc = list_entry(pdev->dev.msi_list.next, struct msi_desc, list);
+
+	hwirq = aspeed_msi_alloc_region(nvec);
+	if (hwirq < 0)
+		return hwirq;
+
+	irq = irq_find_mapping(pcie->msi_domain, hwirq);
+	if (!irq)
+		return -ENOSPC;
+
+	for (i = 0; i < nvec; i++) {
+		/*
+		 * irq_create_mapping() called from rcar_pcie_probe() pre-
+		 * allocates descs,  so there is no need to allocate descs here.
+		 * We can therefore assume that if irq_find_mapping() above
+		 * returns non-zero, then the descs are also successfully
+		 * allocated.
+		 */
+		if (irq_set_msi_desc_off(irq, i, desc)) {
+			/* TODO: clear */
+			return -EINVAL;
+		}
+	}
+
+	desc->nvec_used = nvec;
+	desc->msi_attrib.multiple = order_base_2(nvec);
+
+	msg.address_hi = 0;
+	msg.address_lo = pcie->msi_address;
+	msg.data = hwirq;
+
+	pci_write_msi_msg(irq, &msg);
+
+	return 0;
+}
+
+/**
+ * aspeed_pcie_msi_map - Set the handler for the MSI and mark IRQ as valid
+ * @domain: IRQ domain
+ * @irq: Virtual IRQ number
+ * @hwirq: HW interrupt number
+ *
+ * Return: Always returns 0.
+ */
+static int aspeed_pcie_msi_map(struct irq_domain *domain, unsigned int irq,
+			       irq_hw_number_t hwirq)
+{
+	struct aspeed_pcie *pcie = (struct aspeed_pcie *)domain->host_data;
+
+	irq_set_chip_and_handler(irq,
+				&pcie->aspeed_msi_irq_chip, handle_simple_irq);
+	irq_set_chip_data(irq, domain->host_data);
+
+	return 0;
+}
+#endif
+/**
+ * aspeed_pcie_intx_map - Set the handler for the INTx and mark IRQ as valid
+ * @domain: IRQ domain
+ * @irq: Virtual IRQ number
+ * @hwirq: HW interrupt number
+ *
+ * Return: Always returns 0.
+ */
+static int aspeed_pcie_intx_map(struct irq_domain *domain, unsigned int irq,
+					irq_hw_number_t hwirq)
+{
+	struct aspeed_pcie *pcie = (struct aspeed_pcie *)domain->host_data;
+
+	irq_set_chip_and_handler(irq,
+				&pcie->aspeed_h2x_intx_chip, handle_level_irq);
+	irq_set_chip_data(irq, domain->host_data);
+
+	return 0;
+}
+
+/**
+ * aspeed_pcie_intr_handler - Interrupt Service Handler
+ * @irq: IRQ number
+ * @data: PCIe port information
+ *
+ * Return: IRQ_HANDLED on success and IRQ_NONE on failure
+ */
+static irqreturn_t aspeed_pcie_intr_handler(int irq, void *data)
+{
+	struct aspeed_pcie *pcie = (struct aspeed_pcie *)data;
+
+	aspeed_h2x_rc_intr_handler(pcie);
+	return IRQ_HANDLED;
+}
+
+/**
+ * aspeed_pcie_init_irq_domain - Initialize IRQ domain
+ * @port: PCIe port information
+ *
+ * Return: '0' on success and error value on failure
+ */
+static int aspeed_pcie_init_irq_domain(struct aspeed_pcie *pcie)
+{
+	struct device *dev = pcie->dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *pcie_intc_node;
+#ifdef CONFIG_PCI_MSI
+	int i = 0;
+#endif
+	/* Setup INTx */
+	pcie_intc_node = of_get_next_child(node, NULL);
+	if (!pcie_intc_node) {
+		dev_err(dev, "No PCIe Intc node found\n");
+		return -ENODEV;
+	}
+
+	pcie->aspeed_h2x_intx_chip.name = "IntX";
+	pcie->aspeed_h2x_intx_chip.irq_ack	= aspeed_h2x_intx_ack_irq;
+	pcie->aspeed_h2x_intx_chip.irq_mask	= aspeed_h2x_intx_mask_irq;
+	pcie->aspeed_h2x_intx_chip.irq_unmask = aspeed_h2x_intx_unmask_irq;
+	pcie->intx_domain_ops.map = aspeed_pcie_intx_map;
+	pcie->leg_domain = irq_domain_add_linear(pcie_intc_node,
+				MAX_LEGACY_IRQS, &pcie->intx_domain_ops, pcie);
+	of_node_put(pcie_intc_node);
+	if (!pcie->leg_domain) {
+		dev_err(dev, "unable get a INTx IRQ domain\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_PCI_MSI
+	/* MSI Domain operations */
+	pcie->msi_domain_ops.map = aspeed_pcie_msi_map;
+	pcie->aspeed_pcie_msi_chip.setup_irq = aspeed_pcie_msi_setup_irq;
+	pcie->aspeed_pcie_msi_chip.setup_irqs = aspeed_pcie_msi_setup_irqs;
+	pcie->aspeed_pcie_msi_chip.teardown_irq = aspeed_msi_teardown_irq;
+	pcie->aspeed_msi_irq_chip.name = "MSI";
+	pcie->aspeed_msi_irq_chip.irq_enable = pci_msi_unmask_irq;
+	pcie->aspeed_msi_irq_chip.irq_disable = pci_msi_mask_irq;
+	pcie->aspeed_msi_irq_chip.irq_mask = pci_msi_mask_irq;
+	pcie->aspeed_msi_irq_chip.irq_unmask = pci_msi_unmask_irq;
+
+	/* Setup MSI */
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		pcie->msi_domain =
+				irq_domain_add_linear(node,
+							MAX_MSI_HOST_IRQS,
+							&pcie->msi_domain_ops,
+							pcie);
+		if (!pcie->msi_domain) {
+			dev_err(dev, "unable to get a MSI IRQ domain\n");
+			return -ENODEV;
+		}
+
+		for (i = 0; i < MAX_MSI_HOST_IRQS; i++)
+			irq_create_mapping(pcie->msi_domain, i);
+
+		//enable all msi interrupt
+		aspeed_h2x_msi_enable(pcie);
+	}
+#endif
+	return 0;
+}
+
+/**
+ * aspeed_pcie_init_port - Initialize hardware
+ * @port: PCIe port information
+ */
+
+#define AHBC_UNLOCK	0xAEED1A03
+static void aspeed_pcie_init_port(struct aspeed_pcie *pcie)
+{
+	struct regmap *ahbc =
+		syscon_regmap_lookup_by_compatible("aspeed,aspeed-ahbc");
+	if (!IS_ERR(ahbc)) {
+		//ahbc remap enable
+		regmap_write(ahbc, 0x00, AHBC_UNLOCK);
+		regmap_update_bits(ahbc, 0x8C, BIT(5), BIT(5));
+		regmap_write(ahbc, 0x00, 0x1);
+	} else {
+		dev_warn(pcie->dev,
+			"Unable to remap AHBC. %ld\n", PTR_ERR(ahbc));
+	}
+
+	aspeed_h2x_rc_init(pcie);
+
+	//plda init
+	writel(PCIE_UNLOCK, pcie->pciereg_base + ASPEED_PCIE_LOCK);
+//	writel(PCIE_CFG_CLASS_CODE(0x60000) | PCIE_CFG_REV_ID(4),
+//				pcie->pciereg_base + ASPEED_PCIE_CLASS_CODE);
+#ifdef CONFIG_HOTPLUG_PCI
+	writel(RC_SYNC_RESET_DISABLE | ROOT_COMPLEX_ID(0x3) | PCIE_RC_SLOT_ENABLE, pcie->pciereg_base + ASPEED_PCIE_GLOBAL);
+	writel(0xd7040022 | DATALINK_REPORT_CAPABLE, pcie->pciereg_base + 0x10);
+	writel(HOTPLUG_CAPABLE_ENABLE | HOTPLUG_SURPRISE_ENABLE | ATTENTION_BUTTON_ENALBE, pcie->pciereg_base + 0x14);
+#else
+	writel(ROOT_COMPLEX_ID(0x3), pcie->pciereg_base + ASPEED_PCIE_GLOBAL);
+#endif
+	/* Don't register host if link is down */
+	if (readl(pcie->pciereg_base + ASPEED_PCIE_LINK) & PCIE_LINK_STS) {
+		aspeed_h2x_workaround(pcie);
+
+		if (readl(pcie->pciereg_base
+				+ ASPEED_PCIE_LINK_STS) & PCIE_LINK_5G)
+			dev_info(pcie->dev, "PCIE- Link up : 5G\n");
+		if (readl(pcie->pciereg_base
+				+ ASPEED_PCIE_LINK_STS) & PCIE_LINK_2_5G)
+			dev_info(pcie->dev, "PCIE- Link up : 2.5G\n");
+	} else {
+		dev_info(pcie->dev, "PCIE- Link down\n");
+	}
+
+}
+
+/**
+ * aspeed_pcie_parse_dt - Parse Device tree
+ * @port: PCIe port information
+ *
+ * Return: '0' on success and error value on failure
+ */
+static int aspeed_pcie_parse_dt(struct aspeed_pcie *pcie,
+					struct platform_device *pdev)
+{
+	struct device *dev = pcie->dev;
+	struct device_node *node = dev->of_node;
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res) {
+		pcie->pciereg_base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(pcie->pciereg_base))
+			return PTR_ERR(pcie->pciereg_base);
+	}
+
+	pcie->irq = irq_of_parse_and_map(node, 0);
+
+	of_property_read_u32(node, "rc_offset", &pcie->rc_offset);
+	of_property_read_u32(node, "msi_address", &pcie->msi_address);
+	return 0;
+}
+
+static int aspeed_pcie_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct aspeed_pcie *pcie;
+	struct pci_bus *bus;
+	struct pci_bus *child;
+	struct pci_host_bridge *bridge;
+//	struct regmap *scu;
+	int err;
+	resource_size_t iobase = 0;
+	LIST_HEAD(res);
+
+	if (!dev->of_node)
+		return -ENODEV;
+
+	bridge = devm_pci_alloc_host_bridge(dev, sizeof(*pcie));
+	if (!bridge)
+		return -ENOMEM;
+
+	pcie = pci_host_bridge_priv(bridge);
+
+	pcie->dev = dev;
+
+	err = aspeed_pcie_parse_dt(pcie, pdev);
+	if (err) {
+		dev_err(dev, "Parsing DT failed\n");
+		return err;
+	}
+
+	pcie->reset = devm_reset_control_get(&pdev->dev, 0);
+	if (IS_ERR(pcie->reset)) {
+		dev_err(&pdev->dev, "can't get pcie reset\n");
+		return PTR_ERR(pcie->reset);
+	}
+#if 0
+	scu = syscon_regmap_lookup_by_compatible("aspeed,aspeed-scu");
+	if (!IS_ERR(scu)) {
+		regmap_update_bits(scu, 0x500, BIT(24), BIT(24));
+		regmap_update_bits(scu, 0x40, BIT(19) | BIT(18),
+							BIT(19) | BIT(18));
+	} else
+		dev_warn(pcie->dev, "Unable to remap SCU. %ld\n", PTR_ERR(scu));
+#else
+	reset_control_assert(pcie->reset);
+	mdelay(50);
+	reset_control_deassert(pcie->reset);
+	mdelay(50);
+#endif
+	aspeed_pcie_init_port(pcie);
+
+	err = aspeed_pcie_init_irq_domain(pcie);
+	if (err) {
+		dev_err(dev, "Failed creating IRQ Domain\n");
+		goto error;
+	}
+
+	err = devm_of_pci_get_host_bridge_resources(dev, 0, 0xff, &res,
+						    &iobase);
+	if (err) {
+		dev_err(dev, "Getting bridge resources failed\n");
+		return err;
+	}
+
+	err = devm_request_pci_bus_resources(dev, &res);
+	if (err)
+		goto error;
+
+	list_splice_init(&res, &bridge->windows);
+
+	/* PCIe operations */
+	pcie->aspeed_pcie_ops.read = aspeed_h2x_rd_conf;
+	pcie->aspeed_pcie_ops.write = aspeed_h2x_wr_conf;
+	bridge->dev.parent = dev;
+	bridge->sysdata = pcie;
+	bridge->busnr = 0;
+	bridge->ops = &pcie->aspeed_pcie_ops;
+	bridge->map_irq = of_irq_parse_and_map_pci;
+//	bridge->swizzle_irq = pci_common_swizzle;
+
+#ifdef CONFIG_PCI_MSI
+	pcie->aspeed_pcie_msi_chip.dev = dev;
+	bridge->msi = &pcie->aspeed_pcie_msi_chip;
+#endif
+	err = pci_scan_root_bus_bridge(bridge);
+	if (err)
+		goto error;
+
+	bus = bridge->bus;
+	pci_assign_unassigned_bus_resources(bus);
+	list_for_each_entry(child, &bus->children, node)
+		pcie_bus_configure_settings(child);
+	pci_bus_add_devices(bus);
+
+	err = devm_request_irq(dev, pcie->irq, aspeed_pcie_intr_handler,
+						   0,
+						   "aspeed-pcie", pcie);
+	if (err) {
+		dev_err(dev, "unable to request irq %d\n", pcie->irq);
+		return err;
+	}
+
+	return 0;
+
+error:
+	pci_free_resource_list(&res);
+	return err;
+}
+
+static const struct of_device_id aspeed_pcie_of_match[] = {
+	{ .compatible = "aspeed,ast2600-pcie", },
+	{},
+};
+
+static struct platform_driver aspeed_pcie_driver = {
+	.driver = {
+		.name	= "aspeed-pcie",
+		.of_match_table = aspeed_pcie_of_match,
+	},
+	.probe = aspeed_pcie_probe,
+};
+
+builtin_platform_driver(aspeed_pcie_driver);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_DESCRIPTION("ASPEED PCIe Host driver");
+MODULE_LICENSE("GPL");
diff -Naur ori_linux/drivers/pci/probe.c linux/drivers/pci/probe.c
--- ori_linux/drivers/pci/probe.c	2021-06-03 14:59:17.000000000 +0800
+++ linux/drivers/pci/probe.c	2022-03-20 22:27:07.000000000 +0800
@@ -365,6 +365,11 @@
 	if (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)
 		return;
 
+    if ((bridge->vendor == 0x1a03 && bridge->device == 0x1150) && (!bridge->bus->number)) {
+		dev_info(&bridge->dev, "ASPEED Bridge Gen2 re-training \n");
+		pci_write_config_byte(bridge, 0x90, 0x20);
+	}
+
 	pci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);
 	if (!pmem) {
 		pci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,
