diff -Naur linux_ori/drivers/hwmon/aspeed2600-pwm-tacho.c linux/drivers/hwmon/aspeed2600-pwm-tacho.c
--- linux_ori/drivers/hwmon/aspeed2600-pwm-tacho.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/hwmon/aspeed2600-pwm-tacho.c	2022-08-15 11:50:54.622973078 +0800
@@ -0,0 +1,803 @@
+/*
+ * Copyright (C) ASPEED Technology Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 or later as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/reset.h>
+#include <linux/regmap.h>
+#include <linux/thermal.h>
+/**********************************************************
+ * PWM HW register offset define
+ *********************************************************/
+//PWM Control Register
+#define ASPEED_PWM_CTRL_CH(ch)			((ch * 0x10) + 0x00)
+//PWM Duty Cycle Register
+#define ASPEED_PWM_DUTY_CYCLE_CH(ch)	((ch * 0x10) + 0x04)
+//TACH Control Register
+#define ASPEED_TACHO_CTRL_CH(ch)		((ch * 0x10) + 0x08)
+//TACH Status Register
+#define ASPEED_TACHO_STS_CH(x)			((x * 0x10) + 0x0C)
+/**********************************************************
+ * PWM register Bit field 
+ *********************************************************/
+/*PWM_CTRL */
+#define  PWM_LOAD_SEL_AS_WDT_BIT	(19)	//load selection as WDT
+#define  PWM_DUTY_LOAD_AS_WDT_EN	BIT(18)	//enable PWM duty load as WDT
+#define  PWM_DUTY_SYNC_DIS			BIT(17)	//disable PWM duty sync
+#define	 PWM_CLK_ENABLE				BIT(16)	//enable PWM clock
+#define  PWM_LEVEL_OUTPUT			BIT(15)	//output PWM level
+#define  PWM_INVERSE				BIT(14) //inverse PWM pin
+#define  PWM_OPEN_DRAIN_EN			BIT(13)	//enable open-drain
+#define  PWM_PIN_EN					BIT(12) //enable PWM pin
+#define  PWM_CLK_DIV_H_MASK			(0xf << 8)	//PWM clock division H bit [3:0]
+#define  PWM_CLK_DIV_L_MASK			(0xff)	//PWM clock division H bit [3:0]
+/* [19] */
+#define LOAD_SEL_FALLING 0
+#define LOAD_SEL_RIGING  1
+
+/*PWM_DUTY_CYCLE */
+#define  PWM_PERIOD_BIT					(24)	//pwm period bit [7:0]
+#define  PWM_PERIOD_BIT_MASK			(0xff << 24)	//pwm period bit [7:0]
+#define  PWM_RISING_FALLING_AS_WDT_BIT  (16)	
+#define  PWM_RISING_FALLING_AS_WDT_MASK (0xff << 16)	//pwm rising/falling point bit [7:0] as WDT
+#define  PWM_RISING_FALLING_MASK		(0xffff)	
+#define  PWM_FALLING_POINT_BIT			(8)	//pwm falling point bit [7:0]
+#define  PWM_RISING_POINT_BIT			(0)	//pwm rising point bit [7:0]
+/* [31:24] */
+#define  DEFAULT_PWM_PERIOD 0xff
+
+/*PWM_TACHO_CTRL */
+#define  TACHO_IER						BIT(31)	//enable tacho interrupt
+#define  TACHO_INVERS_LIMIT				BIT(30) //inverse tacho limit comparison
+#define  TACHO_LOOPBACK					BIT(29) //tacho loopback
+#define  TACHO_ENABLE					BIT(28)	//{enable tacho}
+#define  TACHO_DEBOUNCE_MASK			(0x3 << 26) //{tacho de-bounce}
+#define  TACHO_DEBOUNCE_BIT				(26) //{tacho de-bounce}
+#define  TECHIO_EDGE_MASK				(0x3 << 24) //tacho edge}
+#define  TECHIO_EDGE_BIT				(24) //tacho edge}
+#define  TACHO_CLK_DIV_T_MASK			(0xf << 20) 
+#define  TACHO_CLK_DIV_BIT				(20)
+#define  TACHO_THRESHOLD_MASK			(0xfffff)	//tacho threshold bit
+/* [27:26] */
+#define DEBOUNCE_3_CLK 0x00 /* 10b */
+#define DEBOUNCE_2_CLK 0x01 /* 10b */
+#define DEBOUNCE_1_CLK 0x02 /* 10b */
+#define DEBOUNCE_0_CLK 0x03 /* 10b */
+/* [25:24] */
+#define F2F_EDGES 0x00 /* 10b */
+#define R2R_EDGES 0x01 /* 10b */
+#define BOTH_EDGES 0x02 /* 10b */
+/* [23:20] */
+/* Cover rpm range 5~5859375 */
+#define  DEFAULT_TACHO_DIV 5
+
+/*PWM_TACHO_STS */
+#define  TACHO_ISR			BIT(31)	//interrupt status and clear
+#define  PWM_OUT			BIT(25)	//{pwm_out}
+#define  PWM_OEN			BIT(24)	//{pwm_oeN}
+#define  TACHO_DEB_INPUT	BIT(23)	//tacho deB input
+#define  TACHO_RAW_INPUT	BIT(22) //tacho raw input}
+#define  TACHO_VALUE_UPDATE	BIT(21)	//tacho value updated since the last read
+#define  TACHO_FULL_MEASUREMENT	BIT(20) //{tacho full measurement}
+#define  TACHO_VALUE_MASK	0xfffff	//tacho value bit [19:0]}
+/**********************************************************
+ * Software setting
+ *********************************************************/
+#define DEFAULT_TARGET_PWM_FREQ		25000
+#define DEFAULT_DUTY_PT 10
+#define DEFAULT_WDT_RELOAD_DUTY_PT 16
+#define DEFAULT_FAN_MIN_RPM 1000
+#define DEFAULT_FAN_PULSE_PR 2
+#define MAX_CDEV_NAME_LEN 16
+
+struct aspeed_pwm_channel_params {
+	u32 target_freq;
+	u32 pwm_freq;
+	u32 wdt_reload_duty_pt;
+	u32	duty_pt;
+	bool wdt_reload_enable;
+};
+
+struct aspeed_tacho_channel_params {
+	int limited_inverse;
+	u16 threshold;
+	u8	tacho_edge;
+	u8	tacho_debounce;
+	u8  pulse_pr;
+	u32 min_rpm;
+	u32 divide;
+	u32 sample_period; /* unit is us */
+};
+
+struct aspeed_pwm_tachometer_data {
+	struct regmap *regmap;
+	unsigned long clk_freq;
+	struct reset_control *reset;	
+	bool pwm_present[16];
+	bool fan_tach_present[16];
+	struct aspeed_pwm_channel_params *pwm_channel;
+	struct aspeed_tacho_channel_params *tacho_channel;
+	/* for thermal */
+	struct aspeed_cooling_device *cdev[8];
+	/* for hwmon */
+	const struct attribute_group *groups[3];
+};
+
+struct aspeed_cooling_device {
+	char name[16];
+	struct aspeed_pwm_tachometer_data *priv;
+	struct thermal_cooling_device *tcdev;
+	int pwm_channel;
+	u8 *cooling_levels;
+	u8 max_state;
+	u8 cur_state;
+};
+
+static int regmap_aspeed_pwm_tachometer_reg_write(void *context, unsigned int reg,
+					     unsigned int val)
+{
+	void __iomem *regs = (void __iomem *)context;
+
+	writel(val, regs + reg);
+	return 0;
+}
+
+static int regmap_aspeed_pwm_tachometer_reg_read(void *context, unsigned int reg,
+					    unsigned int *val)
+{
+	void __iomem *regs = (void __iomem *)context;
+
+	*val = readl(regs + reg);
+	return 0;
+}
+
+static const struct regmap_config aspeed_pwm_tachometer_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = 0x100,
+	.reg_write = regmap_aspeed_pwm_tachometer_reg_write,
+	.reg_read = regmap_aspeed_pwm_tachometer_reg_read,
+	.fast_io = true,
+};
+
+static void aspeed_set_pwm_channel_enable(struct regmap *regmap, u8 pwm_channel,
+				       bool enable)
+{
+	regmap_update_bits(regmap, ASPEED_PWM_CTRL_CH(pwm_channel), (PWM_CLK_ENABLE | PWM_PIN_EN), enable ? (PWM_CLK_ENABLE | PWM_PIN_EN) : 0);
+}
+
+static u32
+aspeed_get_fan_tach_sample_period(struct aspeed_pwm_tachometer_data *priv, u8 fan_tach_ch)
+{
+	u32 tach_period_us;
+	u8 pulse_pr = priv->tacho_channel[fan_tach_ch].pulse_pr;
+	u32 min_rpm = priv->tacho_channel[fan_tach_ch].min_rpm;
+	/* 
+	 * min(Tach input clock) = (PulsePR * minRPM) / 60
+	 * max(Tach input period) = 60 / (PulsePR * minRPM)
+	 * Tach sample period > 2 * max(Tach input period) = (2*60) / (PulsePR * minRPM)
+	 */
+	tach_period_us = (1000000 * 2 * 60) / (pulse_pr * min_rpm);
+	/* Add the margin (about 1.2) of tach sample period to avoid sample miss */
+	tach_period_us = (tach_period_us * 1200) >> 10;
+	printk(KERN_DEBUG "tach%d sample period = %dus", fan_tach_ch, tach_period_us);
+	return tach_period_us;
+}
+
+static void
+aspeed_set_fan_tach_ch_enable(struct aspeed_pwm_tachometer_data *priv,
+			      u8 fan_tach_ch, bool enable, u32 tacho_div)
+{
+	u32 reg_value = 0;
+
+	if(enable) {
+		/* divide = 2^(tacho_div*2) */
+		priv->tacho_channel[fan_tach_ch].divide = 1 << (tacho_div << 1);
+
+		reg_value = TACHO_ENABLE | 
+				(priv->tacho_channel[fan_tach_ch].tacho_edge << TECHIO_EDGE_BIT) |
+				(tacho_div << TACHO_CLK_DIV_BIT) |
+				(priv->tacho_channel[fan_tach_ch].tacho_debounce << TACHO_DEBOUNCE_BIT);
+
+		if(priv->tacho_channel[fan_tach_ch].limited_inverse)
+			reg_value |= TACHO_INVERS_LIMIT;
+
+		if(priv->tacho_channel[fan_tach_ch].threshold)
+			reg_value |= (TACHO_IER | priv->tacho_channel[fan_tach_ch].threshold); 
+
+		regmap_write(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch), reg_value);
+
+		priv->tacho_channel[fan_tach_ch].sample_period =
+			aspeed_get_fan_tach_sample_period(priv, fan_tach_ch);
+	} else
+		regmap_update_bits(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch),  TACHO_ENABLE, 0);
+}
+
+/*
+ * The PWM frequency = HCLK(200Mhz) / (clock division L bit *
+ * clock division H bit * (period bit + 1))
+ */
+static void aspeed_set_pwm_channel_fan_ctrl(struct aspeed_pwm_tachometer_data *priv,
+					 u8 index, u8 fan_ctrl)
+{
+	u32 duty_value,	ctrl_value;
+	u32 target_div, cal_freq;
+	u32 tmp_div_h, tmp_div_l, diff, min_diff = INT_MAX;
+	u32 div_h = BIT(5) - 1, div_l = BIT(8) - 1;
+	u8 div_found;
+
+	if (fan_ctrl == 0) {
+		aspeed_set_pwm_channel_enable(priv->regmap, index, false);
+	} else {
+		cal_freq = priv->clk_freq / (DEFAULT_PWM_PERIOD + 1);
+		target_div = DIV_ROUND_UP(cal_freq, priv->pwm_channel[index].target_freq);
+		div_found = 0;
+		/* calculate for target frequence */
+		for (tmp_div_h = 0; tmp_div_h < 0x10; tmp_div_h++) {
+			tmp_div_l = target_div / BIT(tmp_div_h) - 1;
+
+			if (tmp_div_l < 0 || tmp_div_l > 255)
+				continue;
+
+			diff = priv->pwm_channel[index].target_freq - cal_freq / (BIT(tmp_div_h) * (tmp_div_l + 1));
+			if (abs(diff) < abs(min_diff)) {
+				min_diff = diff;
+				div_l = tmp_div_l;
+				div_h = tmp_div_h;
+				div_found = 1;
+				if (diff == 0)
+					break;
+			}
+		}
+		if (div_found == 0) {
+			printk(KERN_WARNING "target freq: %d too slow set minimal frequency\n", priv->pwm_channel[index].target_freq);
+		}
+
+		priv->pwm_channel[index].pwm_freq = cal_freq / (BIT(div_h) * (div_l + 1));
+		printk(KERN_DEBUG "div h %x, l : %x pwm out clk %d\n", div_h, div_l,
+		       priv->pwm_channel[index].pwm_freq);
+		printk(KERN_DEBUG "hclk %ld, target pwm freq %d, real pwm freq %d\n", priv->clk_freq,
+				priv->pwm_channel[index].target_freq, priv->pwm_channel[index].pwm_freq);
+
+		ctrl_value = (div_h << 8) | div_l;
+
+		duty_value = (DEFAULT_PWM_PERIOD << PWM_PERIOD_BIT) | 
+					(0 << PWM_RISING_POINT_BIT) | (fan_ctrl << PWM_FALLING_POINT_BIT);
+
+		if (priv->pwm_channel[index].wdt_reload_enable) {
+			ctrl_value |= PWM_DUTY_LOAD_AS_WDT_EN;
+			ctrl_value |= LOAD_SEL_FALLING << PWM_LOAD_SEL_AS_WDT_BIT;
+			duty_value |= (priv->pwm_channel[index].wdt_reload_duty_pt << PWM_RISING_FALLING_AS_WDT_BIT);
+		}
+
+		regmap_write(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), duty_value);
+		regmap_write(priv->regmap, ASPEED_PWM_CTRL_CH(index), ctrl_value);
+
+		aspeed_set_pwm_channel_enable(priv->regmap, index, true);
+	}
+}
+
+static int aspeed_get_fan_tach_ch_rpm(struct aspeed_pwm_tachometer_data *priv,
+				      u8 fan_tach_ch)
+{
+	u32 raw_data, tach_div, clk_source, usec, val;
+	int ret;
+
+	usec = priv->tacho_channel[fan_tach_ch].sample_period;
+	ret = regmap_read_poll_timeout(
+		priv->regmap, ASPEED_TACHO_STS_CH(fan_tach_ch), val,
+		(val & TACHO_FULL_MEASUREMENT) && (val & TACHO_VALUE_UPDATE), 0,
+		usec);
+
+	/* return -ETIMEDOUT if we didn't get an answer. */
+	if (ret)
+		return ret;
+	
+	raw_data = val & TACHO_VALUE_MASK;
+	/*
+	 * We need the mode to determine if the raw_data is double (from
+	 * counting both edges).
+	 */
+	if (priv->tacho_channel[fan_tach_ch].tacho_edge == BOTH_EDGES)
+		raw_data <<= 1;
+	
+	tach_div = raw_data * (priv->tacho_channel[fan_tach_ch].divide) * (priv->tacho_channel[fan_tach_ch].pulse_pr);
+
+//	printk("clk %ld, raw_data %d , tach_div %d  \n", priv->clk_freq, raw_data, tach_div);
+	
+	clk_source = priv->clk_freq;
+
+	if (tach_div == 0)
+		return -EDOM;
+
+	return ((clk_source / tach_div) * 60);
+
+}
+
+static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	int ret;
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+	long fan_ctrl;
+	u8 org_falling = priv->pwm_channel[index].duty_pt;
+
+	ret = kstrtol(buf, 10, &fan_ctrl);
+	if (ret != 0)
+		return ret;
+
+	if (fan_ctrl < 0 || fan_ctrl > DEFAULT_PWM_PERIOD)
+		return -EINVAL;
+
+	if (priv->pwm_channel[index].duty_pt == fan_ctrl)
+		return count;
+
+	priv->pwm_channel[index].duty_pt = fan_ctrl;
+
+	if(fan_ctrl == 0)
+		aspeed_set_pwm_channel_enable(priv->regmap, index, false);
+	else {
+		if(fan_ctrl == DEFAULT_PWM_PERIOD)
+			regmap_update_bits(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), GENMASK(15, 0), 0);
+		else
+			regmap_update_bits(priv->regmap, ASPEED_PWM_DUTY_CYCLE_CH(index), GENMASK(15, 8), (fan_ctrl << PWM_FALLING_POINT_BIT));
+	}
+
+	if(org_falling == 0)
+		aspeed_set_pwm_channel_enable(priv->regmap, index, true);
+
+	return count;
+}
+
+static ssize_t show_pwm(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", priv->pwm_channel[index].duty_pt);
+}
+
+static ssize_t show_rpm(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	int rpm;
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	rpm = aspeed_get_fan_tach_ch_rpm(priv, index);
+	if (rpm < 0)
+		return rpm;
+
+	return sprintf(buf, "%d\n", rpm);
+}
+
+static umode_t pwm_is_visible(struct kobject *kobj,
+			      struct attribute *a, int index)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	if (!priv->pwm_present[index])
+		return 0;
+	return a->mode;
+}
+
+static umode_t fan_dev_is_visible(struct kobject *kobj,
+				  struct attribute *a, int index)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct aspeed_pwm_tachometer_data *priv = dev_get_drvdata(dev);
+
+	if (!priv->fan_tach_present[index])
+		return 0;
+	return a->mode;
+}
+
+static SENSOR_DEVICE_ATTR(pwm0, 0644,
+			show_pwm, set_pwm, 0);
+static SENSOR_DEVICE_ATTR(pwm1, 0644,
+			show_pwm, set_pwm, 1);
+static SENSOR_DEVICE_ATTR(pwm2, 0644,
+			show_pwm, set_pwm, 2);
+static SENSOR_DEVICE_ATTR(pwm3, 0644,
+			show_pwm, set_pwm, 3);
+static SENSOR_DEVICE_ATTR(pwm4, 0644,
+			show_pwm, set_pwm, 4);
+static SENSOR_DEVICE_ATTR(pwm5, 0644,
+			show_pwm, set_pwm, 5);
+static SENSOR_DEVICE_ATTR(pwm6, 0644,
+			show_pwm, set_pwm, 6);
+static SENSOR_DEVICE_ATTR(pwm7, 0644,
+			show_pwm, set_pwm, 7);
+static SENSOR_DEVICE_ATTR(pwm8, 0644,
+			show_pwm, set_pwm, 8);
+static SENSOR_DEVICE_ATTR(pwm9, 0644,
+			show_pwm, set_pwm, 9);
+static SENSOR_DEVICE_ATTR(pwm10, 0644,
+			show_pwm, set_pwm, 10);
+static SENSOR_DEVICE_ATTR(pwm11, 0644,
+			show_pwm, set_pwm, 11);
+static SENSOR_DEVICE_ATTR(pwm12, 0644,
+			show_pwm, set_pwm, 12);
+static SENSOR_DEVICE_ATTR(pwm13, 0644,
+			show_pwm, set_pwm, 13);
+static SENSOR_DEVICE_ATTR(pwm14, 0644,
+			show_pwm, set_pwm, 14);
+static SENSOR_DEVICE_ATTR(pwm15, 0644,
+			show_pwm, set_pwm, 15);
+static struct attribute *pwm_dev_attrs[] = {
+	&sensor_dev_attr_pwm0.dev_attr.attr,
+	&sensor_dev_attr_pwm1.dev_attr.attr,
+	&sensor_dev_attr_pwm2.dev_attr.attr,
+	&sensor_dev_attr_pwm3.dev_attr.attr,
+	&sensor_dev_attr_pwm4.dev_attr.attr,
+	&sensor_dev_attr_pwm5.dev_attr.attr,
+	&sensor_dev_attr_pwm6.dev_attr.attr,
+	&sensor_dev_attr_pwm7.dev_attr.attr,
+	&sensor_dev_attr_pwm8.dev_attr.attr,
+	&sensor_dev_attr_pwm9.dev_attr.attr,
+	&sensor_dev_attr_pwm10.dev_attr.attr,
+	&sensor_dev_attr_pwm11.dev_attr.attr,
+	&sensor_dev_attr_pwm12.dev_attr.attr,
+	&sensor_dev_attr_pwm13.dev_attr.attr,
+	&sensor_dev_attr_pwm14.dev_attr.attr,
+	&sensor_dev_attr_pwm15.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group pwm_dev_group = {
+	.attrs = pwm_dev_attrs,
+	.is_visible = pwm_is_visible,
+};
+
+static SENSOR_DEVICE_ATTR(fan0_input, 0444,
+		show_rpm, NULL, 0);
+static SENSOR_DEVICE_ATTR(fan1_input, 0444,
+		show_rpm, NULL, 1);
+static SENSOR_DEVICE_ATTR(fan2_input, 0444,
+		show_rpm, NULL, 2);
+static SENSOR_DEVICE_ATTR(fan3_input, 0444,
+		show_rpm, NULL, 3);
+static SENSOR_DEVICE_ATTR(fan4_input, 0444,
+		show_rpm, NULL, 4);
+static SENSOR_DEVICE_ATTR(fan5_input, 0444,
+		show_rpm, NULL, 5);
+static SENSOR_DEVICE_ATTR(fan6_input, 0444,
+		show_rpm, NULL, 6);
+static SENSOR_DEVICE_ATTR(fan7_input, 0444,
+		show_rpm, NULL, 7);
+static SENSOR_DEVICE_ATTR(fan8_input, 0444,
+		show_rpm, NULL, 8);
+static SENSOR_DEVICE_ATTR(fan9_input, 0444,
+		show_rpm, NULL, 9);
+static SENSOR_DEVICE_ATTR(fan10_input, 0444,
+		show_rpm, NULL, 10);
+static SENSOR_DEVICE_ATTR(fan11_input, 0444,
+		show_rpm, NULL, 11);
+static SENSOR_DEVICE_ATTR(fan12_input, 0444,
+		show_rpm, NULL, 12);
+static SENSOR_DEVICE_ATTR(fan13_input, 0444,
+		show_rpm, NULL, 13);
+static SENSOR_DEVICE_ATTR(fan14_input, 0444,
+		show_rpm, NULL, 14);
+static SENSOR_DEVICE_ATTR(fan15_input, 0444,
+		show_rpm, NULL, 15);
+static struct attribute *fan_dev_attrs[] = {
+	&sensor_dev_attr_fan0_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan4_input.dev_attr.attr,
+	&sensor_dev_attr_fan5_input.dev_attr.attr,
+	&sensor_dev_attr_fan6_input.dev_attr.attr,
+	&sensor_dev_attr_fan7_input.dev_attr.attr,
+	&sensor_dev_attr_fan8_input.dev_attr.attr,
+	&sensor_dev_attr_fan9_input.dev_attr.attr,
+	&sensor_dev_attr_fan10_input.dev_attr.attr,
+	&sensor_dev_attr_fan11_input.dev_attr.attr,
+	&sensor_dev_attr_fan12_input.dev_attr.attr,
+	&sensor_dev_attr_fan13_input.dev_attr.attr,
+	&sensor_dev_attr_fan14_input.dev_attr.attr,
+	&sensor_dev_attr_fan15_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group fan_dev_group = {
+	.attrs = fan_dev_attrs,
+	.is_visible = fan_dev_is_visible,
+};
+
+static void aspeed_create_pwm_channel(struct aspeed_pwm_tachometer_data *priv,
+				   u8 pwm_channel)
+{
+	priv->pwm_present[pwm_channel] = true;
+
+	//use default 
+	aspeed_set_pwm_channel_fan_ctrl(priv, pwm_channel, priv->pwm_channel[pwm_channel].duty_pt);
+}
+
+static void
+aspeed_create_fan_tach_channel(struct aspeed_pwm_tachometer_data *priv,
+			       u8 *fan_tach_ch, int count, u32 fan_pulse_pr,
+			       u32 fan_min_rpm, u32 tacho_div)
+{
+	u8 val, index;
+
+	for (val = 0; val < count; val++) {
+		index = fan_tach_ch[val];
+		priv->fan_tach_present[index] = true;
+		priv->tacho_channel[index].pulse_pr = fan_pulse_pr;
+		priv->tacho_channel[index].min_rpm = fan_min_rpm;
+		priv->tacho_channel[index].limited_inverse = 0;
+		priv->tacho_channel[index].threshold = 0;
+		priv->tacho_channel[index].tacho_edge = F2F_EDGES;
+		priv->tacho_channel[index].tacho_debounce = DEBOUNCE_3_CLK;
+		aspeed_set_fan_tach_ch_enable(priv, index, true, tacho_div);
+	}
+}
+
+static int
+aspeed_pwm_cz_get_max_state(struct thermal_cooling_device *tcdev,
+			    unsigned long *state)
+{
+	struct aspeed_cooling_device *cdev = tcdev->devdata;
+
+	*state = cdev->max_state;
+
+	return 0;
+}
+
+static int
+aspeed_pwm_cz_get_cur_state(struct thermal_cooling_device *tcdev,
+			    unsigned long *state)
+{
+	struct aspeed_cooling_device *cdev = tcdev->devdata;
+
+	*state = cdev->cur_state;
+
+	return 0;
+}
+
+static int
+aspeed_pwm_cz_set_cur_state(struct thermal_cooling_device *tcdev,
+			    unsigned long state)
+{
+	struct aspeed_cooling_device *cdev = tcdev->devdata;
+
+	if (state > cdev->max_state)
+		return -EINVAL;
+
+	cdev->cur_state = state;
+	cdev->priv->pwm_channel[cdev->pwm_channel].duty_pt =
+					cdev->cooling_levels[cdev->cur_state];
+	aspeed_set_pwm_channel_fan_ctrl(cdev->priv, cdev->pwm_channel,
+				     cdev->cooling_levels[cdev->cur_state]);
+
+	return 0;
+}
+
+static const struct thermal_cooling_device_ops aspeed_pwm_cool_ops = {
+	.get_max_state = aspeed_pwm_cz_get_max_state,
+	.get_cur_state = aspeed_pwm_cz_get_cur_state,
+	.set_cur_state = aspeed_pwm_cz_set_cur_state,
+};
+
+static int aspeed_create_pwm_cooling(struct device *dev,
+				     struct device_node *child,
+				     struct aspeed_pwm_tachometer_data *priv,
+				     u32 pwm_channel, u8 num_levels)
+{
+	int ret;
+	struct aspeed_cooling_device *cdev;
+
+	cdev = devm_kzalloc(dev, sizeof(*cdev), GFP_KERNEL);
+	if (!cdev)
+		return -ENOMEM;
+
+	cdev->cooling_levels = devm_kzalloc(dev, num_levels, GFP_KERNEL);
+	if (!cdev->cooling_levels)
+		return -ENOMEM;
+
+	cdev->max_state = num_levels - 1;
+	ret = of_property_read_u8_array(child, "cooling-levels",
+					cdev->cooling_levels,
+					num_levels);
+	if (ret) {
+		dev_err(dev, "Property 'cooling-levels' cannot be read.\n");
+		return ret;
+	}
+	snprintf(cdev->name, MAX_CDEV_NAME_LEN, "%s%d", child->name, pwm_channel);
+
+	cdev->tcdev = thermal_of_cooling_device_register(child,
+							 cdev->name,
+							 cdev,
+							 &aspeed_pwm_cool_ops);
+	if (IS_ERR(cdev->tcdev))
+		return PTR_ERR(cdev->tcdev);
+
+	cdev->priv = priv;
+	cdev->pwm_channel = pwm_channel;
+
+	priv->cdev[pwm_channel] = cdev;
+
+	return 0;
+}
+
+static int aspeed_pwm_create_fan(struct device *dev,
+			     struct device_node *child,
+			     struct aspeed_pwm_tachometer_data *priv)
+{
+	u8 *fan_tach_ch;
+	u32 fan_pulse_pr, fan_min_rpm;
+	u32 tacho_div;
+	u32 pwm_channel;
+	int ret, count;
+
+	ret = of_property_read_u32(child, "reg", &pwm_channel);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(child, "aspeed,target_pwm",
+				   &priv->pwm_channel[pwm_channel].target_freq);
+	if (ret)
+		priv->pwm_channel[pwm_channel].target_freq = DEFAULT_TARGET_PWM_FREQ;
+
+	ret = of_property_read_u32(child, "aspeed,default-duty-point",
+				   &priv->pwm_channel[pwm_channel].duty_pt);
+	if (ret)
+		priv->pwm_channel[pwm_channel].duty_pt = DEFAULT_DUTY_PT;
+
+	ret = of_property_read_u32(child, "aspeed,wdt-reload-duty-point",
+				   &priv->pwm_channel[pwm_channel].wdt_reload_duty_pt);
+	if (ret)
+		priv->pwm_channel[pwm_channel].wdt_reload_duty_pt = DEFAULT_WDT_RELOAD_DUTY_PT;
+
+	priv->pwm_channel[pwm_channel].wdt_reload_enable =
+		of_property_read_bool(child, "aspeed,wdt-reload-enable");
+
+	aspeed_create_pwm_channel(priv, (u8)pwm_channel);
+
+	ret = of_property_count_u8_elems(child, "cooling-levels");
+	if (ret > 0) {
+		if (IS_ENABLED(CONFIG_THERMAL)) {
+			ret = aspeed_create_pwm_cooling(dev, child, priv, pwm_channel,
+							ret);
+			if (ret)
+				return ret;
+		}
+	}
+
+	count = of_property_count_u8_elems(child, "aspeed,fan-tach-ch");
+	if (count < 1)
+		return -EINVAL;
+
+	fan_tach_ch = devm_kzalloc(dev, sizeof(*fan_tach_ch) * count,
+				   GFP_KERNEL);
+	if (!fan_tach_ch)
+		return -ENOMEM;
+	ret = of_property_read_u8_array(child, "aspeed,fan-tach-ch",
+					fan_tach_ch, count);
+	if (ret)
+		return ret;
+	
+	ret = of_property_read_u32(child, "aspeed,pulse-pr", &fan_pulse_pr);
+	if (ret)
+		fan_pulse_pr = DEFAULT_FAN_PULSE_PR;
+
+	ret = of_property_read_u32(child, "aspeed,min-rpm", &fan_min_rpm);
+	if (ret)
+		fan_min_rpm = DEFAULT_FAN_MIN_RPM;
+
+	ret = of_property_read_u32(child, "aspeed,tacho-div", &tacho_div);
+	if (ret)
+		tacho_div = DEFAULT_TACHO_DIV;
+
+	aspeed_create_fan_tach_channel(priv, fan_tach_ch, count, fan_pulse_pr,
+				       fan_min_rpm, tacho_div);
+
+	return 0;
+}
+
+static int aspeed_pwm_tachometer_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np, *child;
+	struct aspeed_pwm_tachometer_data *priv;
+	void __iomem *regs;
+	struct device *hwmon;
+	struct clk *clk;
+	int ret;
+	np = dev->of_node;
+
+	regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->pwm_channel =
+		devm_kzalloc(dev, 16 * sizeof(*priv->pwm_channel), GFP_KERNEL);
+	priv->tacho_channel =
+		devm_kzalloc(dev, 16 * sizeof(*priv->tacho_channel), GFP_KERNEL);
+
+	priv->regmap = devm_regmap_init(dev, NULL, (__force void *)regs,
+			&aspeed_pwm_tachometer_regmap_config);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(clk))
+		return -ENODEV;
+	priv->clk_freq = clk_get_rate(clk);
+
+	priv->reset = devm_reset_control_get(&pdev->dev, NULL);
+	if (IS_ERR(priv->reset)) {
+		dev_err(&pdev->dev, "can't get aspeed_pwm_tacho reset\n");
+		return PTR_ERR(priv->reset);
+	}
+
+	//scu init
+	reset_control_assert(priv->reset);
+	reset_control_deassert(priv->reset);
+
+	for_each_child_of_node(np, child) {
+		ret = aspeed_pwm_create_fan(dev, child, priv);
+		if (ret) {
+			of_node_put(child);
+			return ret;
+		}
+	}
+
+	priv->groups[0] = &pwm_dev_group;
+	priv->groups[1] = &fan_dev_group;
+	priv->groups[2] = NULL;
+	dev_info(dev, "pwm tach probe done\n");
+	hwmon = devm_hwmon_device_register_with_groups(dev,
+						       "aspeed_pwm_tachometer",
+						       priv, priv->groups);
+
+	return PTR_ERR_OR_ZERO(hwmon);
+}
+
+static const struct of_device_id of_pwm_tachometer_match_table[] = {
+	{ .compatible = "aspeed,ast2600-pwm-tachometer", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_pwm_tachometer_match_table);
+
+static struct platform_driver aspeed_pwm_tachometer_driver = {
+	.probe		= aspeed_pwm_tachometer_probe,
+	.driver		= {
+		.name	= "aspeed_pwm_tachometer",
+		.of_match_table = of_pwm_tachometer_match_table,
+	},
+};
+
+module_platform_driver(aspeed_pwm_tachometer_driver);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_DESCRIPTION("ASPEED PWM and Fan Tachometer device driver");
+MODULE_LICENSE("GPL");
diff -Naur linux_ori/drivers/hwmon/aspeed-pwm-tacho.c linux/drivers/hwmon/aspeed-pwm-tacho.c
--- linux_ori/drivers/hwmon/aspeed-pwm-tacho.c	2022-03-11 18:22:39.000000000 +0800
+++ linux/drivers/hwmon/aspeed-pwm-tacho.c	2022-08-15 11:50:54.622973078 +0800
@@ -62,6 +62,7 @@
 #define ASPEED_PTCR_CTRL_SET_PWMA_TYPE_PART2	3
 #define ASPEED_PTCR_CTRL_SET_PWMA_TYPE_MASK	(BIT(4) | BIT(12))
 
+#define	ASPEED_PTCR_CTRL_FAN_EN_MASK	GENMASK(31, 16)
 #define	ASPEED_PTCR_CTRL_FAN_NUM_EN(x)	BIT(16 + (x))
 
 #define	ASPEED_PTCR_CTRL_PWMD_EN	BIT(11)
@@ -152,13 +153,13 @@
 #define M_PWM_PERIOD 0x5F
 #define M_TACH_CLK_DIV 0x00
 /*
- * 5:4 Type N fan tach mode selection bit:
+ * 5:4 fan tach mode selection bit:
  * 00: falling
  * 01: rising
  * 10: both
  * 11: reserved.
  */
-#define M_TACH_MODE 0x02 /* 10b */
+#define M_TACH_MODE 0x00 /* 10b */
 #define M_TACH_UNIT 0x0210
 #define INIT_FAN_CTRL 0xFF
 
@@ -167,6 +168,9 @@
 
 #define MAX_CDEV_NAME_LEN 16
 
+#define DEFAULT_FAN_PULSE_PR 2
+#define DEFAULT_FAN_MIN_RPM 1000
+
 struct aspeed_cooling_device {
 	char name[16];
 	struct aspeed_pwm_tacho_data *priv;
@@ -194,6 +198,8 @@
 	u8 fan_tach_ch_source[16];
 	struct aspeed_cooling_device *cdev[8];
 	const struct attribute_group *groups[3];
+	u32 pulse_pr;
+	u32 minrpm;
 };
 
 enum type { TYPEM, TYPEN, TYPEO };
@@ -446,8 +452,9 @@
 
 	regmap_update_bits(regmap, type_params[type].ctrl_reg,
 			   TYPE_CTRL_FAN_MASK, reg_value);
+	/* Falling point need to less than tach period to avoid sample error */
 	regmap_update_bits(regmap, type_params[type].ctrl_reg1,
-			   TYPE_CTRL_FAN1_MASK, unit << 16);
+			   TYPE_CTRL_FAN1_MASK, (unit - 0x10) << 16);
 }
 
 static void aspeed_set_fan_tach_ch_enable(struct regmap *regmap, u8 fan_tach_ch,
@@ -497,12 +504,10 @@
 	}
 }
 
-static u32 aspeed_get_fan_tach_ch_measure_period(struct aspeed_pwm_tacho_data
-						 *priv, u8 type)
+static u32 aspeed_get_pwm_clock(struct aspeed_pwm_tacho_data *priv, u8 type)
 {
-	u32 clk;
-	u16 tacho_unit;
-	u8 clk_unit, div_h, div_l, tacho_div;
+	u32 clk, result;
+	u8 clk_unit, div_h, div_l;
 
 	clk = priv->clk_freq;
 	clk_unit = priv->type_pwm_clock_unit[type];
@@ -513,18 +518,26 @@
 		div_l = 1;
 	else
 		div_l = div_l * 2;
+	result = clk / (clk_unit * div_h * div_l);
+	return result;
+}
+
+static u32 aspeed_get_fan_tach_ch_measure_period(struct aspeed_pwm_tacho_data
+						 *priv, u8 type)
+{
+	u32 pwm_clk;
+	u16 tacho_unit;
 
 	tacho_unit = priv->type_fan_tach_unit[type];
-	tacho_div = priv->type_fan_tach_clock_division[type];
+	pwm_clk = aspeed_get_pwm_clock(priv, type);
 
-	tacho_div = 0x4 << (tacho_div * 2);
-	return clk / (clk_unit * div_h * div_l * tacho_div * tacho_unit);
+	return (tacho_unit * 1000000) / pwm_clk;
 }
 
 static int aspeed_get_fan_tach_ch_rpm(struct aspeed_pwm_tacho_data *priv,
 				      u8 fan_tach_ch)
 {
-	u32 raw_data, tach_div, clk_source, msec, usec, val;
+	u32 raw_data, tach_div, clk_source, usec, val;
 	u8 fan_tach_ch_source, type, mode, both;
 	int ret;
 
@@ -534,8 +547,7 @@
 	fan_tach_ch_source = priv->fan_tach_ch_source[fan_tach_ch];
 	type = priv->pwm_port_type[fan_tach_ch_source];
 
-	msec = (1000 / aspeed_get_fan_tach_ch_measure_period(priv, type));
-	usec = msec * 1000;
+	usec = aspeed_get_fan_tach_ch_measure_period(priv, type);
 
 	ret = regmap_read_poll_timeout(
 		priv->regmap,
@@ -545,10 +557,13 @@
 		ASPEED_RPM_STATUS_SLEEP_USEC,
 		usec);
 
-	/* return -ETIMEDOUT if we didn't get an answer. */
-	if (ret)
-		return ret;
-
+	if (ret) {
+		/* return 0 if we didn't get an answer because of timeout*/
+		if (ret == -ETIMEDOUT)
+			return 0;
+		else
+			return ret;
+	}
 	raw_data = val & RESULT_VALUE_MASK;
 	tach_div = priv->type_fan_tach_clock_division[type];
 	/*
@@ -557,14 +572,15 @@
 	 */
 	mode = priv->type_fan_tach_mode[type];
 	both = (mode & BOTH_EDGES) ? 1 : 0;
-
-	tach_div = (0x4 << both) << (tach_div * 2);
+	raw_data <<= both;
+	/* 4^(tach_div+1) */
+	tach_div = 0x4 << (tach_div * 2);
 	clk_source = priv->clk_freq;
 
 	if (raw_data == 0)
 		return 0;
 
-	return (clk_source * 60) / (2 * raw_data * tach_div);
+	return (clk_source * 60) / (priv->pulse_pr * raw_data * tach_div);
 }
 
 static ssize_t pwm_store(struct device *dev, struct device_attribute *attr,
@@ -712,6 +728,7 @@
  */
 static void aspeed_create_type(struct aspeed_pwm_tacho_data *priv)
 {
+	u32 tach_period, pwm_clk;
 	priv->type_pwm_clock_division_h[TYPEM] = M_PWM_DIV_H;
 	priv->type_pwm_clock_division_l[TYPEM] = M_PWM_DIV_L;
 	priv->type_pwm_clock_unit[TYPEM] = M_PWM_PERIOD;
@@ -719,10 +736,27 @@
 				    M_PWM_DIV_L, M_PWM_PERIOD);
 	aspeed_set_tacho_type_enable(priv->regmap, TYPEM, true);
 	priv->type_fan_tach_clock_division[TYPEM] = M_TACH_CLK_DIV;
-	priv->type_fan_tach_unit[TYPEM] = M_TACH_UNIT;
+	/*
+	 * min(Tach input clock) = (PulsePR * minRPM) / 60
+	 * max(Tach input period) = 60 / (PulsePR * minRPM)
+	 * Tach sample period > 2 * max(Tach input period) = (2*60) / (PulsePR * minRPM)
+	 * Tach sample period = PWM period * Tach period value = Tach period value / PWM clock
+	 * Tach period value / PWM clock > (2*60) / (PulsePR * minRPM)
+	 * Tach period value > (60 * 2 * PWM clock) / (PulsePR * miniRPM)
+	 */
+	pwm_clk = aspeed_get_pwm_clock(priv, TYPEM);
+	printk(KERN_INFO "tach period = 60 * 2 * %d / (%d * %d)", pwm_clk, priv->minrpm,
+	       priv->pulse_pr);
+	tach_period = 60 * 2 * aspeed_get_pwm_clock(priv, TYPEM) /
+		      (priv->minrpm * priv->pulse_pr);
+	/* Add the margin (about 1.2) of tach sample period to avoid sample miss */
+	tach_period = (tach_period * 1200) >> 10;
+
+	printk(KERN_INFO "tach period = %d", tach_period);
+	priv->type_fan_tach_unit[TYPEM] = tach_period;
 	priv->type_fan_tach_mode[TYPEM] = M_TACH_MODE;
 	aspeed_set_tacho_type_values(priv->regmap, TYPEM, M_TACH_MODE,
-				     M_TACH_UNIT, M_TACH_CLK_DIV);
+				     tach_period, M_TACH_CLK_DIV);
 }
 
 static void aspeed_create_pwm_port(struct aspeed_pwm_tacho_data *priv,
@@ -936,8 +970,20 @@
 	aspeed_set_clock_enable(priv->regmap, true);
 	aspeed_set_clock_source(priv->regmap, 0);
 
+	ret = of_property_read_u32(pdev->dev.of_node, "aspeed,min-rpm", &priv->minrpm);
+	if (ret)
+		priv->minrpm = DEFAULT_FAN_MIN_RPM;
+
+	ret = of_property_read_u32(pdev->dev.of_node, "aspeed,pulse-pr", &priv->pulse_pr);
+	if (ret)
+		priv->pulse_pr = DEFAULT_FAN_PULSE_PR;
+
 	aspeed_create_type(priv);
 
+	/* Disable all tach channels */
+	regmap_write_bits(priv->regmap, ASPEED_PTCR_CTRL,
+			  ASPEED_PTCR_CTRL_FAN_EN_MASK, 0);
+
 	for_each_child_of_node(np, child) {
 		ret = aspeed_create_fan(dev, child, priv);
 		if (ret) {
diff -Naur linux_ori/drivers/hwmon/dell-smm-hwmon.c linux/drivers/hwmon/dell-smm-hwmon.c
--- linux_ori/drivers/hwmon/dell-smm-hwmon.c	2022-03-11 18:22:39.000000000 +0800
+++ linux/drivers/hwmon/dell-smm-hwmon.c	2022-08-15 11:50:54.626973078 +0800
@@ -301,7 +301,7 @@
 }
 
 /*
- * Set the fan speed (off, low, high, ...).
+ * Set the fan speed (off, low, high). Returns the new fan status.
  */
 static int i8k_set_fan(int fan, int speed)
 {
@@ -313,7 +313,7 @@
 	speed = (speed < 0) ? 0 : ((speed > i8k_fan_max) ? i8k_fan_max : speed);
 	regs.ebx = (fan & 0xff) | (speed << 8);
 
-	return i8k_smm(&regs);
+	return i8k_smm(&regs) ? : i8k_get_fan_status(fan);
 }
 
 static int i8k_get_temp_type(int sensor)
@@ -427,7 +427,7 @@
 i8k_ioctl_unlocked(struct file *fp, unsigned int cmd, unsigned long arg)
 {
 	int val = 0;
-	int speed, err;
+	int speed;
 	unsigned char buff[16];
 	int __user *argp = (int __user *)arg;
 
@@ -488,11 +488,7 @@
 		if (copy_from_user(&speed, argp + 1, sizeof(int)))
 			return -EFAULT;
 
-		err = i8k_set_fan(val, speed);
-		if (err < 0)
-			return err;
-
-		val = i8k_get_fan_status(val);
+		val = i8k_set_fan(val, speed);
 		break;
 
 	default:
diff -Naur linux_ori/drivers/hwmon/Kconfig linux/drivers/hwmon/Kconfig
--- linux_ori/drivers/hwmon/Kconfig	2022-08-15 11:35:36.890973078 +0800
+++ linux/drivers/hwmon/Kconfig	2022-08-15 14:02:32.874973078 +0800
@@ -371,6 +371,12 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called aspeed_pwm_tacho.
 
+config SENSORS_ASPEED2600_PWM_TACHO
+	tristate "ASPEED AST2600 PWM and Fan Tachometer"
+	depends on THERMAL || THERMAL=n
+	help
+	  This driver provides support for ASPEED AST2600 PWM
+	  and Fan Tacho controllers.
 config SENSORS_ATXP1
 	tristate "Attansic ATXP1 VID controller"
 	depends on I2C
@@ -1571,6 +1577,14 @@
 	  This driver can also be built as a module. If so, the module will
 	  be called smm665.
 
+config SENSORS_TACH_ASPEED_AST2600
+	tristate "ASPEED ast2600 Tachometer support"
+	help
+	  This driver provides support for Aspeed ast2600 Tachometer.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called tach-aspeed-ast2600.
+
 config SENSORS_ADC128D818
 	tristate "Texas Instruments ADC128D818"
 	depends on I2C
diff -Naur linux_ori/drivers/hwmon/Makefile linux/drivers/hwmon/Makefile
--- linux_ori/drivers/hwmon/Makefile	2022-08-15 11:35:36.890973078 +0800
+++ linux/drivers/hwmon/Makefile	2022-08-15 14:02:53.654973078 +0800
@@ -49,7 +49,9 @@
 obj-$(CONFIG_SENSORS_ARM_SCPI)	+= scpi-hwmon.o
 obj-$(CONFIG_SENSORS_AS370)	+= as370-hwmon.o
 obj-$(CONFIG_SENSORS_ASC7621)	+= asc7621.o
+obj-$(CONFIG_SENSORS_TACH_ASPEED_AST2600) += tach-aspeed-ast2600.o
 obj-$(CONFIG_SENSORS_ASPEED)	+= aspeed-pwm-tacho.o
+obj-$(CONFIG_SENSORS_ASPEED2600_PWM_TACHO)	+= aspeed2600-pwm-tacho.o
 obj-$(CONFIG_SENSORS_ATXP1)	+= atxp1.o
 obj-$(CONFIG_SENSORS_CORETEMP)	+= coretemp.o
 obj-$(CONFIG_SENSORS_DA9052_ADC)+= da9052-hwmon.o
diff -Naur linux_ori/drivers/hwmon/tach-aspeed-ast2600.c linux/drivers/hwmon/tach-aspeed-ast2600.c
--- linux_ori/drivers/hwmon/tach-aspeed-ast2600.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/hwmon/tach-aspeed-ast2600.c	2022-08-15 11:50:54.890973078 +0800
@@ -0,0 +1,388 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) ASPEED Technology Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 or later as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/syscon.h>
+#include <linux/sysfs.h>
+#include <linux/reset.h>
+#include <linux/regmap.h>
+/* TACH Control Register */
+#define ASPEED_TACHO_CTRL_CH(ch) ((ch * 0x10) + 0x08)
+#define TACHO_IER BIT(31) //enable tacho interrupt
+#define TACHO_INVERS_LIMIT BIT(30) //inverse tacho limit comparison
+#define TACHO_LOOPBACK BIT(29) //tacho loopback
+#define TACHO_ENABLE BIT(28) //{enable tacho}
+#define TACHO_DEBOUNCE_MASK (0x3 << 26) //{tacho de-bounce}
+#define TACHO_DEBOUNCE_BIT (26) //{tacho de-bounce}
+#define TECHIO_EDGE_MASK (0x3 << 24) //tacho edge}
+#define TECHIO_EDGE_BIT (24) //tacho edge}
+#define TACHO_CLK_DIV_T_MASK (0xf << 20)
+#define TACHO_CLK_DIV_BIT (20)
+#define TACHO_THRESHOLD_MASK (0xfffff) //tacho threshold bit
+/* [27:26] */
+#define DEBOUNCE_3_CLK 0x00 /* 10b */
+#define DEBOUNCE_2_CLK 0x01 /* 10b */
+#define DEBOUNCE_1_CLK 0x02 /* 10b */
+#define DEBOUNCE_0_CLK 0x03 /* 10b */
+/* [25:24] */
+#define F2F_EDGES 0x00 /* 10b */
+#define R2R_EDGES 0x01 /* 10b */
+#define BOTH_EDGES 0x02 /* 10b */
+/* [23:20] */
+/* Cover rpm range 5~5859375 */
+#define DEFAULT_TACHO_DIV 5
+
+/* TACH Status Register */
+#define ASPEED_TACHO_STS_CH(x) ((x * 0x10) + 0x0C)
+
+/*PWM_TACHO_STS */
+#define TACHO_ISR BIT(31) //interrupt status and clear
+#define PWM_OUT BIT(25) //{pwm_out}
+#define PWM_OEN BIT(24) //{pwm_oeN}
+#define TACHO_DEB_INPUT BIT(23) //tacho deB input
+#define TACHO_RAW_INPUT BIT(22) //tacho raw input}
+#define TACHO_VALUE_UPDATE BIT(21) //tacho value updated since the last read
+#define TACHO_FULL_MEASUREMENT BIT(20) //{tacho full measurement}
+#define TACHO_VALUE_MASK 0xfffff //tacho value bit [19:0]}
+/**********************************************************
+ * Software setting
+ *********************************************************/
+#define DEFAULT_FAN_MIN_RPM 1000
+#define DEFAULT_FAN_PULSE_PR 2
+/*
+ * Add this value to avoid CPU consuming a lot of resources in waiting rpm
+ * updating. Assume the max rpm of fan is 60000, the period of updating tach
+ * value will equal to (1000000 * 2 * 60) / (2 * max_rpm) = 1000.
+ */
+#define RPM_POLLING_PERIOD_US 1000
+
+struct aspeed_tacho_channel_params {
+	int limited_inverse;
+	u16 threshold;
+	u8 tacho_edge;
+	u8 tacho_debounce;
+	u8 pulse_pr;
+	u32 min_rpm;
+	u32 divide;
+	u32 sample_period; /* unit is us */
+};
+
+struct aspeed_tach_data {
+	struct regmap *regmap;
+	unsigned long clk_freq;
+	struct reset_control *reset;
+	bool tach_present[16];
+	struct aspeed_tacho_channel_params *tacho_channel;
+	/* for hwmon */
+	const struct attribute_group *groups[2];
+};
+
+static u32 aspeed_get_fan_tach_sample_period(struct aspeed_tach_data *priv,
+					     u8 fan_tach_ch)
+{
+	u32 tach_period_us;
+	u8 pulse_pr = priv->tacho_channel[fan_tach_ch].pulse_pr;
+	u32 min_rpm = priv->tacho_channel[fan_tach_ch].min_rpm;
+	/*
+	 * min(Tach input clock) = (PulsePR * minRPM) / 60
+	 * max(Tach input period) = 60 / (PulsePR * minRPM)
+	 * Tach sample period > 2 * max(Tach input period) = (2*60) / (PulsePR * minRPM)
+	 */
+	tach_period_us = (1000000 * 2 * 60) / (pulse_pr * min_rpm);
+	/* Add the margin (about 1.2) of tach sample period to avoid sample miss */
+	tach_period_us = (tach_period_us * 1200) >> 10;
+	pr_debug("tach%d sample period = %dus", fan_tach_ch, tach_period_us);
+	return tach_period_us;
+}
+
+static void aspeed_set_fan_tach_ch_enable(struct aspeed_tach_data *priv,
+					  u8 fan_tach_ch, bool enable,
+					  u32 tacho_div)
+{
+	u32 reg_value = 0;
+
+	if (enable) {
+		/* divide = 2^(tacho_div*2) */
+		priv->tacho_channel[fan_tach_ch].divide = 1 << (tacho_div << 1);
+
+		reg_value = TACHO_ENABLE |
+			    (priv->tacho_channel[fan_tach_ch].tacho_edge
+			     << TECHIO_EDGE_BIT) |
+			    (tacho_div << TACHO_CLK_DIV_BIT) |
+			    (priv->tacho_channel[fan_tach_ch].tacho_debounce
+			     << TACHO_DEBOUNCE_BIT);
+
+		if (priv->tacho_channel[fan_tach_ch].limited_inverse)
+			reg_value |= TACHO_INVERS_LIMIT;
+
+		if (priv->tacho_channel[fan_tach_ch].threshold)
+			reg_value |=
+				(TACHO_IER |
+				 priv->tacho_channel[fan_tach_ch].threshold);
+
+		regmap_write(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch),
+			     reg_value);
+
+		priv->tacho_channel[fan_tach_ch].sample_period =
+			aspeed_get_fan_tach_sample_period(priv, fan_tach_ch);
+	} else
+		regmap_update_bits(priv->regmap,
+				   ASPEED_TACHO_CTRL_CH(fan_tach_ch),
+				   TACHO_ENABLE, 0);
+}
+
+static int aspeed_get_fan_tach_ch_rpm(struct aspeed_tach_data *priv,
+				      u8 fan_tach_ch)
+{
+	u32 raw_data, tach_div, clk_source, usec, val;
+	u64 rpm;
+	int ret;
+
+	usec = priv->tacho_channel[fan_tach_ch].sample_period;
+	/* Restart the Tach channel to guarantee the value is fresh */
+	regmap_update_bits(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch),
+			     TACHO_ENABLE, 0);
+	regmap_update_bits(priv->regmap, ASPEED_TACHO_CTRL_CH(fan_tach_ch),
+			     TACHO_ENABLE, TACHO_ENABLE);
+	ret = regmap_read_poll_timeout(
+		priv->regmap, ASPEED_TACHO_STS_CH(fan_tach_ch), val,
+		(val & TACHO_FULL_MEASUREMENT) && (val & TACHO_VALUE_UPDATE),
+		RPM_POLLING_PERIOD_US, usec);
+
+	if (ret) {
+		/* return 0 if we didn't get an answer because of timeout*/
+		if (ret == -ETIMEDOUT)
+			return 0;
+		else
+			return ret;
+	}
+
+	raw_data = val & TACHO_VALUE_MASK;
+	/*
+	 * We need the mode to determine if the raw_data is double (from
+	 * counting both edges).
+	 */
+	if (priv->tacho_channel[fan_tach_ch].tacho_edge == BOTH_EDGES)
+		raw_data <<= 1;
+
+	tach_div = raw_data * (priv->tacho_channel[fan_tach_ch].divide) *
+		   (priv->tacho_channel[fan_tach_ch].pulse_pr);
+
+	pr_debug("clk %ld, raw_data %d , tach_div %d\n", priv->clk_freq, raw_data, tach_div);
+
+	clk_source = priv->clk_freq;
+
+	if (tach_div == 0)
+		return -EDOM;
+
+	rpm = (u64)clk_source * 60;
+	do_div(rpm, tach_div);
+
+	return rpm;
+}
+
+static ssize_t show_rpm(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int index = sensor_attr->index;
+	int rpm;
+	struct aspeed_tach_data *priv = dev_get_drvdata(dev);
+
+	rpm = aspeed_get_fan_tach_ch_rpm(priv, index);
+	if (rpm < 0)
+		return rpm;
+
+	return sprintf(buf, "%d\n", rpm);
+}
+
+static umode_t fan_dev_is_visible(struct kobject *kobj, struct attribute *a,
+				  int index)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct aspeed_tach_data *priv = dev_get_drvdata(dev);
+
+	if (!priv->tach_present[index])
+		return 0;
+	return a->mode;
+}
+
+static SENSOR_DEVICE_ATTR(fan1_input, 0444, show_rpm, NULL, 0);
+static SENSOR_DEVICE_ATTR(fan2_input, 0444, show_rpm, NULL, 1);
+static SENSOR_DEVICE_ATTR(fan3_input, 0444, show_rpm, NULL, 2);
+static SENSOR_DEVICE_ATTR(fan4_input, 0444, show_rpm, NULL, 3);
+static SENSOR_DEVICE_ATTR(fan5_input, 0444, show_rpm, NULL, 4);
+static SENSOR_DEVICE_ATTR(fan6_input, 0444, show_rpm, NULL, 5);
+static SENSOR_DEVICE_ATTR(fan7_input, 0444, show_rpm, NULL, 6);
+static SENSOR_DEVICE_ATTR(fan8_input, 0444, show_rpm, NULL, 7);
+static SENSOR_DEVICE_ATTR(fan9_input, 0444, show_rpm, NULL, 8);
+static SENSOR_DEVICE_ATTR(fan10_input, 0444, show_rpm, NULL, 9);
+static SENSOR_DEVICE_ATTR(fan11_input, 0444, show_rpm, NULL, 10);
+static SENSOR_DEVICE_ATTR(fan12_input, 0444, show_rpm, NULL, 11);
+static SENSOR_DEVICE_ATTR(fan13_input, 0444, show_rpm, NULL, 12);
+static SENSOR_DEVICE_ATTR(fan14_input, 0444, show_rpm, NULL, 13);
+static SENSOR_DEVICE_ATTR(fan15_input, 0444, show_rpm, NULL, 14);
+static SENSOR_DEVICE_ATTR(fan16_input, 0444, show_rpm, NULL, 15);
+static struct attribute *fan_dev_attrs[] = {
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	&sensor_dev_attr_fan2_input.dev_attr.attr,
+	&sensor_dev_attr_fan3_input.dev_attr.attr,
+	&sensor_dev_attr_fan4_input.dev_attr.attr,
+	&sensor_dev_attr_fan5_input.dev_attr.attr,
+	&sensor_dev_attr_fan6_input.dev_attr.attr,
+	&sensor_dev_attr_fan7_input.dev_attr.attr,
+	&sensor_dev_attr_fan8_input.dev_attr.attr,
+	&sensor_dev_attr_fan9_input.dev_attr.attr,
+	&sensor_dev_attr_fan10_input.dev_attr.attr,
+	&sensor_dev_attr_fan11_input.dev_attr.attr,
+	&sensor_dev_attr_fan12_input.dev_attr.attr,
+	&sensor_dev_attr_fan13_input.dev_attr.attr,
+	&sensor_dev_attr_fan14_input.dev_attr.attr,
+	&sensor_dev_attr_fan15_input.dev_attr.attr,
+	&sensor_dev_attr_fan16_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group fan_dev_group = {
+	.attrs = fan_dev_attrs,
+	.is_visible = fan_dev_is_visible,
+};
+
+static void aspeed_create_fan_tach_channel(struct aspeed_tach_data *priv,
+					   u32 tach_ch, int count,
+					   u32 fan_pulse_pr, u32 fan_min_rpm,
+					   u32 tacho_div)
+{
+	priv->tach_present[tach_ch] = true;
+	priv->tacho_channel[tach_ch].pulse_pr = fan_pulse_pr;
+	priv->tacho_channel[tach_ch].min_rpm = fan_min_rpm;
+	priv->tacho_channel[tach_ch].limited_inverse = 0;
+	priv->tacho_channel[tach_ch].threshold = 0;
+	priv->tacho_channel[tach_ch].tacho_edge = F2F_EDGES;
+	priv->tacho_channel[tach_ch].tacho_debounce = DEBOUNCE_3_CLK;
+	aspeed_set_fan_tach_ch_enable(priv, tach_ch, true, tacho_div);
+}
+
+static int aspeed_tach_create_fan(struct device *dev, struct device_node *child,
+				  struct aspeed_tach_data *priv)
+{
+	u32 fan_pulse_pr, fan_min_rpm;
+	u32 tacho_div;
+	u32 tach_channel;
+	int ret, count;
+
+	ret = of_property_read_u32(child, "reg", &tach_channel);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(child, "aspeed,pulse-pr", &fan_pulse_pr);
+	if (ret)
+		fan_pulse_pr = DEFAULT_FAN_PULSE_PR;
+
+	ret = of_property_read_u32(child, "aspeed,min-rpm", &fan_min_rpm);
+	if (ret)
+		fan_min_rpm = DEFAULT_FAN_MIN_RPM;
+
+	ret = of_property_read_u32(child, "aspeed,tach-div", &tacho_div);
+	if (ret)
+		tacho_div = DEFAULT_TACHO_DIV;
+
+	aspeed_create_fan_tach_channel(priv, tach_channel, count, fan_pulse_pr,
+				       fan_min_rpm, tacho_div);
+
+	return 0;
+}
+
+static int aspeed_tach_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np, *child;
+	struct aspeed_tach_data *priv;
+	struct device *hwmon;
+	struct clk *clk;
+	int ret;
+
+	np = dev->parent->of_node;
+	dev_info(dev, "tach probe start\n");
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->tacho_channel = devm_kzalloc(
+		dev, 16 * sizeof(*priv->tacho_channel), GFP_KERNEL);
+
+	priv->regmap = syscon_node_to_regmap(np);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(dev, "Couldn't get regmap\n");
+		return -ENODEV;
+	}
+
+	clk = of_clk_get(np, 0);
+	if (IS_ERR(clk))
+		return -ENODEV;
+	priv->clk_freq = clk_get_rate(clk);
+
+	priv->reset = of_reset_control_get_shared(np, NULL);
+	if (IS_ERR(priv->reset)) {
+		dev_err(&pdev->dev, "can't get aspeed_pwm_tacho reset\n");
+		return PTR_ERR(priv->reset);
+	}
+
+	//scu init
+	reset_control_deassert(priv->reset);
+
+	for_each_child_of_node(dev->of_node, child) {
+		ret = aspeed_tach_create_fan(dev, child, priv);
+		if (ret) {
+			of_node_put(child);
+			return ret;
+		}
+	}
+
+	priv->groups[0] = &fan_dev_group;
+	priv->groups[1] = NULL;
+	dev_info(dev, "tach probe done\n");
+	hwmon = devm_hwmon_device_register_with_groups(dev, "aspeed_tach", priv,
+						       priv->groups);
+
+	return PTR_ERR_OR_ZERO(hwmon);
+}
+
+static const struct of_device_id of_stach_match_table[] = {
+	{
+		.compatible = "aspeed,ast2600-tach",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_stach_match_table);
+
+static struct platform_driver aspeed_tach_driver = {
+	.probe		= aspeed_tach_probe,
+	.driver		= {
+		.name	= "aspeed_tach",
+		.of_match_table = of_stach_match_table,
+	},
+};
+
+module_platform_driver(aspeed_tach_driver);
+
+MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
+MODULE_DESCRIPTION("ASPEED Fan tach device driver");
+MODULE_LICENSE("GPL");
diff -Naur linux_ori/drivers/pwm/Kconfig linux/drivers/pwm/Kconfig
--- linux_ori/drivers/pwm/Kconfig	2022-03-11 18:22:39.000000000 +0800
+++ linux/drivers/pwm/Kconfig	2022-08-15 12:11:51.046973078 +0800
@@ -42,6 +42,16 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-ab8500.
 
+config PWM_ASPEED_AST2600
+	tristate "Aspeed ast2600 PWM support"
+	depends on ARCH_ASPEED || COMPILE_TEST
+	help
+	  This driver provides support for Aspeed ast2600 PWM controllers.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-aspeed-ast2600.
+
+
 config PWM_ATMEL
 	tristate "Atmel PWM support"
 	depends on ARCH_AT91 && OF
diff -Naur linux_ori/drivers/pwm/Makefile linux/drivers/pwm/Makefile
--- linux_ori/drivers/pwm/Makefile	2022-03-11 18:22:39.000000000 +0800
+++ linux/drivers/pwm/Makefile	2022-08-15 12:11:51.046973078 +0800
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_PWM)		+= core.o
 obj-$(CONFIG_PWM_SYSFS)		+= sysfs.o
+obj-$(CONFIG_PWM_ASPEED_AST2600)	+= pwm-aspeed-ast2600.o
 obj-$(CONFIG_PWM_AB8500)	+= pwm-ab8500.o
 obj-$(CONFIG_PWM_ATMEL)		+= pwm-atmel.o
 obj-$(CONFIG_PWM_ATMEL_HLCDC_PWM)	+= pwm-atmel-hlcdc.o
diff -Naur linux_ori/drivers/pwm/pwm-aspeed-ast2600.c linux/drivers/pwm/pwm-aspeed-ast2600.c
--- linux_ori/drivers/pwm/pwm-aspeed-ast2600.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/pwm/pwm-aspeed-ast2600.c	2022-08-15 12:11:51.050973078 +0800
@@ -0,0 +1,365 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Aspeed Technology Inc.
+ *
+ * PWM controller driver for Aspeed ast2600 SoCs.
+ * This drivers doesn't support earlier version of the IP.
+ *
+ * The formula of pwm period duration:
+ * period duration = ((DIV_L + 1) * (PERIOD + 1) << DIV_H) / input-clk
+ *
+ * The formula of pwm duty cycle duration:
+ * duty cycle duration = period duration * DUTY_CYCLE_FALLING_POINT / (PERIOD + 1)
+ * = ((DIV_L + 1) * DUTY_CYCLE_FALLING_POINT << DIV_H) / input-clk
+ *
+ * The software driver fixes the period to 255, which causes the high-frequency
+ * precision of the PWM to be coarse, in exchange for the fineness of the duty cycle.
+ *
+ * Register usage:
+ * PIN_ENABLE: When it is unset the pwm controller will always output low to the extern.
+ * Use to determine whether the PWM channel is enabled or disabled
+ * CLK_ENABLE: When it is unset the pwm controller will reset the duty counter to 0 and
+ * output low to the PIN_ENABLE mux after that the driver can still change the pwm period
+ * and duty and the value will apply when CLK_ENABLE be set again.
+ * Use to determine whether duty_cycle bigger than 0.
+ * PWM_ASPEED_CTRL_INVERSE: When it is toggled the output value will inverse immediately.
+ * PWM_ASPEED_DUTY_CYCLE_FALLING_POINT/PWM_ASPEED_DUTY_CYCLE_RISING_POINT: When these two
+ * values are equal it means the duty cycle = 100%.
+ *
+ * Limitations:
+ * - When changing both duty cycle and period, we cannot prevent in
+ *   software that the output might produce a period with mixed
+ *   settings.
+ * - Disabling the PWM doesn't complete the current period.
+ *
+ * Improvements:
+ * - When only changing one of duty cycle or period, our pwm controller will not
+ *   generate the glitch, the configure will change at next cycle of pwm.
+ *   This improvement can disable/enable through PWM_ASPEED_CTRL_DUTY_SYNC_DISABLE.
+ */
+
+#include <linux/clk.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/reset.h>
+#include <linux/regmap.h>
+#include <linux/bitfield.h>
+#include <linux/slab.h>
+#include <linux/pwm.h>
+#include <linux/math64.h>
+
+/* The channel number of Aspeed pwm controller */
+#define PWM_ASPEED_NR_PWMS 16
+
+/* PWM Control Register */
+#define PWM_ASPEED_CTRL(ch) ((ch) * 0x10 + 0x00)
+#define PWM_ASPEED_CTRL_LOAD_SEL_RISING_AS_WDT BIT(19)
+#define PWM_ASPEED_CTRL_DUTY_LOAD_AS_WDT_ENABLE BIT(18)
+#define PWM_ASPEED_CTRL_DUTY_SYNC_DISABLE BIT(17)
+#define PWM_ASPEED_CTRL_CLK_ENABLE BIT(16)
+#define PWM_ASPEED_CTRL_LEVEL_OUTPUT BIT(15)
+#define PWM_ASPEED_CTRL_INVERSE BIT(14)
+#define PWM_ASPEED_CTRL_OPEN_DRAIN_ENABLE BIT(13)
+#define PWM_ASPEED_CTRL_PIN_ENABLE BIT(12)
+#define PWM_ASPEED_CTRL_CLK_DIV_H GENMASK(11, 8)
+#define PWM_ASPEED_CTRL_CLK_DIV_L GENMASK(7, 0)
+
+/* PWM Duty Cycle Register */
+#define PWM_ASPEED_DUTY_CYCLE(ch) ((ch) * 0x10 + 0x04)
+#define PWM_ASPEED_DUTY_CYCLE_PERIOD GENMASK(31, 24)
+#define PWM_ASPEED_DUTY_CYCLE_POINT_AS_WDT GENMASK(23, 16)
+#define PWM_ASPEED_DUTY_CYCLE_FALLING_POINT GENMASK(15, 8)
+#define PWM_ASPEED_DUTY_CYCLE_RISING_POINT GENMASK(7, 0)
+
+/* PWM fixed value */
+#define PWM_ASPEED_FIXED_PERIOD 0xff
+
+struct aspeed_pwm_data {
+	struct pwm_chip chip;
+	struct clk *clk;
+	struct regmap *regmap;
+	struct reset_control *reset;
+};
+
+static inline struct aspeed_pwm_data *
+aspeed_pwm_chip_to_data(struct pwm_chip *chip)
+{
+	return container_of(chip, struct aspeed_pwm_data, chip);
+}
+
+static void aspeed_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
+				 struct pwm_state *state)
+{
+	struct device *dev = chip->dev;
+	struct aspeed_pwm_data *priv = aspeed_pwm_chip_to_data(chip);
+	u32 index = pwm->hwpwm;
+	bool polarity, ch_en, clk_en;
+	u32 duty_pt, val;
+	unsigned long rate;
+	u64 div_h, div_l, clk_period;
+
+	regmap_read(priv->regmap, PWM_ASPEED_CTRL(index), &val);
+	polarity = FIELD_GET(PWM_ASPEED_CTRL_INVERSE, val);
+	ch_en = FIELD_GET(PWM_ASPEED_CTRL_PIN_ENABLE, val);
+	clk_en = FIELD_GET(PWM_ASPEED_CTRL_CLK_ENABLE, val);
+	div_h = FIELD_GET(PWM_ASPEED_CTRL_CLK_DIV_H, val);
+	div_l = FIELD_GET(PWM_ASPEED_CTRL_CLK_DIV_L, val);
+	regmap_read(priv->regmap, PWM_ASPEED_DUTY_CYCLE(index), &val);
+	duty_pt = FIELD_GET(PWM_ASPEED_DUTY_CYCLE_FALLING_POINT, val);
+	clk_period = FIELD_GET(PWM_ASPEED_DUTY_CYCLE_PERIOD, val);
+
+	rate = clk_get_rate(priv->clk);
+	state->period = DIV_ROUND_UP_ULL(
+		(u64)NSEC_PER_SEC * (div_l + 1) * (clk_period + 1) << div_h,
+		rate);
+
+	if (clk_en && duty_pt)
+		state->duty_cycle = DIV_ROUND_UP_ULL(
+			(u64)NSEC_PER_SEC * (div_l + 1) * duty_pt << div_h,
+			rate);
+	else
+		state->duty_cycle = clk_en ? state->period : 0;
+	state->polarity = polarity;
+	state->enabled = ch_en;
+	dev_dbg(dev, "get period: %dns, duty_cycle: %dns", state->period,
+		state->duty_cycle);
+}
+
+static int aspeed_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+			    const struct pwm_state *state)
+{
+	struct device *dev = chip->dev;
+	struct aspeed_pwm_data *priv = aspeed_pwm_chip_to_data(chip);
+	u32 index = pwm->hwpwm, duty_pt;
+	unsigned long rate;
+	u64 div_h, div_l, divisor;
+	bool clk_en;
+
+	dev_dbg(dev, "expect period: %dns, duty_cycle: %dns", state->period,
+		state->duty_cycle);
+
+	rate = clk_get_rate(priv->clk);
+	/*
+	 * Pick the smallest value for div_h so that div_l can be the biggest
+	 * which results in a finer resolution near the target period value.
+	 */
+	divisor = (u64)NSEC_PER_SEC * (PWM_ASPEED_FIXED_PERIOD + 1) *
+		  (PWM_ASPEED_CTRL_CLK_DIV_L + 1);
+	div_h = order_base_2(
+		DIV64_U64_ROUND_UP((u64)rate * state->period, divisor));
+	if (div_h > 0xf)
+		div_h = 0xf;
+
+	divisor = ((u64)NSEC_PER_SEC * (PWM_ASPEED_FIXED_PERIOD + 1)) << div_h;
+	div_l = div64_u64((u64)rate * state->period, divisor);
+
+	if (div_l == 0)
+		return -ERANGE;
+
+	div_l -= 1;
+
+	if (div_l > 255)
+		div_l = 255;
+
+	dev_dbg(dev, "clk source: %ld div_h %lld, div_l : %lld\n", rate, div_h,
+		div_l);
+	/* duty_pt = duty_cycle * (PERIOD + 1) / period */
+	duty_pt = div64_u64(state->duty_cycle * (u64)rate,
+			    (u64)NSEC_PER_SEC * (div_l + 1) << div_h);
+	dev_dbg(dev, "duty_cycle = %d, duty_pt = %d\n", state->duty_cycle,
+		 duty_pt);
+
+	regmap_update_bits(priv->regmap, PWM_ASPEED_CTRL(index),
+			   PWM_ASPEED_CTRL_PIN_ENABLE,
+			   state->enabled ? PWM_ASPEED_CTRL_PIN_ENABLE : 0);
+
+	if (duty_pt == 0)
+		clk_en = 0;
+	else {
+		clk_en = 1;
+		if (duty_pt >= (PWM_ASPEED_FIXED_PERIOD + 1))
+			duty_pt = 0;
+		/*
+		 * Fixed DUTY_CYCLE_PERIOD to its max value to get a
+		 * fine-grained resolution for duty_cycle at the expense of a
+		 * coarser period resolution.
+		 */
+		regmap_update_bits(priv->regmap, PWM_ASPEED_DUTY_CYCLE(index),
+				PWM_ASPEED_DUTY_CYCLE_PERIOD |
+				PWM_ASPEED_DUTY_CYCLE_RISING_POINT |
+				PWM_ASPEED_DUTY_CYCLE_FALLING_POINT,
+				FIELD_PREP(PWM_ASPEED_DUTY_CYCLE_PERIOD,
+					PWM_ASPEED_FIXED_PERIOD) |
+				FIELD_PREP(PWM_ASPEED_DUTY_CYCLE_FALLING_POINT,
+				   duty_pt));
+	}
+
+	regmap_update_bits(priv->regmap, PWM_ASPEED_CTRL(index),
+			   PWM_ASPEED_CTRL_CLK_DIV_H |
+			   PWM_ASPEED_CTRL_CLK_DIV_L |
+			   PWM_ASPEED_CTRL_CLK_ENABLE |
+			   PWM_ASPEED_CTRL_INVERSE,
+			   FIELD_PREP(PWM_ASPEED_CTRL_CLK_DIV_H, div_h) |
+			   FIELD_PREP(PWM_ASPEED_CTRL_CLK_DIV_L, div_l) |
+			   FIELD_PREP(PWM_ASPEED_CTRL_CLK_ENABLE, clk_en) |
+			   FIELD_PREP(PWM_ASPEED_CTRL_INVERSE,
+			   state->polarity));
+	return 0;
+}
+
+static const struct pwm_ops aspeed_pwm_ops = {
+	.apply = aspeed_pwm_apply,
+	.get_state = aspeed_pwm_get_state,
+	.owner = THIS_MODULE,
+};
+
+static int aspeed_pwm_extend_feature(struct device *dev,
+				     struct device_node *child,
+				     struct aspeed_pwm_data *priv)
+{
+	u32 hwpwm, wdt_reload_duty;
+	bool wdt_reload_en;
+	int ret;
+
+	wdt_reload_en = of_property_read_bool(child, "aspeed,wdt-reload-enable");
+	if (!wdt_reload_en)
+		return wdt_reload_en;
+
+	ret = of_property_read_u32(child, "reg", &hwpwm);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_u32(child, "aspeed,wdt-reload-duty-point",
+				   &wdt_reload_duty);
+	if (ret)
+		return ret;
+
+	regmap_update_bits(
+		priv->regmap, PWM_ASPEED_CTRL(hwpwm),
+		PWM_ASPEED_CTRL_LOAD_SEL_RISING_AS_WDT |
+			PWM_ASPEED_CTRL_DUTY_LOAD_AS_WDT_ENABLE,
+		FIELD_PREP(PWM_ASPEED_CTRL_LOAD_SEL_RISING_AS_WDT, 0) |
+			FIELD_PREP(PWM_ASPEED_CTRL_DUTY_LOAD_AS_WDT_ENABLE,
+				   wdt_reload_en));
+	regmap_update_bits(priv->regmap, PWM_ASPEED_DUTY_CYCLE(hwpwm),
+			   PWM_ASPEED_DUTY_CYCLE_POINT_AS_WDT,
+			   FIELD_PREP(PWM_ASPEED_DUTY_CYCLE_POINT_AS_WDT,
+				      wdt_reload_duty));
+	return 0;
+}
+
+static int aspeed_pwm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+	struct aspeed_pwm_data *priv;
+	struct device_node *np, *child;
+	struct platform_device *parent_dev;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	np = pdev->dev.parent->of_node;
+	if (!of_device_is_compatible(np, "aspeed,ast2600-pwm-tach")) {
+		dev_err(dev, "unsupported pwm device binding\n");
+		return -ENODEV;
+	}
+
+	priv->regmap = syscon_node_to_regmap(np);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(dev, "Couldn't get regmap\n");
+		return PTR_ERR(priv->regmap);
+	}
+
+	parent_dev = of_find_device_by_node(np);
+	priv->clk = devm_clk_get(&parent_dev->dev, 0);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "get clock failed\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret) {
+		dev_err(dev, "couldn't enable clock\n");
+		return ret;
+	}
+
+	priv->reset = devm_reset_control_get_shared(&parent_dev->dev, NULL);
+	if (IS_ERR(priv->reset)) {
+		dev_err(dev, "get reset failed\n");
+		return PTR_ERR(priv->reset);
+	}
+	ret = reset_control_deassert(priv->reset);
+	if (ret) {
+		dev_err(dev, "cannot deassert reset control: %pe\n",
+			ERR_PTR(ret));
+		goto err_disable_clk;
+	}
+
+	for_each_child_of_node(dev->of_node, child) {
+		ret = aspeed_pwm_extend_feature(dev, child, priv);
+		if (ret)
+			dev_warn(dev, "Set extend feature failed %d\n", ret);
+	}
+
+	priv->chip.dev = dev;
+	priv->chip.ops = &aspeed_pwm_ops;
+	priv->chip.npwm = PWM_ASPEED_NR_PWMS;
+	priv->chip.of_xlate = of_pwm_xlate_with_flags;
+	priv->chip.of_pwm_n_cells = 3;
+
+	ret = pwmchip_add(&priv->chip);
+	if (ret < 0) {
+		dev_err(dev, "failed to add PWM chip: %pe\n", ERR_PTR(ret));
+		goto err_assert_reset;
+	}
+	dev_set_drvdata(dev, priv);
+	return 0;
+err_assert_reset:
+	reset_control_assert(priv->reset);
+err_disable_clk:
+	clk_disable_unprepare(priv->clk);
+	return ret;
+}
+
+static int aspeed_pwm_remove(struct platform_device *dev)
+{
+	struct aspeed_pwm_data *priv = platform_get_drvdata(dev);
+
+	pwmchip_remove(&priv->chip);
+	reset_control_assert(priv->reset);
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static const struct of_device_id of_pwm_match_table[] = {
+	{
+		.compatible = "aspeed,ast2600-pwm",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_pwm_match_table);
+
+static struct platform_driver aspeed_pwm_driver = {
+	.probe = aspeed_pwm_probe,
+	.remove	= aspeed_pwm_remove,
+	.driver	= {
+		.name = "aspeed-pwm",
+		.of_match_table = of_pwm_match_table,
+	},
+};
+
+module_platform_driver(aspeed_pwm_driver);
+
+MODULE_AUTHOR("Billy Tsai <billy_tsai@aspeedtech.com>");
+MODULE_DESCRIPTION("Aspeed ast2600 PWM device driver");
+MODULE_LICENSE("GPL v2");
